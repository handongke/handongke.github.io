<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从零开始免费搭建自己的博客(一)——本地搭建hexo框架</title>
    <url>/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<blockquote>
<p>​    本文是博客搭建系列文章第一篇，其他文章链接：</p>
<ol>
<li><strong>从零开始免费搭建自己的博客(一)——<a href="https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></strong></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaigee.gitee.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaigee.gitee.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>本文思路：使用 Hexo 框架搭建网站，发布到 GitHub pages 或者 Gitee pages .</p>
<p>首先先看一下最终效果：</p>
<p>GitHub pages 链接(国际站点)：<a href="https://yushuaige.github.io/">杰克小麻雀的博客</a><br>Gitee pages 链接(国内站点)：<a href="https://yushuaigee.gitee.io/">杰克小麻雀的博客</a></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/myblog.gif" alt="myblog"></p>
<hr>
<h2 id="一、Hexo-框架简介"><a href="#一、Hexo-框架简介" class="headerlink" title="一、Hexo 框架简介"></a>一、Hexo 框架简介</h2><p>首先，都 0202 年了，我们想搭建一个网站，当然不用自己从头开始写 html，因为有许多开源的代码可以供我们选择。Hexo 就是一个专门用于博客类网站的开源项目，使用 Node.js 语言开发，GitHub 上目前已经有 31.8k 的 star 了，现在网上大多数的个人博客都是使用这个框架搭建的。Hexo不仅搭建过程简单快捷，配置灵活，可定制型非常高，因此众多大佬开发者为它开发了丰富的主题库，而作为菜鸟我们只需要选择一个符合自己审美的主题直接用就行了，当然如果你懂前端和 js ，也可以自己修改定制，或者自己制作主题并分享到互联网上。</p>
<p> Hexo 中文官网：<a href="https://hexo.io/zh-cn/">hexo.io</a> ，GitHub 地址：<a href="https://github.com/hexojs/hexo">hexojs/hexo</a> 。</p>
<h2 id="二、Hexo-依赖环境安装-：Node-js"><a href="#二、Hexo-依赖环境安装-：Node-js" class="headerlink" title="二、Hexo 依赖环境安装 ：Node.js"></a>二、Hexo 依赖环境安装 ：Node.js</h2><p>Hexo 是使用 Node.js 开发的，所以我们安装 Hexo 之前需要先安装 Node.js 环境。</p>
<p>Node.js 是什么？简单的说 Node.js 就是运行在服务端的 JavaScript 。安装了 Node.js 环境，就可以不用依赖浏览器就可以运行 js 代码，其实它也是基于 Chrome 引擎开发的一个开源项目。简单理解， Node.js 对于 js 代码的作用类似 Python 解释器对于 Python 代码的作用。</p>
<p>这里注意，不是说博客框架必须用 Node.js 来开发，博客框架本质上是一个网站，可以用任何语言开发，也有用 Python 的 Flask/Django 或者 Java 开发的博客框架，只是没有 Hexo 这么流行。</p>
<h3 id="1-官网下载-Node-js"><a href="#1-官网下载-Node-js" class="headerlink" title="1. 官网下载  Node.js"></a>1. 官网下载  Node.js</h3><p>Node.js 中文官网：<a href="https://nodejs.org/zh-cn/">nodejs.org</a></p>
<p>打开官网直接下载安装包就行了，左边是稳定版，右边是尝鲜版。任选一个点击下载，尝鲜版包含了比较新的特性，但是没有经过充分测试。我这里下载了 15.4.0 版本。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220164653416.png" alt="image-20201220164653416"></p>
<p>我这里是用浏览器自带下载器，下载速度还可以，如果没速度可以在下载按钮上右键，选择“复制链接地址”，然后粘贴到迅雷下载。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220165109254.png" alt="image-20201220165109254"></p>
<h3 id="2-安装-Node-js"><a href="#2-安装-Node-js" class="headerlink" title="2. 安装  Node.js"></a>2. 安装  Node.js</h3><p>下载完安装包后双击打开，一路点 Next 就行了。注意这一步是安装额外工具，没必要勾选。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220165451877.png" alt="image-20201220165451877"></p>
<h3 id="3-测试-Node-js-是否安装成功"><a href="#3-测试-Node-js-是否安装成功" class="headerlink" title="3. 测试 Node.js 是否安装成功"></a>3. 测试 Node.js 是否安装成功</h3><p>安装完成后，<kbd>Win</kbd> + <kbd>R</kbd> 打开运行框，输入<code>cmd</code>打开命令行窗口，输入<code>npm -v</code>回车，如果出现版本号说明安装成功。就跟安装完 Python 解释器一样，npm 就类似 Python 中的 pip 工具。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220170553434.png" alt="image-20201220170553434"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220180008301.png" alt="image-20201220180008301"></p>
<h2 id="三、Hexo-依赖环境安装-：Git"><a href="#三、Hexo-依赖环境安装-：Git" class="headerlink" title="三、Hexo 依赖环境安装 ：Git"></a>三、Hexo 依赖环境安装 ：Git</h2><p>作为程序员，Git 应该不陌生，如果你已经安装了 Git，那这一步可以跳过。</p>
<p>Git（读音/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。简单理解就是下载代码的工具，因为 Hexo 是一个托管于 GitHub 上的开源项目，所以安装 Hexo 的时候需要使用 Git 来下载源码和依赖代码，而且后面要将自己的博客发布到 GitHub pages 或者 Gitee pages 上面也需要使用 Git。</p>
<h3 id="1-官网下载-Git"><a href="#1-官网下载-Git" class="headerlink" title="1. 官网下载  Git"></a>1. 官网下载  Git</h3><p>Git 官网：<a href="https://git-scm.com/">git</a></p>
<p>打开官网直接下载安装包就行了。由于网络环境原因，浏览器下载可能会非常慢，可以按照上面的方法，在下载按钮上右键，选择“复制链接地址”，然后粘贴到迅雷下载。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220171653488.png" alt="image-20201220171653488"></p>
<h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装  Git"></a>2. 安装  Git</h3><p>下载完安装包后双击打开，没有特殊需要的话，一路点 Next 就行了。安装完毕，在桌面空白处右键，可以看到多了两个选项。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220172655709.png" alt="image-20201220172655709"></p>
<h3 id="3-测试-Git-是否安装成功"><a href="#3-测试-Git-是否安装成功" class="headerlink" title="3.  测试 Git 是否安装成功"></a>3.  测试 Git 是否安装成功</h3><p>Git 安装完成后，自带了一个命令行窗口，通过上面新增的右键菜单<kbd>Git Bash Here</kbd>就可以打开，比 Windows自带的命令行要好用，后面都使用这个命令行窗口。在桌面空白处右键，选择<kbd>Git Bash Here</kbd>，输入<code>git --version</code>回车，如果出现版本号说明安装成功</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220175806607.png" alt="image-20201220175806607"></p>
<h2 id="四、安装-Hexo"><a href="#四、安装-Hexo" class="headerlink" title="四、安装 Hexo"></a>四、安装 Hexo</h2><p>下面开始正式安装 Hexo，有了前面的准备工作，安装 Hexo 就非常简单了，就跟使用 pip 安装一个 Python 第三方库一样方便。</p>
<h3 id="1-本地安装-hexo"><a href="#1-本地安装-hexo" class="headerlink" title="1. 本地安装 hexo"></a>1. 本地安装 hexo</h3><p>首先在本地新建一个空文件夹，用来存放 Hexo 的文件和以后要写的博客文件，注意不要有中文路径，避免可能出现的问题。我这里建立在 D 盘根目录，取名 MyBlog。</p>
<p>进入新建的文件夹，右键，选择<kbd>Git Bash Here</kbd>，依次输入下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 hexo 框架</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化文件夹</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 hexo 依赖包</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>命令很好理解，第一行安装 hexo 模块，<code>-g</code>表示安装全局模块；第二行是 hexo 初始化，会用 <code>git clone</code>命令去 GitHub 下载一个 hexo 默认模板代码库；第三行是安装依赖包，类似安装 pip 的 requirement 文件，会根据刚下载的代码库中的配置文件，下载并安装所需依赖包。安装成功结果，如下图。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220175707251.png" alt="image-20201220175707251"></p>
<h3 id="2-可能遇到的问题"><a href="#2-可能遇到的问题" class="headerlink" title="2. 可能遇到的问题"></a>2. 可能遇到的问题</h3><ul>
<li><p><strong><code>npm install -g hexo-cli</code>命令执行卡住，或者报错连接不上</strong></p>
<p>可能是 npm 源速度太慢，可以尝试修改淘宝源解决，再重新执行安装命令。npm 源的概念就和 Python 中的 pip 源一样，默认源是<code>https://registry.npmjs.org/</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 npm 源</span></span><br><span class="line">npm config get registry</span><br><span class="line"><span class="meta">#</span><span class="bash"> 临时修改 npm 源安装 hexo (仅本条命令有效)</span></span><br><span class="line">npm --registry=https://registry.npm.taobao.org install -g hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者永久修改 npm 源</span></span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>如果是公司内网使用代理访问外网 (比如<code>ping registry.npmjs.org</code> <code>ping registry.npm.taobao.org</code>都不通)，可以尝试给 npm 配置代理解决，再重新执行安装命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置代理</span></span><br><span class="line">npm config set proxy http://serverip:port</span><br><span class="line">npm confit set https-proxy http:/serverip:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置带用户名密码的代理</span></span><br><span class="line">npm config set proxy http://username:password@serverip:port</span><br><span class="line">npm confit set https-proxy http://username:password@serverip:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消代理</span></span><br><span class="line">npm config delete proxy</span><br><span class="line">npm config delete https-proxy</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>hexo init</code>命令执行卡住，或者报错连接不上</strong></p>
<p>如果是公司内网使用代理访问外网 (比如<code>ping GitHub.com</code> 不通)，可以尝试给 git 配置代理解决，再重新执行初始化命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置代理</span></span><br><span class="line">git config --global http.proxy http://serverip:port</span><br><span class="line">git config --global https.proxy http:/serverip:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置带用户名密码的代理</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：如果密码中带了特殊字符需要进行转义, 将特殊字符替换为下面对应的转义字符即可</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  !   <span class="comment">#   $   &amp;   &#x27;   (    )  *   +   ,   /   :   ;   =   ?   @   [   ]</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> %21 %23 %24 %26 %27 %28 %29 %2A %2B %2C %2F %3A %3B %3D %3F %40 %5B %5D</span></span><br><span class="line">npm config set proxy http://username:password@serverip:port</span><br><span class="line">npm confit set https-proxy http://username:password@serverip:port</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消代理</span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>
<h3 id="3-本地博客效果"><a href="#3-本地博客效果" class="headerlink" title="3. 本地博客效果"></a>3. 本地博客效果</h3></li>
</ul>
<p>前面三条命令执行成功，Hexo 框架在本地就已经搭建好了，下面看看效果。</p>
<p>还是在<kbd>Git Bash</kbd>命令行窗口里，依次执行下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成静态网站</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>或者直接执行<code>hexo g &amp;&amp; hexo s</code>，其中<code>hexo g</code>是 <code>hexo generate</code>命令的简写，<code>hexo s</code>是 <code>hexo server</code>命令的简写。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220204316929.png" alt="image-20201220204316929"></p>
<p>此时，打开浏览器，输入网址<code>http://localhost:4000/</code>，就可以看到我们 Hexo 搭建的博客示例了。此时是默认主题，比较简洁，下一步我们换一个更精美的主题。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220204625063.png" alt="image-20201220204625063"></p>
<h2 id="五、更换-Hexo-博客主题"><a href="#五、更换-Hexo-博客主题" class="headerlink" title="五、更换 Hexo  博客主题"></a>五、更换 Hexo  博客主题</h2><h3 id="1-如何找主题"><a href="#1-如何找主题" class="headerlink" title="1. 如何找主题"></a>1. 如何找主题</h3><p>默认主题非常简洁，适合大佬使用，像我等菜鸟，自己不会做却又想使用花里胡哨的主题，就要学会找主题了。</p>
<p>下面是我寻找主题的三个方法。</p>
<ul>
<li><p><strong>官方网站</strong></p>
<p>Hexo 官网收录了几百个第三方主题，其中有许多中文开发者开发的主题。</p>
<p>在 Hexo 官网点击“主题”，或者直接进入 Hexo 主题页：<a href="https://hexo.io/themes/">themes</a></p>
<p>通过上方的搜索框可以根据标签搜索。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222231238616.png" alt="image-20201222231238616"></p>
</li>
<li><p><strong>Github 搜索</strong></p>
<p>大多数流行的主题都在 GitHub 托管开源了，我们可以直接去 GitHub  下载。</p>
<p>在 Github 官网搜索<code>hexo-theme</code>，选择<code>All GitHub</code>，或者直接进入搜索页：<a href="https://github.com/search?q=hexo-theme">search?q=hexo-theme</a></p>
<p>点击右上角<code>Sort</code>可以选择按<code>Most stars</code>数量排序，根据流行程度找到心仪的主题。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222231133883.png" alt="image-20201222231133883"></p>
</li>
<li><p><strong>网上搜索</strong></p>
<p>直接在搜索引擎搜索<code>Hexo主题推荐</code>，会有许多别人推荐的主题，不过大多数的推荐前面两种方法都能覆盖到，偶尔也能发现一些冷门却又戳中你的审美的宝藏，这就看耐心和运气了。</p>
</li>
</ul>
<h3 id="2-主题推荐"><a href="#2-主题推荐" class="headerlink" title="2. 主题推荐"></a>2. 主题推荐</h3><p>我挑选了几个自己觉得简单美观而又不过分花哨的主题，其实都是 GitHub 热门的，很好发现。这些主题都太漂亮了，以至于我都不知道该选哪个，额。</p>
<p>下面几个主题切换时可能会遇到一些问题，多数是依赖包未安装完整的原因，解决办法见<code>4. 出错解决办法</code>。</p>
<ul>
<li><p><strong>Next</strong></p>
<p>Demo 示例：<a href="https://theme-next.js.org/">NexT</a> | <a href="https://dandyxu.me/">Dandy</a> | <a href="https://raincal.com/">Raincal</a> </p>
<p>GitHub 主页：<a href="https://github.com/iissnan/hexo-theme-next">hexo-theme-next</a></p>
<p>这个是 Hexo 最流行的主题，GitHub 上 15.5k stars，在 Hexo 主题中排行第一。</p>
<p>这个主题跟默认主题一样简洁，但是却漂亮了很多，尤其是文章浏览界面，排版非常干净舒服，大佬必备。</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201221224929253.png" alt="image-20201221224929253"></p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201221222603632.png" alt="image-20201221222603632"></p>
<hr>
</li>
</ul>
<ul>
<li><p><strong>stun</strong></p>
<p>Demo 示例：<a href="https://liuyib.github.io/">Liuyib’s Blog</a></p>
<p>GitHub 主页：<a href="https://github.com/liuyib/hexo-theme-stun">hexo-theme-stun</a></p>
<p>这是一个漂亮、简洁的 Hexo 主题，增加了首页图片，和白天黑夜模式，最重要的是文章浏览界面非常干净美观。我就是看到一篇博客使用的这个主题，特别漂亮，才有了想自己搭博客的强烈愿望。</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608904463540.gif" alt="test"></p>
<hr>
<p>文章浏览界面：</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608904209387.gif" alt="test"></p>
<hr>
</li>
</ul>
<ul>
<li><p><strong>matery</strong></p>
<p>Demo 示例：<a href="http://blinkfox.com/">闪烁之狐</a></p>
<p>GitHub 主页：<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a></p>
<p>同样是一个很漂亮的主题，除了首页的图片，它会为每一篇文章添加一张非常漂亮的封面图，而且集成了很多强大的功能插件，比喻词云，访问统计，音乐播放，视频播放，在线聊天等等。</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608995730975.gif" alt="test"></p>
<hr>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608995969178.gif" alt="test"></p>
<hr>
</li>
</ul>
<ul>
<li><p><strong>butterfly</strong></p>
<p>Demo 示例： <a href="https://butterfly.js.org/">Butterfly</a> |  <a href="https://jerryc.me/">JerryC</a></p>
<p>GitHub 主页：<a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-butterfly</a></p>
<p>这个主题和上面这个同样强大、漂亮，且色彩更加丰富。</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201226233544278.png" alt="image-20201226233544278"></p>
<hr>
<p>![Butterfly - A Simple and Card UI Design theme for ](<a href="https://yushuaigee.gitee.io/myblog/img/Butterfly">https://yushuaigee.gitee.io/myblog/img/Butterfly</a> - A Simple and Card UI Design theme for .png)</p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608997237304.gif" alt="test"></p>
<hr>
</li>
</ul>
<ul>
<li><p><strong>ayer</strong></p>
<p>Demo 示例：<a href="https://shen-yu.gitee.io/">岛</a></p>
<p>GitHub 主页：<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-ayer</a></p>
<p>这个主题在这几个里面算是最小众的，但是功能却不少，界面比较简洁，我就选择了这一款主题。</p>
<hr>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608998694257.gif" alt="test"></p>
<hr>
<p><img src="https://yushuaigee.gitee.io/myblog/img/test-1608998820660.gif" alt="test"></p>
<hr>
</li>
</ul>
<h3 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h3><p>以 <strong>ayer</strong> 主题为例。</p>
<p>在 Hexo 博客根目录(<code>D:\MyBlog</code>)下，右键，选择<code>Git Bash Here</code>，执行下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载主题仓库到 themes 文件夹， git <span class="built_in">clone</span> &lt;仓库地址&gt; themes/&lt;主题名&gt;</span> </span><br><span class="line">git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer</span><br></pre></td></tr></table></figure>
<p>其中，&lt;仓库地址&gt;可以在每个主题的 GitHub 主页获取到。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222231736247.png" alt="image-20201222231736247"></p>
<p>此时打开博客根目录下的 themes 文件夹可以看到多了个 ayer 文件夹。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222231910652.png" alt="image-20201222231910652"></p>
<p>然后用记事本打开博客根目录下的 _config.yml (<code>D:\MyBlog\_config.yml</code>)，找到<code>theme</code>标签，默认值是<code>landscape</code>主题，把它改为要更换的主题名字<code>ayer</code>，然后执行启动命令。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">ayer</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清理 &amp;&amp; 生成 &amp;&amp; 启动</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201222232806309.png" alt="image-20201222232806309"></p>
<p>此时再到浏览器打开网址<code>http://localhost:4000</code>，可以看到我们的博客已经换上一款非常精美的主题。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/Hexo-1608650994521.png" alt="Hexo"></p>
<h3 id="4-出错解决办法"><a href="#4-出错解决办法" class="headerlink" title="4. 出错解决办法"></a>4. 出错解决办法</h3><ul>
<li><p><strong>Next</strong></p>
<p>打开网页<code>http://localhost:4000</code>出现下面的错误，是因为没有安装依赖库<code>hexo-renderer-swig</code></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201221221407462.png" alt="image-20201221221407462"></p>
<p>先 <kbd>Ctrl</kbd> + <kbd>C</kbd> 停止，执行下面命令安装swig，再执行<code>hexo g &amp;&amp; hexo s</code>重新发布。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-swig</span><br></pre></td></tr></table></figure></li>
<li><p><strong>stun</strong></p>
<p>打开网页<code>http://localhost:4000</code>出现下面的错误，是因为没有安装依赖库<code>hexo-renderer-pug</code></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201221223418827.png" alt="image-20201221223418827"></p>
<p>先 <kbd>Ctrl</kbd> + <kbd>C</kbd> 停止，执行下面命令安装pug，再执行<code>hexo g &amp;&amp; hexo s</code>重新发布。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug</span><br></pre></td></tr></table></figure>
<h3 id="5-修改主题"><a href="#5-修改主题" class="headerlink" title="5. 修改主题"></a>5. 修改主题</h3></li>
</ul>
<p>更换主题后，我们需要修改一些基本属性，比如博客名字、首页图片等，或者增加一些个性化属性，比如鼠标指针样式，雪花特效，点击特效等。本篇文章先介绍一下如何修改基本属性，以便于接下来发布网站，在本系列文章第七篇再介绍高级的个性化设置。</p>
<p>Hexo 的配置大部分都保存在博客根目录下的<code>_config.yml</code>文件，我这里是<code>D:\MyBlog\_config.yml</code>，我们叫它<code>根目录配置文件</code>，直接修改这个文件就可以更改博客的一些设置，像前面更换主题就是修改这个文件的参数实现的。关于这个文件的每个参数的详细意义，可以在 <a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a>里查看，每一个参数都有示例，讲解的非常详细。</p>
<p>此外，下载的第三方主题的根目录下也有一个<code>_config.yml</code>文件，比如 <strong>ayer</strong> 主题，我这里就是<code>D:\MyBlog\themes\ayer\_config.yml</code>文件，我们叫它<code>主题配置文件</code>。关于这个文件每个参数的详细意义，可以在每个主题的 GitHub 主页看到详细说明。</p>
<p>如果你使用的是自带的默认主题，那么所有配置都应该在<code>根目录配置文件</code>修改。如果是用的是第三方那个主题，需要两个文件配合修改。</p>
<p>以 <strong>ayer</strong> 主题为例。</p>
<p>首先，按上面第3步更换主题的方法，将<code>根目录配置文件</code>的 theme 属性设置为对应的主题名字 <code>ayer</code>。打开<code>根目录配置文件</code>(D:\MyBlog_config.yml)。</p>
<p>修改第6/10/11行，修改博客基本信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 博客标题，冒号后面自定义</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">半亩方塘</span></span><br><span class="line"><span class="comment"># 博客作者，冒号后面自定义</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">杰克小麻雀</span></span><br><span class="line"><span class="comment"># 网站语言，zh-CN 表示中文，en表示英文。不改成 zh-CN，某些浏览器总会提示是否需要翻译网页</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>
<p>然后，参考 <strong>ayer</strong> 主题官方帮助文档 <a href="https://shen-yu.gitee.io/2019/ayer/">Ayer中文说明</a>。打开 <strong>ayer</strong> 主题的<code>主题配置文件</code>(D:\MyBlog\themes\ayer_config.yml)。</p>
<p>修改第 2 ~ 10行，关掉不需要的侧边栏。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags</span></span><br><span class="line"><span class="comment">#  旅行: /tags/旅行/</span></span><br><span class="line"><span class="comment">#  摄影: http://shenyu-vip.lofter.com</span></span><br><span class="line"><span class="comment">#  友链: /friends</span></span><br><span class="line">  <span class="string">关于我:</span> <span class="string">/2019/about</span></span><br></pre></td></tr></table></figure>
<p>修改第 14 ~ 18行，自定义首页滚动显示的标题。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启动效</span></span><br><span class="line">  <span class="attr">text:</span> <span class="string">欢迎来到杰克小麻雀的博客</span></span><br><span class="line">  <span class="attr">text2:</span> <span class="string">临渊羡鱼，不如退而结网</span> </span><br><span class="line">  <span class="attr">text3:</span> <span class="string">问渠哪得清如许,为有源头活水来</span></span><br></pre></td></tr></table></figure>
<p>修改第 26 ~ 27行，修改网站图标和侧边栏logo。只需要把自己的图标文件按覆盖原来的文件，完整目录为<code>‪D:\MyBlog\themes\ayer\source\favicon.ico</code>。关于图标，推荐一个可以下载各种尺寸图标的网站： <a href="https://www.easyicon.net/">easyicon</a>，也可以把自己准备好的图片进行在线格式转换： <a href="https://convertio.co/zh/ico-converter/">在线ico转换</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浏览器标签栏显示图标</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/favicon.ico</span> </span><br><span class="line"><span class="comment"># 首页侧边栏图标</span></span><br><span class="line"><span class="attr">logo:</span> <span class="string">/favicon.ico</span></span><br></pre></td></tr></table></figure>
<p>修改第 31 ~ 34行，更换封面为自己的图片。先将自己准备好的封面图片 <code>cover8.jpg</code> 放到<code>D:\MyBlog\themes\ayer\source\images</code>目录下。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/images/cover8.jpg</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>第 125 行，关闭右上角的 GitHub forkme。在这个背景下有点丑。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github:</span></span><br><span class="line">  <span class="comment"># (关闭请设置为false)</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/Shen-Yu/hexo-theme-ayer</span></span><br></pre></td></tr></table></figure>
<p>第 83 行，关闭打赏。如果不改下面的图片，你的打赏就直接给主题作者了哦，我没有改打赏图片，所以直接关了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reward_type: 0</span><br></pre></td></tr></table></figure>
<p>以上只修改了一些最最基本的配置，毕竟先发布网站要紧，其他配置可以慢慢来，建议看一下主题配置文件的每一行注释以及官方文档。</p>
<p>改完后，执行<code>hexo g &amp;&amp; hexo s</code>，刷新网页看下效果：</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227192058171.png" alt="image-20201227192058171"></p>
<h2 id="六、本地发布文章"><a href="#六、本地发布文章" class="headerlink" title="六、本地发布文章"></a>六、本地发布文章</h2><p>博客搭建好了，可是现在只有示例的<code>Hello World</code>一篇文章，怎么发布自己的文章呢？</p>
<h3 id="1-新建文章"><a href="#1-新建文章" class="headerlink" title="1. 新建文章"></a>1. 新建文章</h3><p>在博客根目录下右键，选择<kbd>Git Bash Here</kbd>，输入下面命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;我的第一篇博客&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227193541930.png" alt="image-20201227193541930"></p>
<p>此时进入博客根目录下的<code>source\_posts</code>(D:\MyBlog\source_posts)文件夹，可以看到多了一个<code>我的第一篇博客.md</code>文件，这便是新生成的博客文章，因为 Hexo 默认使用 Markdown 格式，所以文件后缀是md，可以使用记事本或者<code>Typora</code>打开并编辑。关于 Markdown 语法和<code>Typora</code>软件的使用，将在本系列文章第四篇中介绍。</p>
<p>此时先 <kbd>Ctrl</kbd> + <kbd>C</kbd> 停止服务器，执行<code>hexo g &amp;&amp; hexo s</code>重新部署，刷新<code>http://localhost:4000/</code>，可以看到博客上多了一篇文章。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227195815659.png" alt="image-20201227195815659"></p>
<h3 id="2-修改模板"><a href="#2-修改模板" class="headerlink" title="2. 修改模板"></a>2. 修改模板</h3><p>打开新建的文章<code>我的第一篇博客.md</code>，可以看到它并不是空的，可是页面上却显示为空，因为 Hexo 根据默认模板帮我们自动生成了一些参数，比如文章创建时间等。这个模板是可更改的。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227194608547.png" alt="image-20201227194608547"></p>
<p>这就需要修改<code>根目录配置文件</code>(‪D:\MyBlog_config.yml)的<code>new_post_name</code>参数了，其中year month day 分别表示创建文章的年月日，这样，再新建文章时，文件名将会自动加上年月日信息，便于通过日期来管理文章。当然，这个时间后面也是可以修改的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year-:month-:day-:title.md</span></span><br></pre></td></tr></table></figure>
<p>编辑上面打开的文章<code>我的第一篇博客.md</code>，添加一些正文，并改一下自动生成三个参数。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227201533968.png" alt="image-20201227201533968"></p>
<p>此时先 <kbd>Ctrl</kbd> + <kbd>C</kbd> 停止服务器，执行<code>hexo g &amp;&amp; hexo s</code>重新部署，刷新<code>http://localhost:4000/</code>，看看效果。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201227201741602.png" alt="image-20201227201741602"></p>
<h2 id="七、后续"><a href="#七、后续" class="headerlink" title="七、后续"></a>七、后续</h2><p>至此，我们的博客已经基本可以用了，只是现在还部署在本地，其实本地的效果就是发布的效果，后面只把这一整套文件都部署到远程服务器上就可以了，针不戳。第一部分说了， 0202 年我们想搭建一个网站不用自己从头开始写 html，有 Hexo 这么优秀的框架供我们选择，而且还完全免费，那么部署网站怎么办呢？</p>
<p>毕竟马上就要 2021 年了，现在部署网站也不用买服务器啦，有 GitHub Page 和 Gitee Page 等免费服务可供我们选择，只需要注册一个帐号就可以了。虽然 GitHub 在程序员界是最流行的，但是由于网络环境原因访问速度很慢，再加上最近的形势变化，说不定哪天这网站甚至会打不开了，所以国内平台Gitee成了一个不错的选择。</p>
<p>网站部署步骤详情见本系列文章的第二篇和第三篇，这两个步骤只需任选其一即可。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(四)——编写Markdown文章利器 Typora</title>
    <url>/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/</url>
    <content><![CDATA[<blockquote>
<p>​    本文是博客搭建系列文章第四篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaige.github.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaige.github.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaige.github.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li><strong>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></strong></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们利用 Hexo 框架搭建了自己的博客网站，可以注意到 Hexo 默认是使用 Markdown 格式的文件的，所以在写新博客之前，我们要先了解一下  Markdown 语法 。</p>
<p>其实我在上大学时也听说过 Markdown，但是一直以为很麻烦，所以之前在 CSDN 的博客都是用富文本编辑器写的，直到在公司试着写了一篇 Markdown 格式的资料，才领略到它的魅力，要不说一个东西这么流行一定有它的道理呢。平时经常看到推荐 Markdown 的文章，都会提到”让你全程双手不离开键盘就可以写出带格式的文章”，我不以为然：我点几下鼠标就能编辑出很美观的格式，也没浪费多少时间啊，何必为了写文章去学一个新的语法呢？</p>
<p>开始用 Markdown 后，我发现选择 Markdown 起码有这些好处：</p>
<ul>
<li>一次编写，到处编辑，不会出现不同版本word显示效果不同的情况。</li>
<li>语法并不麻烦，从零基础到会使用，十分钟足矣。</li>
<li>简洁且漂亮。我也说不上来为啥，可能是因为程序员更懂程序员的审美吧。</li>
<li>有Typora这样的编辑器。这真是一个很大的加分项，如果你用过其他软件写 Markdown 就知道了。</li>
</ul>
<p>本文先介绍 Markdown 语法，再介绍下 Typora 软件的安装和使用。想必使用 Markdown 写文章的人没有不知道 Typora 的，为了系列文章的完整性还是写一篇，主要介绍下我个人觉得比较方便的使用技巧。</p>
<h2 id="一-、使用-Markdown"><a href="#一-、使用-Markdown" class="headerlink" title="一 、使用 Markdown"></a>一 、使用 Markdown</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>创始人 John Gruber 在2004 创造了Markdown语言。 Markdown是一种轻量级标记语言，这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的HTML。</p>
<p>更通俗的解释：我们之所以不用记事本而用 Microsoft Word 写文章，是因为在 Word 里，我们可以用鼠标设置各种标题、字体加粗等格式以及插入表格、插入图片等功能，使文章更加美观易读。而使用 Markdown 语法，在纯文本编辑器中也可以快速写出格式丰富且又美观的文章，手不用离开键盘。</p>
<p>什么叫标记语言，比如在 html 中，用<code>&lt;h1&gt;标题内容&lt;/h1&gt;</code>的形式来标记文字显示的格式，支持 html 解析的软件(浏览器)，读到<code>&lt;h1&gt;</code>就知道这是一个一级标题，然后就把它的字体渲染大一点。Markdown 也是类似的道理，不过作者让标记方法更简单更易读，例如想标记标题就用<code># 标题内容</code>这种形式，我们写文章时随手就能敲出来。当然，想要看到显示效果也需要在支持 Markdown 解析的软件中打开。</p>
<h3 id="十分钟学会-Markdown-语法"><a href="#十分钟学会-Markdown-语法" class="headerlink" title="十分钟学会 Markdown 语法"></a>十分钟学会 Markdown 语法</h3><p>我之所以没有把”十分钟学会…”放在标题里，是因为我这个方法是真的只需要十分钟，我就是这样做的。</p>
<p>下面代码块里的这段文字是 CSDN 的 Markdown 编辑器的新手示例帮助，基本包含了所有的 Markdown 用法，我们只需要在新建一个<code>Markdown示例.md</code>文件，把下面这段话复制进去保存，再用支持md格式的软件(比如后文介绍的Typora)打开，所有的效果所见即所得。先大概浏览一下有哪些效果，写自己的文章时，想用哪种效果直接在示例里面复制源码粘贴到自己的文件再修改就行了。</p>
<p>用这个方法写上一两篇文章，下次再写的时候就不用再参考示例了。因为我们本质上是用语法写文章，没必要上来先背 Markdown 语法，不会的可以现查。就跟学英语不能单纯的背单词而是要多看文章一个道理。</p>
<p>比如，写文章时想用一个按键的效果，就可以到示例文件中找到并复制过来修改一下：</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/md_demo.gif" alt="md_demo"></p>
<p>示例内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">@[<span class="string">TOC</span>](<span class="link">这里写自定义目录标题</span>)</span><br><span class="line"></span><br><span class="line"><span class="section"># 欢迎使用Markdown编辑器</span></span><br><span class="line"></span><br><span class="line">你好！ 这是你第一次使用 <span class="strong">**Markdown编辑器**</span> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</span><br><span class="line"></span><br><span class="line"><span class="section">## 新的改变</span></span><br><span class="line"></span><br><span class="line">我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</span><br><span class="line"></span><br><span class="line"><span class="bullet">  1.</span> <span class="strong">**全新的界面设计**</span> ，将会带来全新的写作体验；</span><br><span class="line"><span class="bullet">  2.</span> 在创作中心设置你喜爱的代码高亮样式，Markdown <span class="strong">**将代码片显示选择的高亮样式**</span> 进行展示；</span><br><span class="line"><span class="bullet">  3.</span> 增加了 <span class="strong">**图片拖拽**</span> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</span><br><span class="line"><span class="bullet">  4.</span> 全新的 <span class="strong">**KaTeX数学公式**</span> 语法；</span><br><span class="line"><span class="bullet">  5.</span> 增加了支持<span class="strong">**甘特图的mermaid语法[^1]**</span> 功能；</span><br><span class="line"><span class="bullet">  6.</span> 增加了 <span class="strong">**多屏幕编辑**</span> Markdown文章功能；</span><br><span class="line"><span class="bullet">  7.</span> 增加了 <span class="strong">**焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置**</span> 等功能，功能按钮位于编辑区域与预览区域中间；</span><br><span class="line"><span class="bullet">  8.</span> 增加了 <span class="strong">**检查列表**</span> 功能。</span><br><span class="line"></span><br><span class="line">[<span class="string">^1</span>]: [<span class="string">mermaid语法说明</span>](<span class="link">https://mermaidjs.github.io/</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## 功能快捷键</span></span><br><span class="line"></span><br><span class="line">撤销：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Z<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">重做：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Y<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">加粗：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>B<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">斜体：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>I<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">标题：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>H<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">无序列表：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>U<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">有序列表：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>O<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">检查列表：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>C<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">插入代码：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>K<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">插入链接：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>L<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">插入图片：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Shift<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>G<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">查找：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>F<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line">替换：<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl/Command<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> + <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>G<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">## 合理的创建标题，有助于目录的生成</span></span><br><span class="line"></span><br><span class="line">直接输入1次<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>#<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>，并按下<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>space<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>后，将生成1级标题。</span><br><span class="line">输入2次<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>#<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>，并按下<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>space<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>后，将生成2级标题。</span><br><span class="line">以此类推，我们支持6级标题。有助于使用<span class="code">`TOC`</span>语法后生成一个完美的目录。</span><br><span class="line"></span><br><span class="line"><span class="section">## 如何改变文本的样式</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">*强调文本*</span> <span class="emphasis">_强调文本_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**加粗文本**</span> <span class="strong">__加粗文本__</span></span><br><span class="line"></span><br><span class="line">==标记文本==</span><br><span class="line"></span><br><span class="line">~~删除文本~~</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 引用文本</span></span><br><span class="line"></span><br><span class="line">H~2~O is是液体。</span><br><span class="line"></span><br><span class="line">2^10^ 运算结果是 1024.</span><br><span class="line"></span><br><span class="line"><span class="section">## 插入链接与图片</span></span><br><span class="line"></span><br><span class="line">链接: [<span class="string">link</span>](<span class="link">https://www.csdn.net/</span>).</span><br><span class="line"></span><br><span class="line">图片: ![<span class="string">Alt</span>](<span class="link">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</span>)</span><br><span class="line"></span><br><span class="line">带尺寸的图片: ![<span class="string">Alt</span>](<span class="link">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw =30x30</span>)</span><br><span class="line"></span><br><span class="line">居中的图片: ![<span class="string">Alt</span>](<span class="link">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</span>)</span><br><span class="line"></span><br><span class="line">居中并且带尺寸的图片: ![<span class="string">Alt</span>](<span class="link">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center =30x30</span>)</span><br><span class="line"></span><br><span class="line">当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</span><br><span class="line"></span><br><span class="line"><span class="section">## 如何插入一段漂亮的代码片</span></span><br><span class="line"></span><br><span class="line">去[<span class="string">博客设置</span>](<span class="link">https://mp.csdn.net/console/configBlog</span>)页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <span class="code">`代码片`</span>.</span><br><span class="line"></span><br><span class="line">​<span class="code">```javascript</span></span><br><span class="line"><span class="code">// An highlighted block</span></span><br><span class="line"><span class="code">var foo = &#x27;bar&#x27;;</span></span><br><span class="line"><span class="code">​```</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 生成一个适合你的列表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 项目</span><br><span class="line"><span class="bullet">  -</span> 项目</span><br><span class="line"><span class="bullet">    -</span> 项目</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 项目1</span><br><span class="line"><span class="bullet">2.</span> 项目2</span><br><span class="line"><span class="bullet">3.</span> 项目3</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [ ] 计划任务</span><br><span class="line"><span class="bullet">-</span> [x] 完成任务</span><br><span class="line"></span><br><span class="line"><span class="section">## 创建一个表格</span></span><br><span class="line"></span><br><span class="line">一个简单的表格是这么创建的：</span><br><span class="line"></span><br><span class="line">| 项目 | Value |</span><br><span class="line">| ---- | ----- |</span><br><span class="line">| 电脑 | $1600 |</span><br><span class="line">| 手机 | $12   |</span><br><span class="line">| 导管 | $1    |</span><br><span class="line"></span><br><span class="line"><span class="section">### 设定内容居中、居左、居右</span></span><br><span class="line"></span><br><span class="line">使用<span class="code">`:---------:`</span>居中</span><br><span class="line">使用<span class="code">`:----------`</span>居左</span><br><span class="line">使用<span class="code">`----------:`</span>居右</span><br><span class="line"></span><br><span class="line">|     第一列     |         第二列 | 第三列         |</span><br><span class="line">| :------------: | -------------: | :------------- |</span><br><span class="line">| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 |</span><br><span class="line"></span><br><span class="line"><span class="section">### SmartyPants</span></span><br><span class="line"></span><br><span class="line">SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：</span><br><span class="line">|    TYPE   |ASCII                          |HTML</span><br><span class="line">|----------------|-------------------------------|-----------------------------|</span><br><span class="line">|Single backticks|<span class="code">`&#x27;Isn&#x27;t this fun?&#x27;`</span>            |&#x27;Isn&#x27;t this fun?&#x27;            |</span><br><span class="line">|Quotes          |<span class="code">`&quot;Isn&#x27;t this fun?&quot;`</span>            |&quot;Isn&#x27;t this fun?&quot;            |</span><br><span class="line">|Dashes          |<span class="code">`-- is en-dash, --- is em-dash`</span>|-- is en-dash, --- is em-dash|</span><br><span class="line"></span><br><span class="line"><span class="section">## 创建一个自定义列表</span></span><br><span class="line"></span><br><span class="line">Markdown</span><br><span class="line">:  Text-to-HTML conversion tool</span><br><span class="line"></span><br><span class="line">Authors</span><br><span class="line">:  John</span><br><span class="line">:  Luke</span><br><span class="line"></span><br><span class="line"><span class="section">## 如何创建一个注脚</span></span><br><span class="line"></span><br><span class="line">一个具有注脚的文本。[^2]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^2</span>]: <span class="link">注脚的解释</span></span><br><span class="line"></span><br><span class="line"><span class="section">##  注释也是必不可少的</span></span><br><span class="line"></span><br><span class="line">Markdown将文本转换为 HTML。</span><br><span class="line"></span><br><span class="line"><span class="emphasis">*[HTML]:   超文本标记语言</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## KaTeX数学公式</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">您可以使用渲染LaTeX数学表达式 [<span class="string">KaTeX</span>](<span class="link">https://khan.github.io/KaTeX/</span>):</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Gamma公式展示 $\Gamma(n) = (n-1)!\quad\forall</span></span><br><span class="line"><span class="emphasis">n\in\mathbb N$ 是通过欧拉积分</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">$$</span></span><br><span class="line"><span class="emphasis">\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&gt; 你可以找到更多关于的信息 <span class="strong">**LaTeX**</span> 数学表达式[<span class="string">here</span>][<span class="symbol">1</span>].</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## 新的甘特图功能，丰富你的文章</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">​```mermaid</span></span><br><span class="line"><span class="emphasis">gantt</span></span><br><span class="line"><span class="emphasis">        dateFormat  YYYY-MM-DD</span></span><br><span class="line"><span class="emphasis">        title Adding GANTT diagram functionality to mermaid</span></span><br><span class="line"><span class="emphasis">        section 现有任务</span></span><br><span class="line"><span class="emphasis">        已完成               :done,    des1, 2014-01-06,2014-01-08</span></span><br><span class="line"><span class="emphasis">        进行中               :active,  des2, 2014-01-09, 3d</span></span><br><span class="line"><span class="emphasis">        计划一               :         des3, after des2, 5d</span></span><br><span class="line"><span class="emphasis">        计划二               :         des4, after des3, 5d</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- 关于 <span class="strong">**甘特图**</span> 语法，参考 [<span class="string">这儿</span>][<span class="symbol">2</span>],</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## UML 图表</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">可以使用UML图表进行渲染。 [<span class="string">Mermaid</span>](<span class="link">https://mermaidjs.github.io/</span>). 例如下面产生的一个序列图：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">​```mermaid</span></span><br><span class="line"><span class="emphasis">sequenceDiagram</span></span><br><span class="line"><span class="emphasis">张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?</span></span><br><span class="line"><span class="emphasis">李四--&gt;&gt;王五: 你最近怎么样，王五？</span></span><br><span class="line"><span class="emphasis">李四--x 张三: 我很好，谢谢!</span></span><br><span class="line"><span class="emphasis">李四-x 王五: 我很好，谢谢!</span></span><br><span class="line"><span class="emphasis">Note right of 王五: 李四想了很长时间, 文字太长了<span class="xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>不适合放在一行.</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">李四--&gt;&gt;张三: 打量着王五...</span></span><br><span class="line"><span class="emphasis">张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">这将产生一个流程图。:</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">​```mermaid</span></span><br><span class="line"><span class="emphasis">graph LR</span></span><br><span class="line"><span class="emphasis">A[长方形] -- 链接 --&gt; B((圆))</span></span><br><span class="line"><span class="emphasis">A --&gt; C(圆角长方形)</span></span><br><span class="line"><span class="emphasis">B --&gt; D&#123;菱形&#125;</span></span><br><span class="line"><span class="emphasis">C --&gt; D</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- 关于 <span class="strong">**Mermaid**</span> 语法，参考 [<span class="string">这儿</span>][<span class="symbol">3</span>],</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## FLowchart流程图</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">我们依旧会支持flowchart的流程图：</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">​```mermaid</span></span><br><span class="line"><span class="emphasis">flowchat</span></span><br><span class="line"><span class="emphasis">st=&gt;start: 开始</span></span><br><span class="line"><span class="emphasis">e=&gt;end: 结束</span></span><br><span class="line"><span class="emphasis">op=&gt;operation: 我的操作</span></span><br><span class="line"><span class="emphasis">cond=&gt;condition: 确认？</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">st-&gt;op-&gt;cond</span></span><br><span class="line"><span class="emphasis">cond(yes)-&gt;e</span></span><br><span class="line"><span class="emphasis">cond(no)-&gt;op</span></span><br><span class="line"><span class="emphasis">​```</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- 关于 <span class="strong">**Flowchart流程图**</span> 语法，参考 [<span class="string">这儿</span>][<span class="symbol">4</span>].</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">## 导出与导入</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">###  导出</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <span class="strong">**文章导出**</span> ，生成一个.md文件或者.html文件进行本地保存。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">### 导入</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，</span></span><br><span class="line"><span class="emphasis">继续你的创作。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">[1]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference</span></span><br><span class="line"><span class="emphasis">[2]: https://mermaidjs.github.io/</span></span><br><span class="line"><span class="emphasis">[3]: https://mermaidjs.github.io/</span></span><br><span class="line"><span class="emphasis">[4]: http://adrai.github.io/flowchart.js/</span></span><br></pre></td></tr></table></figure>
<h2 id="二、使用-Typora"><a href="#二、使用-Typora" class="headerlink" title="二、使用 Typora"></a>二、使用 Typora</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Typora 是一款支持实时预览的 Markdown 文本编辑器，现在支持有 OS X、Windows、Linux 三个平台的版本。其实像 Pycharm 等 IDE 也支持 md 语法，不过大都是左侧显示源码，右侧显示效果，或者只显示源码/效果，包括 CSDN 的在线 Markdown 编辑器也是这样。而Typora 创新的提出实时预览这种方式，源码和显示效果合一显示，所见即所得，非常的方便。</p>
<p>为什么要用 Typora ？就和你为什么用 jetbrains 全家桶写代码一样，因为它们漂亮、简洁、强大。</p>
<p>这些特点在它的官网(<a href="https://typora.io/">Typora</a>)就能看出来。直接拉到页面最后，下载对应版本安装就可以了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109193749369.png" alt="image-20210109193749369"></p>
<p>网上有很多介绍的 Typora 的文章，推荐两篇写的很详细的文章。</p>
<p>深度介绍(必看)：<a href="https://sspai.com/post/54912">少数派:Typora 完全使用详解</a></p>
<p>快捷键介绍：<a href="https://www.cnblogs.com/hider/p/11614688.html">Typora入门</a></p>
<p>设置：**</p>
<h3 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h3><p>下面介绍几个我觉得很有用很方便的设置。</p>
<p>打开<code>文件</code> –&gt; <code>偏好设置</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109230837590.png" alt="image-20210109230837590"></p>
<h4 id="1-打开自动保存"><a href="#1-打开自动保存" class="headerlink" title="1. 打开自动保存"></a>1. 打开自动保存</h4><p>选择<code>通用</code>，勾选 <code>自动保存</code>。这样软件会定期自动保存我们的编辑内容，防止异常退出时忘记保存。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109231108977.png" alt="image-20210109231108977"></p>
<h4 id="2-打开成对符号"><a href="#2-打开成对符号" class="headerlink" title="2. 打开成对符号"></a>2. 打开成对符号</h4><p>选择<code>编辑器</code>，勾选 <code>匹配括号和引号</code>和<code>匹配 Markdown 字符</code>。这样当我们输入括号(<code>[]()&#123;&#125;</code>)等成对的符号时，只需要输入左边一半，软件会自动补充右边一半。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109231716512.png" alt="image-20210109231716512"></p>
<h4 id="3-打开首行缩进"><a href="#3-打开首行缩进" class="headerlink" title="3. 打开首行缩进"></a>3. 打开首行缩进</h4><p>选择<code>Markdown</code>，勾选 <code>首行缩进</code>。这个看自己需要，只是在 Typora 本地显示中首行缩进，因为 Markdown 语法本身并没有支持首行缩进的符号，所以文件拿到别的地方不会有首行缩进的效果。如果非要首行缩进，可以在段落开头加个<code>&amp;emsp;&amp;emsp;</code>可以在其他地方打开时也能首行缩进。这个仁者见仁，智者见智，开始我是很喜欢首行缩进的，后来发现不缩进也挺好看的，现在已经习惯了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109232158103.png" alt="image-20210109232158103"></p>
<h4 id="4-打开自动保存图片"><a href="#4-打开自动保存图片" class="headerlink" title="4. 打开自动保存图片"></a>4. 打开自动保存图片</h4><p>选择<code>图像</code>，选择<code>插入图片时...</code>自动执行的动作：</p>
<ul>
<li>默认是<code>无特殊操作</code>，当你写文章时，粘贴或者拖动进来的图片会自动保存在<code>C:\Users\&lt;电脑用户名&gt;\AppData\Roaming\Typora\typora-user-images</code>目录下。</li>
<li><code>复制图片到当前文件夹</code>，选择该选项时，粘贴或者拖动进来的图片会自动保存在当前编辑的文件同目录下。</li>
<li><code>复制图片到 ./$&#123;filename&#125;.assets 文件夹</code>，选择该选项时，粘贴或者拖动图片进来，会自动在当前编辑的文件目录下新建文件夹<code>$&#123;filename&#125;.assets</code>并将图片复制到该文件夹下，其中``${filename}<code>是当前编辑的文件名，不包含</code>.md`。</li>
<li><code>上传图片</code>，选择该选项时，粘贴或者拖动图片进来，会根据下面的<code>上传服务设置</code>将图片自动上传到图床，平时最好用这个设置，详细内容在下一篇文章中介绍。</li>
<li><code>复制到指定路经</code>，选择该选项时，可以自己填入一个文件夹，粘贴或者拖动图片进来，会自动创建文件夹并将图片复制进去。</li>
</ul>
<p>建议选择<code>上传图片</code>，按照下篇文章的方法将图片保存在图床。当然，如果写的的文章只保存在本地或者需要断网时浏览，那么可以选择其他几个选项。我有一次手贱把图片文件夹删了，辛苦几天截得图片和录的 GIF 全没了，经过这次教训，我感觉还是上传到图床比较保险，可惜不能同时选择保存到本地和上传图床。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210109233120920.png" alt="image-20210109233120920"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>现在我们可以先在本地写好博客，然后按照前两篇文章的方法将它们发布到网站上了。不过还不够完美，我们一直没说带图片的文章要怎么处理，其实 Hexo 本身支持将图片打包发布，需要新建博客时创建对应的图片文件夹，有点麻烦就不介绍了。我们既然已经用了 Markdown 格式，图片在 Markdown 文件里不过就是一个路径或者网址，为什么不用更简便的方法呢？接下来第五篇文章，就介绍怎么搭建自己的免费图床并搭配 Typora 使用。</p>
<p>相信我，用上了 Markdown和 Typora ，你会爱上写博客的。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(五)——Typora + PicGo + GitHub/Gitee图床</title>
    <url>/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<blockquote>
<p>   ​    本文是博客搭建系列文章第五篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaige.github.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaige.github.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaige.github.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li><strong>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></strong></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们搭建好了博客，选择了 Typora 作为创作软件，但是现在一篇博客从写完到发布到网站还是有许多步骤要手动处理，比如处理图片路径，发布更新等。写博客已经很耗费时间了，我们肯定不希望花费大量时间在部署上，毕竟使用 CSDN 等平台写博客时只需一键就可以发布博客，所以有必要把一些重复工作自动化，提升自己的创作体验。接下来两篇文章就做这件事情，首先是完成图床的搭建，然后是通过脚本一键发布博客。</p>
<p>本篇文章先介绍怎么搭建自己的免费图床。我尝试了各种组合方案，最终选用了最方便的 Typora + PicGo + GitHub + jsDelivr CDN加速的方案。不过既然前面讲了使用 Gitee Pages 建站，这里也介绍一下使用 Gitee 搭建图床的方法。关于 Typora 的使用介绍见上一篇文章。</p>
<h2 id="什么是图床"><a href="#什么是图床" class="headerlink" title="什么是图床"></a>什么是图床</h2><p>图床是什么？Picture bed？No ，其实是 Picture host，即提供外链访问的图片存储服务器（看了《西部世界》，见到 “host” 最先想到的竟是“接待员” -.-）。通俗讲就是你把图片上传到一个图床提供者的图片服务器上，它会生成一个存储链接，你就可以随时通过这个链接就下载这个图片，而且还可以把这个链接放到 html 里或者 Markdown 文件里，浏览时再由浏览器或者阅读器自动加载出来。</p>
<p>具体有什么用呢？对于我们的 Markdown 格式的博客而言，图片就成了一个文本，你可以把文章复制到 CSDN/简书/知乎/个人博客等地方，每次换地方不需要重新上传图片，这些网站都能根据图床链接将图片加载出来。这样一说是不是发现“图床”这个翻译还挺贴切的。</p>
<p>当然也有翻车的时候，有时候我们浏览网页时，发现文字都能加载出来，图片都变成了一个个的叉号，这就是因为图床挂了，网站无法根据链接加载到图片，所以图床的稳定性就很重要了。还有一个问题，就是外链大家都可以访问，那么你的图片就很容易被盗链，别人直接用你的链接就可以下载到你的高清大图，版权问题不说，如果你是使用付费图床，一般是按访问流量收费，别人在文章中直接用你的图片链接，走的都是你的流量费，不过现在的图床都提供了防盗链方案。</p>
<p>图床服务国内的有微博图床、聚合图床、七牛云、阿里云、腾讯云等，国外的有 imgur、imgbox、SM图床等，大都是要收费的。此外也有些免费的图床服务，但是不敢用啊，万一哪天没了。</p>
<p>其实我们可以利用 GitHub 的存储能力和对外开放访问的特点，将 GitHub 仓库作为图床。不但免费，而且不用担心图床挂掉，毕竟如果 GitHub 挂了，部署在 GitHub Pages 的博客网站也打不开了，还管什么图片能不能加载出来。当然也请大家合理利用资源，GitHub仓库有 1G 大小的上限。</p>
<h2 id="什么是-PicGo"><a href="#什么是-PicGo" class="headerlink" title="什么是 PicGo"></a>什么是 PicGo</h2><p>PicGo 是一位中国开发者基于 electron-vue 开发的用于快速上传图片并获取图片 URL 链接的开源工具，GitHub主页：<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>，作者博客：<a href="https://molunerfinn.com/">MARKSZのBlog</a>。</p>
<p>写文章需要引用图片时，我们要打开浏览器将图片上传到图床服务器，再把链接复制粘贴到文章中。这太影响效率了，能不能每次插入图片时自动把图片上传并返回链接地址呢？PicGo 便是做这件事的软件，只要配置好图床类型，就可以直接拖拽图片进行上传并自动返回图片链接，配合 Typora 还可以实现在文章中插入图片时自动上传并替换为链接内容，完全不用感知上传图片的过程。</p>
<p>PicGo 本体支持七牛云、腾讯云、又拍云、阿里云、SM、Imgur、GitHub这些图床，而且还支持自己扩展第三方图床的支持插件，比如就有人开发了 Gitee 的插件。更多介绍见<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E5%90%AC%E8%AF%B4%E4%BD%A0%E4%B9%9F%E6%83%B3%E7%94%A8picgo">官方文档</a>，下载地址：<a href="https://molunerfinn.com/PicGo/">PicGo</a></p>
<p>打开下载地址，选择一个版本点进去，点击下载对应的安装包安装即可。同样的，如果下载速度太慢，右键<code>复制链接地址</code>，粘贴到迅雷下载。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000207889.png" alt="image-20210113000207889"></p>
<h2 id="GitHub-图床"><a href="#GitHub-图床" class="headerlink" title="GitHub 图床"></a>GitHub 图床</h2><h4 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1. 新建仓库"></a>1. 新建仓库</h4><p>第一步要先在 GitHub 新建一个仓库用于存储图片。</p>
<p>打开自己 GitHub <a href="https://github.com/">主页</a>，点击<kbd>New</kbd>新建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000300203.png" alt="image-20210113000300203"></p>
<p><code>Repository name</code>填写仓库名字，<code>Description</code>填写仓库描述，勾选<code>Add a README file</code>，点击<kbd>Create repository</kbd>创建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000500752.png" alt="image-20210113000500752"></p>
<h4 id="2-获取-repo-tokens"><a href="#2-获取-repo-tokens" class="headerlink" title="2. 获取 repo tokens"></a>2. 获取 repo tokens</h4><p>这个 token 主要用于让 PicGo 有权限往我们的仓库 push 代码(图片)。</p>
<p>点击自己的头像，选择<kbd>Settings</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000533777.png" alt="image-20210113000533777"></p>
<p>选择<kbd>Developer settings</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000731905.png" alt="image-20210113000731905"></p>
<p>点击 <kbd>Personal access tokens</kbd>。然后点击<kbd>Generate new token</kbd>，因为是敏感操作，此时需要确认密码。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113000830696.png" alt="image-20210113000830696"></p>
<p><code>Note</code>填写 token 用途，用于备忘。下面只需要勾选<code> repo</code>，只给更新仓库的权限。最后点击最下面的<kbd>Generate token</kbd>创建成功。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113001007861.png" alt="image-20210113001007861"></p>
<p>复制字符串下一步使用。注意，为了安全起见此字符串只会出现一次，点击其他页面后就无法再查看了，需要重新创建，所以最好先保存到本地编辑器中。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113001256619.png" alt="image-20210113001256619"></p>
<h4 id="3-PicGo-配置"><a href="#3-PicGo-配置" class="headerlink" title="3. PicGo 配置"></a>3. PicGo 配置</h4><p>打开 PicGo ,选择<code>图床设置</code>，选择<code>GitHub图床</code>，填写参数：</p>
<ul>
<li><code>设定仓库名</code>，填写格式为<code>用户名/仓库名</code></li>
<li><code>设定分支名</code>，填写默认分支<code>master</code>或者<code>main</code></li>
<li><code>设定Token</code>，填写上一步获取的 token 值</li>
<li><code>指定存储路径</code>，选填，可以自定义名称，比如用年月来分类，不填图片会上传在仓库根目录。</li>
<li><code>设定自定义域名</code>，用于修改返回的 url 前缀，不填则返回原始 url。后面配置CDN加速需要更改此项。</li>
</ul>
<p>选择<kbd>设为默认图床</kbd>，点击<kbd>确定</kbd>保存配置。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112233928390.png" alt="image-20210112233928390"></p>
<p>配置完成后，点击<code>上传区</code>，随便选择电脑上一张图片拖动到上传区，上传成功后会弹窗提示，将该 url 复制到浏览器打开就可以看到图片。可以在<code>PicGo设置</code>，打开<code>上传后自动复制URL</code>，这样上传成功后图片 url 会自动复制在剪贴板，可以直接粘贴到记事本。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113223506305.png" alt="image-20210113223506305"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112235620646.png" alt="image-20210112235620646"></p>
<h4 id="4-CDN-加速-jsDelivr"><a href="#4-CDN-加速-jsDelivr" class="headerlink" title="4. CDN 加速(jsDelivr)"></a>4. CDN 加速(jsDelivr)</h4><p>从上一步可以看到 GitHub 存储的图片地址是 <code>https://raw.githubusercontent.com</code> 开头的网址，这个域名在某些地方可能打不开或者很慢导致图片加载失败，所以我们需要对图片配置 CDN 加速。</p>
<p>CDN的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。具体原理见<a href="https://www.jianshu.com/p/1dae6e1680ff">CDN加速原理</a>。通俗来讲，就是 CDN 服务商在全球各个地方建立服务器把要加速的站点进行缓存备份，当你访问站点时实际上是从离你最近的服务器访问缓存，速度自然就快了。</p>
<p>既然要搭建这么多服务器，服务肯定是要收费的吧。在这个互联网时代，还真有免费 CDN —— jsDelivr CDN，不仅开源免费而且在中国大陆建有许多服务站点，官网还声称是中国大陆唯一拥有许可证的公有 CDN，所以速度、稳定性都可以放心了。</p>
<p>打开<a href="https://www.jsdelivr.com/">jsDelivr CDN 官网</a>，可以看到 jsDelivr 支持 npm、GitHub、WordPress三个站点的加速，用于我们的GitHub图床是再适合不过了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112225345331.png" alt="image-20210112225345331"></p>
<p>在浏览器输入<code>https://cdn.jsdelivr.net/gh/用户名/仓库名/</code>，(注意最后的<code>/</code>不要丢)，可以打开我们在 GitHub 上创建的仓库的文件列表，说明我们在 Github 上创建的仓库已经默认被 jsDelivr 缓存了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112232127381.png" alt="image-20210112232127381"></p>
<p>所以只要把资源链接中的前面部分更改一下就可以使用 CDN 加速了。</p>
<p>例如，</p>
<p>原始图片地址的格式为<code>https://raw.githubusercontent.com/用户名/仓库名/分支名/目录/图片名.png</code>，<code>https://raw.githubusercontent.com/yushuaige/myblog/master/img/image-20201219114500183.png</code>，</p>
<p>更改后的图片地址的格式<code>https://cdn.jsdelivr.net/gh/用户名/仓库名@分支名/目录/图片名.png</code>，</p>
<p><code>https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20201219114500183.png</code>。</p>
<p>可以分别打开一下两个图片网址感受一下速度区别。</p>
<p><strong>PicGo 中需要改一下自定义域名</strong>，之后上传图片自动生成的链接就是 jsDelivr 的链接了。具体就是在<code>设定自定义域名</code>填写<code>https://cdn.jsdelivr.net/gh/用户名/仓库名@master</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112232746338.png" alt="image-20210112232746338"></p>
<h4 id="5-Typora-配置"><a href="#5-Typora-配置" class="headerlink" title="5. Typora 配置"></a>5. Typora 配置</h4><p>打开<code>文件</code>，<code>偏好设置</code>，<code>图像</code>，选择插入图片时<code>上传图片</code>，勾选图中三个选项，上传服务设定选择<code>PicGo (app)</code>，PicGo 路径通过后面的文件夹选择自己电脑上 PicGo 的安装路径。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112233235226.png" alt="image-20210112233235226"></p>
<p>此时，使用 Typora 编辑文件，拖入或者粘贴图片时，会自动调用 PicGo 将图片上传到我们的 GitHub 图床，并把返回的图片链接粘贴到文章中，快去试试吧。</p>
<h2 id="Gitee-图床"><a href="#Gitee-图床" class="headerlink" title="Gitee 图床"></a>Gitee 图床</h2><h4 id="1-新建仓库-1"><a href="#1-新建仓库-1" class="headerlink" title="1. 新建仓库"></a>1. 新建仓库</h4><p>第一步要先在 Gitee 新建一个仓库用于存储图片。</p>
<p>打开自己 Gitee <a href="https://gitee.com/">主页</a>，点击右上角的<kbd>+</kbd>号新建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113220514529.png" alt="image-20210113220514529"></p>
<p>依次填写<code>仓库名称</code>，<code>路径</code>，<code>仓库介绍</code>，注意要勾选<code>公开</code>和<code>使用Readme文件初始化这个仓库</code>，最后点击<kbd>创建</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113221426230.png" alt="image-20210113221426230"></p>
<h4 id="2-获取私人令牌"><a href="#2-获取私人令牌" class="headerlink" title="2. 获取私人令牌"></a>2. 获取私人令牌</h4><p>同样的，<code>私人令牌</code>和 GitHub 上的 token 一样，主要用于让 PicGo 有权限往我们的仓库 push 代码(图片)。</p>
<p>点击自己的头像，选择<code>设置</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113222056606.png" alt="image-20210113222056606"></p>
<p>点击<code>私人令牌</code>，选择<kbd>生成新令牌</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113222420963.png" alt="image-20210113222420963"></p>
<p>同样的，我们只勾选更新代码的权限。填写<code>私人令牌描述</code>，点击<kbd>提交</kbd>。因为是敏感操作，此时需要确认密码。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113222755852.png" alt="image-20210113222755852"></p>
<p>复制字符串下一步使用。注意，为了安全起见此字符串只会出现一次，点击其他页面后就无法再查看了，需要重新创建，所以最好先保存到本地编辑器中。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113223101983.png" alt="image-20210113223101983"></p>
<h4 id="3-PicGo-配置-1"><a href="#3-PicGo-配置-1" class="headerlink" title="3. PicGo 配置"></a>3. PicGo 配置</h4><p>PicGo 本体没有支持 Gitee ，所以需要下载一个插件，有人己经写好了。</p>
<p>打开 PicGo ，点击 <code>插件设置</code>，搜索框输入<code>gitee</code>，目前有两个插件应该都能用，任选一个安装，这里我选择的后面那个。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113225243341.png" alt="image-20210113225243341"></p>
<p>安装好插件后，这时再选择<code>图床设置</code>，选择<code>gitee</code>，填写参数：</p>
<ul>
<li><code>repo</code>，填写格式为<code>用户名/仓库名</code></li>
<li><code>branch</code>，填写默认分支<code>master</code></li>
<li><code>token</code>，填写上一步获取的私人令牌的值</li>
<li><code>path</code>，选填，可以自定义名称，不填图片会上传在仓库根目录。</li>
<li><code>customPath</code>，这个会在上一个参数的基础上再创建一层子文件夹用于按年、年月或年季来分类保存。</li>
<li><code>customUrl</code>，用于修改返回的 url 前缀，不填则返回原始 url。后面解决<code>文件大于1M，登录后可见</code>的问题需要更改此项。</li>
</ul>
<p>在 PicGo 里，GitHub 的设置都是中文的， Gitee 插件的设置反而都是英文的，有点意思hh。</p>
<p>选择<kbd>设为默认图床</kbd>，点击<kbd>确定</kbd>保存配置。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113224703801.png" alt="image-20210113224703801"></p>
<p>配置完成后，点击<code>上传区</code>，随便选择电脑上一张图片拖动到上传区，上传成功后会弹窗提示，将该 url 复制到浏览器打开就可以看到图片。可以在<code>PicGo设置</code>，打开<code>上传后自动复制URL</code>，这样上传成功后图片 url 会自动复制在剪贴板，可以直接粘贴到记事本。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112235111559.png" alt="image-20210112235111559"></p>
<p><img src="https://gitee.com/yushuaigee/myblog/raw/master/img/image-20210113224024050.png" alt="image-20210113224024050"></p>
<h4 id="4-Typora-配置"><a href="#4-Typora-配置" class="headerlink" title="4. Typora 配置"></a>4. Typora 配置</h4><p>打开<code>文件</code>，<code>偏好设置</code>，<code>图像</code>，选择插入图片时<code>上传图片</code>，勾选图中三个选项，上传服务设定选择<code>PicGo (app)</code>，PicGo 路径通过后面的文件夹选择自己电脑上 PicGo 的安装路径。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210112233235226.png" alt="image-20210112233235226"></p>
<p>此时，使用 Typora 编辑文件，拖入或者粘贴图片时，会自动调用 PicGo 将图片上传到我们的 Gitee 图床，并把返回的图片链接粘贴到文章中，快去试试吧。</p>
<h4 id="5-解决”文件大于1M，登录后可见”问题"><a href="#5-解决”文件大于1M，登录后可见”问题" class="headerlink" title="5. 解决”文件大于1M，登录后可见”问题"></a>5. 解决”文件大于1M，登录后可见”问题</h4><p>从上一步可以看到 Gitee 存储的图片地址是 <code>https://gitee.com/yushuaigee/myblog/raw</code> 开头的网址，这个域名是国内站点，速度很快，无需配置CDN加速，图床配置好之后，图片上传成功，在浏览器也能打开，看似没毛病，其实暗藏玄机。</p>
<p>如果你上传的图片大于 1M ，不管是在下一步的 Typora 中还是在浏览器网页中，是无法加载出图片的，比如这张图片<code>https://gitee.com/yushuaigee/myblog/raw/master/img/myblog.gif</code>，输入到浏览器会显示<code>文件大于1M，登录后可见</code>。如果能打开是因为你前面已经登录了 Gitee 了，浏览器新建一个无痕窗口就打不开了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113230821769.png" alt="image-20210113230821769"></p>
<p>可是别人在浏览我们博客时不可能要先登录个 Gitee 吧，所以要想办法解决一下。前面我们将博客仓库打开 Gitee Pages 功能，其他人可以访问我们博客仓库里的博客了，图床仓库也一样，打开它的  Gitee Pages 功能，无需登陆就可以访问里面的图片了。</p>
<p>进入图床仓库主页，点击<code>服务</code>，<code>Gitee Pages</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113231334002.png" alt="image-20210113231334002"></p>
<p>点击<code>启动</code>部署。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113232431704.png" alt="image-20210113232431704"></p>
<p>这样我们就可以通过Gitee Pages 地址来访问图床仓库里的图片了 ，地址前缀需要改一下。</p>
<p>例如，</p>
<p>原始图片地址的格式为<code>https://gitee.com/用户名/仓库名/raw/分支名/目录/图片名.png</code>，<code>https://gitee.com/yushuaigee/myblog/raw/master/img/myblog.gif</code>，</p>
<p>更改后的图片地址的格式<code>https://用户名.gitee.io/仓库名/目录/图片名.png</code>，</p>
<p><code>https://yushuaigee.gitee.io/myblog/img/myblog.gif</code>。</p>
<p><strong>对应的，PicGo 中就需要改一下自定义域名</strong>，之后上传图片自动生成的链接就是 Gitee Pages 上的地址了。具体就是在<code>customUrl</code>填写<code>https://用户名.gitee.io/仓库名</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113233142363.png" alt="image-20210113233142363"></p>
<p><strong>这种方法也存在一个问题</strong>，就是因为 Gitee Pages 不支持自动更新 (pro版支持，需要收费)，每次上传完图片后，需要打开浏览器手动点一下更新。你可以写完文章，把图片一把上传，再点一次更新，但是终究还是有点麻烦。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113231428575.png" alt="image-20210113231428575"></p>
<p><strong>为了解决这个问题，我写了一个自动化脚本</strong>，双击启动就可以自动完成 Gitee Pages 部署，其实原理就是利用 pyppeteer 模拟用户登录，到部署页面模拟点击<code>更新</code>按钮，虽然还是需要启动一下脚本，但是也稍微省了点事儿，下一篇文章将自动部署 Hexo 和 自动部署 Gitee Pages  结合起来。</p>
<p><strong>效果</strong></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113233250172.png" alt="image-20210113233250172"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210113233443911.png" alt="image-20210113233443911"></p>
<p><strong>start.bat 源码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:: start.bat 源码</span><br><span class="line">:: python路径 + 空格 + 脚本路径</span><br><span class="line">C:\Python\Scripts\python.exe D:/scripts/post_my_blog.py</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p><strong>post_my_blog.py 源码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># post_my_blog.py 源码</span></span><br><span class="line"><span class="comment"># 注意: 更改25、36、52行的用户名密码为自己的Gitee的用户名密码，第45行的仓库名为图床仓库的名字</span></span><br><span class="line"><span class="comment"># 每处延时都有用，是我花了好长时间调试过的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_update_gitee_pages</span>(<span class="params">usr_name, repo_name</span>):</span></span><br><span class="line">	browser = <span class="keyword">await</span> launch(devtools=<span class="literal">False</span>, dumpio=<span class="literal">True</span>, autoClose=<span class="literal">True</span>,</span><br><span class="line">                           args=[<span class="string">&#x27;--start-maximized&#x27;</span>,  <span class="comment"># 设置浏览器全屏</span></span><br><span class="line">                                 <span class="string">&#x27;--no-sandbox&#x27;</span>,  <span class="comment"># 取消沙盒模式，沙盒模式下权限太小</span></span><br><span class="line">                                 <span class="string">&#x27;--disable-infobars&#x27;</span>,  <span class="comment"># 关闭受控制提示</span></span><br><span class="line">                                 <span class="comment"># 设置ua</span></span><br><span class="line">                                 <span class="string">&#x27;--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3542.0 Safari/537.36&#x27;</span></span><br><span class="line">                                 ],</span><br><span class="line">                           userDataDir=os.path.abspath(<span class="string">&#x27;./cookies&#x27;</span>))</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="comment"># 登录</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/login&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;登录&#x27;</span> <span class="keyword">in</span> <span class="keyword">await</span> page.title():</span><br><span class="line">        <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#user_login&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#user_password&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;使用账号密码登录成功...&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;使用cookies缓存登录成功...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/%s/%s/pages&#x27;</span> % (usr_name, repo_name))</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    page.on(<span class="string">&#x27;dialog&#x27;</span>, <span class="keyword">lambda</span> dialog: asyncio.ensure_future(_handle_dialog(page, dialog)))</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;#pages-branch &gt; div.button.orange.redeploy-button.ui.update_deploy&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">20000</span>)</span><br><span class="line">    print(<span class="string">&#x27;更新 Gitee Pages %s 成功...&#x27;</span> % repo_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_handle_dialog</span>(<span class="params">page, dialog</span>):</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    print(<span class="string">&#x27;点击确定更新&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> dialog.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_gitee_pages</span>(<span class="params">usr_name, repo_name</span>):</span></span><br><span class="line">    asyncio.get_event_loop().run_until_complete(_update_gitee_pages(usr_name, repo_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    update_gitee_pages(<span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;仓库名&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>两个图床都不完美，所以究竟选哪个呢？让我这个强迫症很纠结。我尝试了各种组合方案，最终总结了两个方案：</p>
<ol>
<li> Typora + PicGo + GitHub图床 + jsDelivr CDN加速</li>
<li> Typora + PicGo + Gitee图床 + Gitee Pages + 自动部署脚本</li>
</ol>
<p>第一种方案似乎比较完美，但是美中不足的是虽然CDN加速解决了查看图片的速度，但是上传还是有点慢的，会出现在 Typora 中粘贴了一张图片后需要5秒以上才能上传成功并加载出来，还有就是本地没有分类备份(其实在<code>C:\Users\用户名\AppData\Roaming\Typora\typora-user-images</code>目录下有缓存)。</p>
<p>第二种方案速度没的说，通过 Gitee Pages  也解决了大图片的问题，通过脚本也解决了自动部署的问题，但是在 Typora 中粘贴了一张图片后，由于没有<code>更新</code>部署，实际上还不能访问，所以不能实时预览，需要用脚本自动部署后重新打开 Typora 才能加载出图片。我想了一种办法，就是在 Typora 设置插入图片时保存在本地，这样就实时加载，还能在本地存一份备份，然后写脚本将文件夹里图片用 PicGo 批量上传然后再调脚本自动部署，然后再自动将 md 文件中的本地链接都改成图床链接。看似麻烦还是可行的，下一篇文章中再实现吧。</p>
<p>我暂时选择了第一种方案。.</p>
<p>本篇文章介绍怎么搭建自己的 GitHub 和 Gitee 免费图床并搭配 Typora 和 PicGo 工具使用 ，两种图床都有自己的好处和缺点，我也尝试了提供了解决办法。</p>
<p>自己搭建的博客漂亮且方便，但终究不如在 CSDN 等成熟的平台上发布博客曝光量大。所以我们写完博客想在 CSDN 和自己的博客站点同时发布，我们怎么可能一篇一篇地手动复制呢，当然是自动化脚本实现啦。接下来两篇文章介绍一下怎么一键在三个站点发布博客，以及怎么快速把 CSDN 的旧博客迁移到自己的站点。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</title>
    <url>/2021/01/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%85%AD)%E2%80%94%E2%80%94%E4%B8%89%E4%B8%AA%E7%AB%99%E7%82%B9%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>   ​    本文是博客搭建系列文章第六篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaige.github.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaige.github.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaige.github.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li><strong>从零开始免费搭建自己的博客(六)——<a href="https://yushuaigee.gitee.io/2021/01/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%85%AD)%E2%80%94%E2%80%94%E4%B8%89%E4%B8%AA%E7%AB%99%E7%82%B9%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/">三个站点一键发布博客</a></strong></li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文目标：本地写好文章后，双击执行一个脚本，文章可以自动发布到自己的 github.io 、gitee.io 和 CSDN。</p>
<p>实现原理：</p>
<ol>
<li>写文章时自己在开头添加好title，date，tags等字段，用python实现文章的新旧版本替换。</li>
<li>配置好 Hexo 的配置文件，用shell脚本实现 <code>hexo g</code>和<code>hexo d</code>等操作，Python脚本实现Gitee Pages更新。</li>
<li>利用puppeteer模拟浏览器登录CSDN发布博客。</li>
<li>将前面三步的代码整合，使用bat脚本双击运行。</li>
</ol>
<h2 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h2><p>我平时在本地写文章保存在<code>E:\Markdown</code>目录，而 Hexo 保存在<code>D:\MyBlog</code>目录。发布 Hexo 之前需要先把文章拷贝到<code>D:\MyBlog\source\_posts</code>目录，有时候文章有修改还要重新拷贝覆盖。所以考虑用Python脚本实现拷贝文件，判断文件最后修改时间决定是否需要覆盖旧文章。</p>
<p>因为我们省略了<code>hexo create &quot;title&quot;</code>这一步，直接把文件拷贝到了<code>_posts</code>目录，所以写文章时需要确保在开头加上 title、date、tags、category信息，不然发布的文章会没有没有标题、发布时间、标签、分类信息，其实<code>hexo create</code>命令做的就是这件事。<strong>注意最后的空行一定要有</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 我的第一篇博客</span><br><span class="line">date: 2021-01-11 19:50:43</span><br><span class="line">tags: [博客搭建]</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是在 Typora 中编辑，直接在第一行输入<code>---</code>回车就行了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210121222437143.png" alt="image-20210121222437143"></p>
<p>Python 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># copy_to_hexo.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_to_hexo</span>():</span></span><br><span class="line">    local_list = os.listdir(LOCAL_ARTICLE_PATH)</span><br><span class="line">    hexo_list = os.listdir(HEXO_ARTICLE_PATH)</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> local_list:</span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">in</span> IGNORE_LIST:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.md&#x27;</span>):</span><br><span class="line">            local_version = os.path.join(LOCAL_ARTICLE_PATH, file)</span><br><span class="line">            hexo_version = os.path.join(HEXO_ARTICLE_PATH, file)</span><br><span class="line">            <span class="keyword">if</span> file <span class="keyword">not</span> <span class="keyword">in</span> hexo_list:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                print(<span class="string">&quot;新增文章: %s...&quot;</span> % file,</span><br><span class="line">                      <span class="string">&quot;最后修改时间：%s&quot;</span> % TimeStampFormat(os.path.getmtime(local_version)))</span><br><span class="line">                shutil.copy(local_version, hexo_version)</span><br><span class="line">            <span class="keyword">elif</span> os.path.getmtime(local_version) &gt; os.path.getmtime(hexo_version):</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                print(<span class="string">&quot;更新文章: %s...&quot;</span> % file,</span><br><span class="line">                      <span class="string">&quot;上次修改时间：%s&quot;</span> % TimeStampFormat(os.path.getmtime(hexo_version)),</span><br><span class="line">                      <span class="string">&quot;最后修改时间：%s&quot;</span> % TimeStampFormat(os.path.getmtime(local_version)))</span><br><span class="line">                shutil.copy(local_version, hexo_version)</span><br><span class="line">    print(<span class="string">&#x27;文章无变化&#x27;</span> <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="string">&#x27;更新完毕&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间格式标准化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TimeStampFormat</span>(<span class="params">timestamp</span>):</span></span><br><span class="line">    <span class="keyword">return</span> time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, time.localtime(timestamp))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IGNORE_LIST = [<span class="string">&#x27;欢迎使用Markdown编辑器.md&#x27;</span>]</span><br><span class="line">HEXO_ARTICLE_PATH = <span class="string">&#x27;D:/MyBlog/source/_posts&#x27;</span></span><br><span class="line">LOCAL_ARTICLE_PATH = <span class="string">&#x27;E:/Markdown&#x27;</span></span><br><span class="line"></span><br><span class="line">copy_to_hexo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124222133145.png" alt="image-20210124222133145"></p>
<h2 id="发布Hexo到GitHub-Gitee"><a href="#发布Hexo到GitHub-Gitee" class="headerlink" title="发布Hexo到GitHub/Gitee"></a>发布Hexo到GitHub/Gitee</h2><p>本来以为需要把配置文件<code>deploy</code>参数改成 GitHub 地址 <code>hexo d</code>一次，再改成 Gitee 地址<code>hexo d</code>一次，后来看文档发现 Hexo 支持一次发布到多个仓库，只需要修改一下配置文件，然后<code>hexo g &amp;&amp; hexo d</code>就可以了。</p>
<h4 id="1修改Hexo配置文件"><a href="#1修改Hexo配置文件" class="headerlink" title="1修改Hexo配置文件"></a>1修改Hexo配置文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">git@github.com:用户名/用户名.github.io.git,main</span></span><br><span class="line">      <span class="attr">gitee:</span> <span class="string">git@gitee.com:用户名/仓库名.git,master</span></span><br></pre></td></tr></table></figure>
<h4 id="shell发布脚本"><a href="#shell发布脚本" class="headerlink" title="shell发布脚本"></a>shell发布脚本</h4><p><kbd>Git Bash</kbd>支持直接运行 shell 脚本，只需要把下面代码保存为 <code>.sh</code>后缀的文件即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> deploy_hexo.sh</span></span><br><span class="line">cd /d/MyBlog</span><br><span class="line">pwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 白底黑字效果</span></span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo g&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line">hexo g</span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo d&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line">hexo d</span><br><span class="line">sleep 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行完毕不退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exec</span> /bin/bash</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124214628069.png" alt="image-20210124214628069"></p>
<h4 id="Gitee-Pages更新脚本"><a href="#Gitee-Pages更新脚本" class="headerlink" title="Gitee Pages更新脚本"></a>Gitee Pages更新脚本</h4><p>上一篇博客已经实现了用 Python 脚本自动更新 Gitee pages，这里直接拿来用就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># update_gitee_pages.py</span></span><br><span class="line"><span class="comment"># 注意: 更改25、36、52行的用户名密码为自己的Gitee的用户名密码，第45行的仓库名为图床仓库的名字</span></span><br><span class="line"><span class="comment"># 每处延时都有用，是我花了好长时间调试过的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_update_gitee_pages</span>(<span class="params">usr_name, repo_name</span>):</span></span><br><span class="line">	browser = <span class="keyword">await</span> launch(devtools=<span class="literal">False</span>, dumpio=<span class="literal">True</span>, autoClose=<span class="literal">True</span>,</span><br><span class="line">                           args=[<span class="string">&#x27;--start-maximized&#x27;</span>,  <span class="comment"># 设置浏览器全屏</span></span><br><span class="line">                                 <span class="string">&#x27;--no-sandbox&#x27;</span>,  <span class="comment"># 取消沙盒模式，沙盒模式下权限太小</span></span><br><span class="line">                                 <span class="string">&#x27;--disable-infobars&#x27;</span>,  <span class="comment"># 关闭受控制提示</span></span><br><span class="line">                                 <span class="comment"># 设置ua</span></span><br><span class="line">                                 <span class="string">&#x27;--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3542.0 Safari/537.36&#x27;</span></span><br><span class="line">                                 ],</span><br><span class="line">                           userDataDir=os.path.abspath(<span class="string">&#x27;./cookies&#x27;</span>))</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="comment"># 登录</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/login&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;登录&#x27;</span> <span class="keyword">in</span> <span class="keyword">await</span> page.title():</span><br><span class="line">        <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#user_login&#x27;</span>, <span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#user_password&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;使用账号密码登录成功...&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;使用cookies缓存登录成功...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/%s/%s/pages&#x27;</span> % (usr_name, repo_name))</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    page.on(<span class="string">&#x27;dialog&#x27;</span>, <span class="keyword">lambda</span> dialog: asyncio.ensure_future(_handle_dialog(page, dialog)))</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;#pages-branch &gt; div.button.orange.redeploy-button.ui.update_deploy&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">20000</span>)</span><br><span class="line">    print(<span class="string">&#x27;更新 Gitee Pages %s 成功...&#x27;</span> % repo_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_handle_dialog</span>(<span class="params">page, dialog</span>):</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    print(<span class="string">&#x27;点击确定更新&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> dialog.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_gitee_pages</span>(<span class="params">usr_name, repo_name</span>):</span></span><br><span class="line">    asyncio.get_event_loop().run_until_complete(_update_gitee_pages(usr_name, repo_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    update_gitee_pages(<span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;仓库名&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124214209633.png" alt="image-20210124214209633"></p>
<h2 id="发布到CSDN"><a href="#发布到CSDN" class="headerlink" title="发布到CSDN"></a>发布到CSDN</h2><p>最不好处理的是自动发布文章到 CSDN ，据说 CSDN 官方之前是提供了发布文章的接口的，后来关闭了。一文多发这个功能对于做自媒体的人来说需求很大，于是有了  <a href="https://openwrite.cn/">OpenWrite</a>这种一文多发平台，还有开源的<a href="https://github.com/crawlab-team/artipub">ArtiPub</a>。各大平台都没有提供发布文章的官方接口，这种一分多发平台想必也是通过模拟 http 请求来实现自动发文。</p>
<p>本文利用 Python 的第三方库 <a href="https://github.com/pyppeteer/pyppeteer">puppeteer</a> 操作无头浏览器模拟登陆 CSDN 发布文章，类似 Selenium，更加接近真实操作，防止被网站检测到机器操作导致封号。最近发现 Go 语言的 <a href="https://github.com/go-rod/rod">go-rod</a> 库对于模拟浏览器操作更加好用，官方文档写的很详细，两者都不用另外下载 driver，相比于 Selenium 方便了很多，后面打算用 Golang 重新实现一版，今天先看下 Python 代码。<strong>注意这只是个 Demo，实现了自动发布一篇文章的功能，我们的需求是发布多篇文章，实际使用要稍作修改，实际使用的代码是这个 <a href="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/scripts/post_to_csdn.py">post_to_csdn.py</a>)。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># post_to_csdn_demo.py </span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">blog_name, title, content, tags, category</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param blog_name: 博客名字，自己博客主页url的最后部分</span></span><br><span class="line"><span class="string">    :param title: 文章标题</span></span><br><span class="line"><span class="string">    :param content: 文章内容</span></span><br><span class="line"><span class="string">    :param tags: 标签，多个用英文&quot;,&quot;隔开</span></span><br><span class="line"><span class="string">    :param category: 分类</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(devtools=<span class="literal">False</span>, dumpio=<span class="literal">True</span>, autoClose=<span class="literal">True</span>,</span><br><span class="line">                           args=[<span class="string">&#x27;--start-maximized&#x27;</span>,  <span class="comment"># 设置浏览器全屏</span></span><br><span class="line">                                 <span class="string">&#x27;--no-sandbox&#x27;</span>,  <span class="comment"># 取消沙盒模式，沙盒模式下权限太小</span></span><br><span class="line">                                 <span class="string">&#x27;--disable-infobars&#x27;</span>,  <span class="comment"># 关闭受控制提示</span></span><br><span class="line">                                 <span class="comment"># 设置ua</span></span><br><span class="line">                                 <span class="string">&#x27;--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3542.0 Safari/537.36&#x27;</span></span><br><span class="line">                                 ],</span><br><span class="line">                           userDataDir=os.path.abspath(<span class="string">&#x27;./cookies&#x27;</span>))</span><br><span class="line">    print(<span class="keyword">await</span> browser.userAgent())</span><br><span class="line">    pages_list = <span class="keyword">await</span> browser.pages()</span><br><span class="line">    page = pages_list[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># await page.setViewport(viewport=&#123;&#x27;width&#x27;: 1920, &#x27;height&#x27;: 1080&#125;)</span></span><br><span class="line">    <span class="comment"># 打开博客主页</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://blog.csdn.net/%s&#x27;</span> % blog_name)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># 先找到已有文章</span></span><br><span class="line">     elements = <span class="keyword">await</span> page.querySelectorAll(<span class="string">&#x27;#articleMeList-blog &gt; div.article-list &gt; div &gt; h4&#x27;</span>)</span><br><span class="line">    article_list = []</span><br><span class="line">    <span class="keyword">for</span> article <span class="keyword">in</span> elements:</span><br><span class="line">        article = <span class="keyword">await</span> (<span class="keyword">await</span> article.getProperty(<span class="string">&#x27;textContent&#x27;</span>)).jsonValue()</span><br><span class="line">        article_list.append(<span class="built_in">str</span>(article).strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>].strip())</span><br><span class="line">    print(<span class="string">&#x27;已有文章%d篇: &#x27;</span> % <span class="built_in">len</span>(article_list), article_list)</span><br><span class="line">    <span class="comment"># 点击 创作中心</span></span><br><span class="line">    <span class="keyword">await</span> page.click(</span><br><span class="line">        <span class="string">&#x27;#csdn-toolbar &gt; div &gt; div &gt; div.toolbar-container-right &gt; div &gt; div.toolbar-btn.toolbar-btn-write.csdn-toolbar-fl &gt; a&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">4000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;登录&#x27;</span> <span class="keyword">in</span> <span class="keyword">await</span> page.title():</span><br><span class="line">        print(<span class="string">&#x27;正在登录...&#x27;</span>)</span><br><span class="line">        <span class="comment"># 点击 CSDN App扫码</span></span><br><span class="line">        <span class="keyword">await</span> page.click(<span class="string">&#x27;#app &gt; div &gt; div &gt; div.main &gt; div.main-login &gt; div.main-select &gt; ul &gt; li:nth-child(1) &gt; a&#x27;</span>)</span><br><span class="line">        <span class="comment"># 获取登录二维码</span></span><br><span class="line">        img_element = <span class="keyword">await</span> page.querySelector(<span class="string">&#x27;#appqr &gt; span.app-code-wrap &gt; img&#x27;</span>)</span><br><span class="line">        img_src = <span class="keyword">await</span> (<span class="keyword">await</span> img_element.getProperty(<span class="string">&#x27;src&#x27;</span>)).jsonValue()</span><br><span class="line">        img_src = <span class="built_in">str</span>(img_src).split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        img_data = base64.b64decode(img_src)</span><br><span class="line">        img_name = <span class="string">&#x27;login.png&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(img_name):</span><br><span class="line">            os.remove(img_name)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(img_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(img_data)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_name)</span><br><span class="line">        img.show()</span><br><span class="line">    <span class="comment"># 等待登录成功，最多等5分钟</span></span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(</span><br><span class="line">        <span class="string">&#x27;#view-containe &gt; div.left_box &gt; div.left_box_top &gt; a.routerlink-bt.routerlink-bt-md &gt; span&#x27;</span>,</span><br><span class="line">        timeout=<span class="number">300</span> * <span class="number">1000</span>)</span><br><span class="line">    print(<span class="string">&#x27;已登录&#x27;</span>)</span><br><span class="line">    <span class="comment"># 点击 Markdown 编辑器</span></span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;#view-containe &gt; div.left_box &gt; div.left_box_top &gt; a.routerlink-bt.routerlink-bt-md &gt; span&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">3000</span>)</span><br><span class="line">    <span class="comment"># 切换到写文章页签</span></span><br><span class="line">    pages_list = <span class="keyword">await</span> browser.pages()</span><br><span class="line">    page = pages_list[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 选中标题输入框</span></span><br><span class="line">    print(<span class="string">&#x27;输入标题: %s&#x27;</span> % title)</span><br><span class="line">    title_input = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.layout &gt; div.layout__panel.layout__panel--articletitle-bar &gt; div &gt; div.article-bar__input-box &gt; input&#x27;</span>)</span><br><span class="line">    <span class="comment"># 清空原有内容</span></span><br><span class="line">    <span class="keyword">await</span> title_input.focus()</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">&#x27;Control&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;KeyA&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">&#x27;Control&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">&#x27;Backspace&#x27;</span>)</span><br><span class="line">    <span class="comment"># 输入标题内容</span></span><br><span class="line">    <span class="keyword">await</span> title_input.<span class="built_in">type</span>(title)</span><br><span class="line">    <span class="comment"># 选中文章输入框</span></span><br><span class="line">    print(<span class="string">&#x27;输入文章内容: %s&#x27;</span> % content)</span><br><span class="line">    content_input = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.layout &gt; div.layout__panel.flex.flex--row &gt; div &gt; div.layout__panel.flex.flex--row &gt; div.layout__panel.layout__panel--editor &gt; div.editor &gt; pre&#x27;</span>)</span><br><span class="line">    <span class="comment"># 清空原有内容</span></span><br><span class="line">    <span class="keyword">await</span> content_input.focus()</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">&#x27;Control&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;KeyA&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">&#x27;Control&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">&#x27;Backspace&#x27;</span>)</span><br><span class="line">    <span class="comment"># 输入文章内容</span></span><br><span class="line">    <span class="keyword">await</span> content_input.<span class="built_in">type</span>(content)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">    <span class="comment"># 点击 发布文章</span></span><br><span class="line">    <span class="keyword">await</span> page.click(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.layout &gt; div.layout__panel.layout__panel--articletitle-bar &gt; div &gt; div.article-bar__user-box.flex.flex--row &gt; button.btn.btn-publish&#x27;</span>)</span><br><span class="line">    <span class="comment"># 删除原来的标签，如果有的话</span></span><br><span class="line">    exist_tags = <span class="keyword">await</span> page.querySelectorAll(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(3) &gt; div &gt; div &gt; div &gt; span &gt; span &gt; i&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> exist_tags:</span><br><span class="line">        <span class="comment"># 每删一个，页面会有变化</span></span><br><span class="line">        tag = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">            <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(3) &gt; div &gt; div &gt; div &gt; span &gt; span &gt; i&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> tag.click()</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 点击 添加文章标签</span></span><br><span class="line">    print(<span class="string">&#x27;添加标签: %s&#x27;</span> % tags)</span><br><span class="line">    add_tag = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(3) &gt; div &gt; div &gt; div &gt; button&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> add_tag.click()</span><br><span class="line">    <span class="comment"># 添加标签</span></span><br><span class="line">    tag_input = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(3) &gt; div &gt; div &gt; div.mark_selection_box &gt; div.mark_selection_box_header &gt; div &gt; div.el-input.el-input--suffix &gt; input&#x27;</span>)</span><br><span class="line">    tag_list = tags.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> tag <span class="keyword">in</span> tag_list:</span><br><span class="line">        <span class="keyword">await</span> tag_input.<span class="built_in">type</span>(tag.strip())</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 收起 添加文章标签</span></span><br><span class="line">    <span class="keyword">await</span> add_tag.click()</span><br><span class="line">    <span class="comment"># 添加分类</span></span><br><span class="line">    print(<span class="string">&#x27;添加分类: %s&#x27;</span> % category)</span><br><span class="line">    add_category = <span class="keyword">await</span> page.querySelector(<span class="string">&#x27;#tagList &gt; button&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> add_category.click()</span><br><span class="line">    category_input = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div:nth-child(4) &gt; div &gt; div &gt; input&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> category_input.<span class="built_in">type</span>(category)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 选择文章类型：原创</span></span><br><span class="line">    print(<span class="string">&#x27;文章类型: 原创&#x27;</span>)</span><br><span class="line">    select_box = <span class="keyword">await</span> page.querySelector(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div.inline-box &gt; div &gt; div&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> select_box.click()</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">    <span class="comment"># 下拉框的 id 是个随机值，每次都不一样，通过按键曲线救国</span></span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;ArrowDown&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">&#x27;Enter&#x27;</span>)</span><br><span class="line">    <span class="comment"># 选择发布形式：公开 2, 私密 4, 粉丝可见 6, VIP可见 8</span></span><br><span class="line">    print(<span class="string">&#x27;发布形式: 公开&#x27;</span>)</span><br><span class="line">    flag = <span class="number">2</span></span><br><span class="line">    <span class="keyword">await</span> page.click(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__content &gt; div.form-entry.flex.form-entry__field-switch-box.overflow-unset.form-entry-marginBottom &gt; div &gt; div &gt; label:nth-child(%d)&#x27;</span> % flag)</span><br><span class="line">    <span class="comment"># 发布文章：保存为草稿 btn-c-blue, 发布文章 btn-b-red</span></span><br><span class="line">    print(<span class="string">&#x27;点击发布...&#x27;</span>)</span><br><span class="line">    flag = <span class="string">&#x27;btn-b-red&#x27;</span></span><br><span class="line">    <span class="keyword">await</span> page.click(</span><br><span class="line">        <span class="string">&#x27;body &gt; div.app.app--light &gt; div.modal &gt; div &gt; div.modal__inner-2 &gt; div.modal__button-bar &gt; button.button.%s&#x27;</span> % flag)</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">3000</span>)</span><br><span class="line">    url_element = <span class="keyword">await</span> page.querySelector(<span class="string">&#x27;#alertSuccess &gt; div &gt; div.pos-top &gt; div:nth-child(4) &gt; a&#x27;</span>)</span><br><span class="line">    url = <span class="keyword">await</span> (<span class="keyword">await</span> url_element.getProperty(<span class="string">&#x27;href&#x27;</span>)).jsonValue()</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line">    print(<span class="string">&#x27;发布成功, 文章地址: %s&#x27;</span> % url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">blog_name = <span class="string">&#x27;yushuaigee&#x27;</span></span><br><span class="line">title = <span class="string">&#x27;自动发布的第一篇文章&#x27;</span></span><br><span class="line">content = <span class="string">&#x27;自动发布的第一篇文章自动发布的第一篇文章自动发布的第一篇文章&#x27;</span></span><br><span class="line">tags = <span class="string">&#x27;博客搭建,自动发布文章&#x27;</span></span><br><span class="line">category = <span class="string">&#x27;博客搭建&#x27;</span></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main(blog_name, title, content, tags, category))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124213855158.png" alt="image-20210124213855158"></p>
<h2 id="一键发布脚本！"><a href="#一键发布脚本！" class="headerlink" title="一键发布脚本！"></a>一键发布脚本！</h2><p>上面写的4个脚本一步一步实现了我们的每个小目标，对于 Windows 系统来说，可以使用 bat 脚本把它们整合在一起，完成“一键”发布的需求。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">:: post_my_blog.bat</span><br><span class="line">python copy_to_hexo.py</span><br><span class="line">D:\Git\git<span class="literal">-bash</span>.exe deploy_hexo.sh</span><br><span class="line">python update_gitee_pages.py</span><br><span class="line">python post_to_csdn.py</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p>写好文章后，直接双击<code>post_my_blog.bat</code>就可以发布到三个地方了。</p>
<p>最终运行效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210124223519915.png" alt="image-20210124223519915"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>本文解决了一文多发的问题，以前发布在 CSDN 上的博客就不用一篇一篇复制到自己的博客站点了，但是要想一键发布，需要先将 CSDN 上的文章先下载到本地，而且原来的文章是使用富文本编辑器写的，怎么转化成 Markdown 格式呢？下一篇文章将介绍这两个问题的解决方法。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>自动发布博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记（一）——那些“奇怪”的规定和特性</title>
    <url>/2019/12/08/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%82%A3%E4%BA%9B%E2%80%9C%E5%A5%87%E6%80%AA%E2%80%9D%E7%9A%84%E8%A7%84%E5%AE%9A%E5%92%8C%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/103444529">https://blog.csdn.net/yushuaigee/article/details/103444529</a></p>
</blockquote>
<p>这几天看了一下Go语言的基础知识，还没有在项目中使用，所以还没体会到它的性能优势。而在学习基础用法部分时我最大的感受就是它的一些特性和规定很“奇怪”。以前听说Go语言声明变量时，类型关键字在变量名称后面就感觉怪怪的，没想到还有许多这样奇怪的地方（主要是和C、Python相比），在这里将这几周的学习内容和感受记录一下以备查阅。</p>
<h3 id="1-去掉循环冗余括号"><a href="#1-去掉循环冗余括号" class="headerlink" title="1. 去掉循环冗余括号"></a>1. 去掉循环冗余括号</h3><p>C语言的数值循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>;a&lt;<span class="number">10</span>;a++)&#123;</span><br><span class="line">    <span class="comment">// 循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言的数值循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a := <span class="number">0</span>;a&lt;<span class="number">10</span>;a++&#123;</span><br><span class="line">    <span class="comment">// 循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个括号确实没什么实际作用，但是Go语言中的循环的风格和C语言太像，没有那两个括号感觉怪怪的。 </p>
<h3 id="2-去掉表达式冗余括号"><a href="#2-去掉表达式冗余括号" class="headerlink" title="2. 去掉表达式冗余括号"></a>2. 去掉表达式冗余括号</h3><p>C语言的判断语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式)&#123;</span><br><span class="line">    <span class="comment">// 表达式成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言的判断语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式&#123;</span><br><span class="line">    <span class="comment">// 表达式成立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个括号确实也没什么实际作用，Python中也是这样写的，但是Python中又没有后面这个大括号。初学Go语言，写这行代码时有一点不适应。</p>
<h3 id="3-强制的代码风格"><a href="#3-强制的代码风格" class="headerlink" title="3.强制的代码风格"></a>3.强制的代码风格</h3><p>Go语言中，左括号必须紧接着语句不换行。其他样式的括号将被视为代码编译错误。<br>也就是说代码中，用到大括号的地方，必须写成这样： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//代码片段</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    <span class="comment">//循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能写成这样：（不然连编译都通不过）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代码片段</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个规定让许多人觉得蛋疼，毕竟程序员大多都有强迫症，我就在网上看到一篇diss Go语言的博文，里面狠狠得吐槽了这一点。不过对于我来说还好，像我这种选择困难症和强迫症并存的人，这个规定可以让我不再纠结到底用哪种格式，大大节省了自己做思想斗争的时间。从而有更多的时间，来纠结这篇博客每一行的排版方式。||—__—</p>
<h3 id="4-不再纠结于-i-和-i"><a href="#4-不再纠结于-i-和-i" class="headerlink" title="4. 不再纠结于 i++ 和 ++i"></a>4. 不再纠结于 i++ 和 ++i</h3><p>C语言非常经典的考试题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = i++;</span><br><span class="line">b = ++i;</span><br></pre></td></tr></table></figure>
<p>在Go语言中，自增操作符不再是一个操作符，而是一个语句。因此，在Go语言中自增只有一种写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i++</span><br></pre></td></tr></table></figure>
<h3 id="5-Go语言变量的声明——标准格式"><a href="#5-Go语言变量的声明——标准格式" class="headerlink" title="5. Go语言变量的声明——标准格式"></a>5. Go语言变量的声明——标准格式</h3><p>Go原因是静态类型语言，因此变量是有明确类型的，编译器也会检查变量类型的正确性。Go语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。</p>
<p>声明变量的一般形式是使用 var 关键字： <code>var name type</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>var关键字没什么奇怪的，C#、js里也有，但是其他大部分语言声明变量时，类型都在变量名之前，以至于我们都认为这是理所当然的，而Go语言偏偏反了过来。教程上说，这样做的好处是：</p>
<blockquote>
<p>可以避免像C语言中那样含糊不清的声明形式，例如：<code>int* a, b;</code> 。其中只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 Go 中，则可以和轻松地将它们都声明为指针类型：<code>var a, b *int</code></p>
</blockquote>
<p>额(⊙o⊙)，感觉这种声明方式带给我的奇怪感受，远大于将这行代码写成两行带来的“不便”。</p>
<h3 id="6-Go语言变量的声明——批量格式"><a href="#6-Go语言变量的声明——批量格式" class="headerlink" title="6. Go语言变量的声明——批量格式"></a>6. Go语言变量的声明——批量格式</h3><p>Go语言中的多个变量可以一起声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">    c []<span class="keyword">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    e <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>虽然感觉不是那么的好看，不过也算是很有自己的风格吧。就像引入多个包的时候，Go语言是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;image&quot;</span></span><br><span class="line">    <span class="string">&quot;image/color&quot;</span></span><br><span class="line">    <span class="string">&quot;image/png&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p> 相比于C语言中的一行一个<code>include</code>”Python一行一个<code>import</code>，这样确实少写了很多个单词，但是总是觉得不太习惯。</p>
<h3 id="7-Go语言变量的声明——简短格式"><a href="#7-Go语言变量的声明——简短格式" class="headerlink" title="7. Go语言变量的声明——简短格式"></a>7. Go语言变量的声明——简短格式</h3><p>Go语言中还可以使用海象操作符<code>:=</code>，这样声明变量：<code>名字 := 表达式 </code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br><span class="line">i, j := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">str := <span class="string">&quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>
<p>乍一看，好像和Python中的等号效果一样，但是这个<code>:=</code>在循环的时候使用是真的香，主要是可以省掉前面声明的那一句。现在新发布的Python3.8版本也加入了海象操作符。</p>
<h3 id="8-Go语言匿名变量"><a href="#8-Go语言匿名变量" class="headerlink" title="8. Go语言匿名变量"></a>8. Go语言匿名变量</h3><p>编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。匿名变量的特点是一个下画线<code>_</code>，<code>_</code>本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），<strong>但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算</strong>。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。</p>
<p><strong>匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用</strong>。在 Lua 等编程语言里，匿名变量也被叫做哑元变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetData</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a, _ := GetData()</span><br><span class="line">    _, b := GetData()</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p> 100 200 </p>
</blockquote>
<p>这个特性给我的直观感受比较有用。</p>
<h3 id="9-Go语言bool类型"><a href="#9-Go语言bool类型" class="headerlink" title="9. Go语言bool类型"></a>9. Go语言bool类型</h3><p>这里需要注意的地方就是，Go语言中的布尔值并不会隐式转换为数字值 0 或 1，反之亦然。</p>
<p>也就是说有些语言默认 <code>true==1</code>，<code>false==0</code>，这在Go语言中是不成立的，如果必须要这么用，需要手动转化一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b为bool型变量</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">   i = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://c.biancheng.net/golang/">Go语言入门教程——C语言中文网</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>go语言特点</tag>
        <tag>go</tag>
        <tag>go语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记（三）——数据类型转换</title>
    <url>/2020/05/24/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/106305233">https://blog.csdn.net/yushuaigee/article/details/106305233</a></p>
</blockquote>
<h2 id="一、强制类型转换"><a href="#一、强制类型转换" class="headerlink" title="一、强制类型转换"></a><strong>一、强制类型转换</strong></h2><p>类似于其他语言，Go语言也支持强制类型转换：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200523205009481.png" alt="20200523205009481.png"></p>
<p>但是只有相同底层类型的变量之间可以进行相互转换（如将 int16 和 int32 相互转换，float 类型和 int 类型相互转换），不同底层类型的变量相互转换时会引发编译错误（如 bool 类型和 int 类型，string 与 int 类型之间的转换）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200523200617332.png" alt="20200523200617332.png"></p>
<h2 id="二、-strconv包：字符串和数值类型的相互转换"><a href="#二、-strconv包：字符串和数值类型的相互转换" class="headerlink" title="二、 strconv包：字符串和数值类型的相互转换"></a><strong>二、 strconv包：字符串和数值类型的相互转换</strong></h2><p>如果需要string、int、int64、float 等数据类型之间的转换功能，可以使用标准包中的 strconv 包。</p>
<p>strconv 包中常用的函数包括 <strong>Atoi()**、</strong>Itia()<strong>、</strong>parse** 系列函数、<strong>format **系列函数、</strong>append **系列函数等。</p>
<h3 id="1-Itoa-：整型转字符串-integer-to-alphanumeric"><a href="#1-Itoa-：整型转字符串-integer-to-alphanumeric" class="headerlink" title="1. Itoa()：整型转字符串  integer to alphanumeric"></a><strong>1. Itoa()：整型转字符串  integer to alphanumeric</strong></h3><p>函数原型：func Itoa(i int) string    输入int，输出string</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">100</span></span><br><span class="line">	str := strconv.Itoa(num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T value:%#v\n&quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//type:string value:&quot;100&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Atoi-：字符串转整型-alphanumeric-to-integer"><a href="#2-Atoi-：字符串转整型-alphanumeric-to-integer" class="headerlink" title="2. Atoi()：字符串转整型 alphanumeric to integer"></a><strong>2. Atoi()：字符串转整型 alphanumeric to integer</strong></h3><p>函数原型：func Atoi(s string) (i int, err error)** **   输入string，输出int 和 错误信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;110&quot;</span></span><br><span class="line">	str2 := <span class="string">&quot;s100&quot;</span></span><br><span class="line">	num1, err := strconv.Atoi(str1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v 转换失败！&quot;</span>, str1)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;type:%T value:%#v\n&quot;</span>, num1, num1)</span><br><span class="line">	&#125;</span><br><span class="line">	num2, err := strconv.Atoi(str2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%v 转换失败！&quot;</span>, str2)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;type:%T value:%#v\n&quot;</span>, num2, num2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:int value:110</span></span><br><span class="line"><span class="comment">//s100 转换失败！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-Parse-系列函数-str转其他-ParseBool-、ParseInt-、ParseUint-、ParseFloat"><a href="#3-Parse-系列函数-str转其他-ParseBool-、ParseInt-、ParseUint-、ParseFloat" class="headerlink" title="3. Parse 系列函数(str转其他): ParseBool()、ParseInt()、ParseUint()、ParseFloat()"></a><strong>3. Parse 系列函数(str转其他): ParseBool()、ParseInt()、ParseUint()、ParseFloat()</strong></h3><p><strong>（1）ParseBool()</strong></p>
<p>它只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE，其它的值均返回错误。</p>
<p>函数原型：func ParseBool(str string) (value bool, err error)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;110&quot;</span></span><br><span class="line">	boo1, err := strconv.ParseBool(str1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;str1: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(boo1)</span><br><span class="line">	&#125;</span><br><span class="line">	str2 := <span class="string">&quot;t&quot;</span></span><br><span class="line">	boo2, err := strconv.ParseBool(str2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;str2: %v\n&quot;</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(boo2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//str1: strconv.ParseBool: parsing &quot;110&quot;: invalid syntax</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）ParseInt()</strong></p>
<p>函数用于返回字符串表示的整数值<strong>（可以包含正负号）。</strong></p>
<p>函数原型：func ParseInt(s string, base int, bitSize int) (i int64, err error)</p>
<p>参数说明：</p>
<ul>
<li>base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x”是 16 进制，“0”是 8 进制，否则是 10 进制。</li>
<li>bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。</li>
<li>返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;-11&quot;</span></span><br><span class="line">	num, err := strconv.ParseInt(str, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//-11</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（3）ParseUint()</strong></p>
<p>函数用于返回字符串表示的整数值，但 ParseUint() 函数<strong>不接受正负号，用于无符号整型。</strong></p>
<p>函数原型：func ParseUint(s string, base int, bitSize int) (n uint64, err error)</p>
<p>参数说明：(同ParseInt())</p>
<ul>
<li>base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x”是 16 进制，“0”是 8 进制，否则是 10 进制。</li>
<li>bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。</li>
<li>返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;11&quot;</span></span><br><span class="line">	num, err := strconv.ParseUint(str, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//11</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（4）ParseFloat()</strong></p>
<p>函数用于将一个表示浮点数的字符串转换为 float 类型。</p>
<p>函数原型：func ParseFloat(s string, bitSize int) (f float64, err error)</p>
<p>参数说明：</p>
<ul>
<li>如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。</li>
<li>bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64；</li>
<li>返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax，如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;3.1415926&quot;</span></span><br><span class="line">	num, err := strconv.ParseFloat(str, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//3.1415926</span></span><br></pre></td></tr></table></figure>
<h3 id="4-Format-系列函数-其他转str-FormatBool-、FormatInt-、FormatUint-、FormatFloat-​​​​​​​"><a href="#4-Format-系列函数-其他转str-FormatBool-、FormatInt-、FormatUint-、FormatFloat-​​​​​​​" class="headerlink" title="4.Format 系列函数(其他转str): FormatBool()、FormatInt()、FormatUint()、FormatFloat()​​​​​​​"></a><strong>4.Format 系列函数(其他转str)<strong>:</strong> FormatBool()、FormatInt()、FormatUint()、FormatFloat()​​​​​​​</strong></h3></li>
</ul>
<p><strong>（1）FormatBool()</strong></p>
<p>函数可以将一个 bool 类型的值转换为对应的字符串类型。</p>
<p>函数原型：func FormatBool(b bool) string</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="literal">true</span></span><br><span class="line">	str := strconv.FormatBool(num)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:string,value:true</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）FormatInt()</strong></p>
<p>函数用于将整型数据转换成指定进制并以字符串的形式返回。</p>
<p>函数原型：func FormatInt(i int64, base int) string</p>
<p>参数说明：</p>
<ul>
<li>参数 i 必须是 int64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母“a”到“z”表示大于 10 的数字。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">int64</span> = <span class="number">100</span></span><br><span class="line">	str := strconv.FormatInt(num, <span class="number">16</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:string,value:64</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（3）FormatUint()</strong></p>
<p>函数用于将无符号的整型数据转换成指定进制并以字符串的形式返回。</p>
<p>函数原型：func FormatUint(i uint64, base int) string</p>
<p>参数说明：</p>
<ul>
<li>参数 i 必须是无符号的 uint64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母“a”到“z”表示大于 10 的数字。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">uint64</span> = <span class="number">110</span></span><br><span class="line">	str := strconv.FormatUint(num, <span class="number">16</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:string,value:6e</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>（4）FormatFloat()</strong></p>
<p>函数用于将浮点数转换为字符串类型并以字符串的形式返回。</p>
<p>函数原型：func FormatFloat(f float64, fmt byte, prec, bitSize int) string</p>
<p>参数说明：</p>
<ul>
<li>bitSize 表示参数 f 的来源类型（32 表示 float32、64 表示 float64），会据此进行舍入。</li>
<li>fmt 表示格式，可以设置为“f”表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、“e”表示 -d.dddde±dd 十进制指数、“E”表示 -d.ddddE±dd 十进制指数、“g”表示指数很大时用“e”格式，否则“f”格式、“G”表示指数很大时用“E”格式，否则“f”格式。</li>
<li>prec 控制精度（排除指数部分）：当参数 fmt 为“f”、“e”、“E”时，它表示小数点后的数字个数；当参数 fmt 为“g”、“G”时，它控制总的数字个数。如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num <span class="keyword">float64</span> = <span class="number">3.1415926</span></span><br><span class="line">	str := strconv.FormatFloat(num, <span class="string">&#x27;E&#x27;</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%T,value:%v\n &quot;</span>, str, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//type:string,value:3.1415926E+00</span></span><br></pre></td></tr></table></figure>
<h3 id="5-Append-系列函数-其他转str后加到切片中-​​​​​​​-AppendBool-、AppendFloat-、AppendInt-、AppendUint"><a href="#5-Append-系列函数-其他转str后加到切片中-​​​​​​​-AppendBool-、AppendFloat-、AppendInt-、AppendUint" class="headerlink" title="5.Append 系列函数(其他转str后加到切片中**)​​​​​​​:** AppendBool()、AppendFloat()、AppendInt()、AppendUint()"></a><strong>5.Append 系列函数(其他转str后</strong>加到切片中**)​​​​​​​<strong>:** </strong>AppendBool()、AppendFloat()、AppendInt()、AppendUint()</h3></li>
</ul>
<p>Append 系列函数和 Format 系列函数的使用方法类似，只不过是将转换后的结果追加到一个切片中。相比之下，入参多了一个[]string类型的数组，返回值是加完元素的数组。</p>
<p>函数原型：</p>
<p>func FormatBool(slice []string, b bool) []string</p>
<p>func FormatInt(slice []string, i int64, base int) []sting</p>
<p>func FormatUint(slice []string, i uint64, base int)  []string</p>
<p>func FormatFloat(slice []string, f float64, fmt byte, prec, bitSize int) []string</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明一个slice</span></span><br><span class="line">	b10 := []<span class="keyword">byte</span>(<span class="string">&quot;int (base 10):&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将转换为10进制的string，追加到slice中</span></span><br><span class="line">	b10 = strconv.AppendInt(b10, <span class="number">-42</span>, <span class="number">10</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(b10))</span><br><span class="line">	b16 := []<span class="keyword">byte</span>(<span class="string">&quot;int (base 16):&quot;</span>)</span><br><span class="line">	b16 = strconv.AppendInt(b16, <span class="number">-42</span>, <span class="number">16</span>)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(b16))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//int (base 10):-42</span></span><br><span class="line"><span class="comment">//int (base 16):-2a</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a><strong>三、参考链接</strong></h2><p><strong><a href="http://c.biancheng.net/view/5112.html"> Go语言strconv包：字符串和数值类型的相互转换</a></strong></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记（二）——计算字符串长度 len()和RuneCountInString()</title>
    <url>/2020/01/17/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6%20len()%E5%92%8CRuneCountInString()/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/103446306">https://blog.csdn.net/yushuaigee/article/details/103446306</a></p>
</blockquote>
<h3 id="1-内建函数-len-函数用来获取字符串的-ASCII-字符个数或字节长度。"><a href="#1-内建函数-len-函数用来获取字符串的-ASCII-字符个数或字节长度。" class="headerlink" title="1. 内建函数 len() 函数用来获取字符串的 ASCII 字符个数或字节长度。"></a>1. 内建函数 len() 函数用来获取字符串的 ASCII 字符个数或字节长度。</h3><p>由于 Go 语言的字符串都以 UTF-8 格式保存，每个中文占用 3 个字节，因此使用 len() 获得两个中文文字对应的 6 个字节。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(str1)) <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">	str2 := <span class="string">&quot;你好&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(str2)) <span class="comment">//6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-UTF-8-包提供的utf8-RuneCountInString-函数用来统计-Uncode-字符数量。"><a href="#2-UTF-8-包提供的utf8-RuneCountInString-函数用来统计-Uncode-字符数量。" class="headerlink" title="2. UTF-8 包提供的utf8.RuneCountInString() 函数用来统计 Uncode 字符数量。"></a>2. UTF-8 包提供的utf8.RuneCountInString() 函数用来统计 Uncode 字符数量。</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	fmt.Println(utf8.RuneCountInString(str1)) <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line">	str2 := <span class="string">&quot;你好&quot;</span></span><br><span class="line">	fmt.Println(utf8.RuneCountInString(str2)) <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-相应的，在遍历一个字符串时，也要注意ascii和Unicode的区别。"><a href="#3-相应的，在遍历一个字符串时，也要注意ascii和Unicode的区别。" class="headerlink" title="3.相应的，在遍历一个字符串时，也要注意ascii和Unicode的区别。"></a>3.相应的，在遍历一个字符串时，也要注意ascii和Unicode的区别。</h3><ul>
<li>用普通的 for 循环遍历时，取到的是对应的ascii码。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello 世界&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &amp;lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;ascii: %c\n&quot;</span>, str[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 输出：</li>
</ul>
<blockquote>
<p> 12<br> ascii: h<br> ascii: e<br> ascii: l<br> ascii: l<br> ascii: o<br> ascii:<br> ascii: ä<br> ascii: ¸<br> ascii:<br> ascii: ç<br> ascii:<br> ascii: </p>
</blockquote>
<ul>
<li>用 for … range 循环遍历时，取到的是对应的Unicode码。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;hello 世界&quot;</span></span><br><span class="line">	fmt.Println(utf8.RuneCountInString(str))</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> str &#123;</span><br><span class="line">	    fmt.Printf(<span class="string">&quot;Unicode: %c\n&quot;</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
输出：</li>
</ul>
<blockquote>
<p>  8<br> Unicode: h<br> Unicode: e<br> Unicode: l<br> Unicode: l<br> Unicode: o<br> Unicode:<br> Unicode: 世<br> Unicode: 界</p>
</blockquote>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go字符串长度</tag>
        <tag>RuneCountInString</tag>
        <tag>len</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang学习笔记（四）——Go语言的指针</title>
    <url>/2020/05/24/Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/106309176">https://blog.csdn.net/yushuaigee/article/details/106309176</a></p>
</blockquote>
<p>Go语言中的指针和C/C++ 中的指针用法基本相似。</p>
<p>指针（pointer）在Go语言中可以被拆分为两个核心概念：</p>
<ul>
<li>类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。</li>
<li>切片，由指向起始元素的原始指针、元素数量和容量组成。<br>受益于这样的约束和拆分，Go语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。</li>
</ul>
<h2 id="1-认识指针地址和指针类型"><a href="#1-认识指针地址和指针类型" class="headerlink" title="1.认识指针地址和指针类型"></a>1.认识指针地址和指针类型</h2><p>一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加<code>&amp;amp;</code>操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：</p>
<blockquote>
<p> ptr := &amp;v     // v 的类型为 T </p>
</blockquote>
<p> 取地址操作符<code>&amp;amp;</code>和取值操作符<code>*</code>是一对互补操作符，<code>&amp;amp;</code>取出地址，<code>*</code>根据地址取出地址指向的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取a指针的值, 赋给临时变量t</span></span><br><span class="line">	t := *a</span><br><span class="line">	<span class="comment">// 取b指针的值, 赋给a指针指向的变量</span></span><br><span class="line">	*a = *b</span><br><span class="line">	<span class="comment">// 将a指针的值赋给b指针指向的变量</span></span><br><span class="line">	*b = t</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 准备两个变量, 赋值1和2</span></span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	<span class="comment">// 交换变量值</span></span><br><span class="line">	swap(&amp;amp;x, &amp;amp;y)</span><br><span class="line">	<span class="comment">// 输出变量值</span></span><br><span class="line">	fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//2 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-创建指针的另一种方法——new-函数"><a href="#2-创建指针的另一种方法——new-函数" class="headerlink" title="2.创建指针的另一种方法——new() 函数"></a>2.创建指针的另一种方法——new() 函数</h2><p>Go语言还提供了另外一种方法来创建指针变量，格式如下：</p>
<blockquote>
<p> new(类型) </p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">*str = <span class="string">&quot;Go语言教程&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(*str)</span><br></pre></td></tr></table></figure>
<p>new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Python获取多网卡的IP地址的几种方法(Linux系统)</title>
    <url>/2019/03/23/Python%E8%8E%B7%E5%8F%96%E5%A4%9A%E7%BD%91%E5%8D%A1%E7%9A%84IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95(Linux%E7%B3%BB%E7%BB%9F)/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/86682583">https://blog.csdn.net/yushuaigee/article/details/86682583</a></p>
</blockquote>
<p>过年之前，有一个任务是将原来的windows工具客户端改写一个Linux版本，对于python来说，很好移植。不过其中有一个很关键的步骤是获取当前设备的ip地址，window版的函数不能直接拿来用了。</p>
<p>本来很简单的一件事，由于公司许多机器的Linux版本不同，机器的网卡数量也不一样，本来在自己的机器测试完没问题，拿给别人一用就出现各种问题，适配完，换了机器又出现新的问题，导致前前后后竟然改了四种方法。</p>
<p>思路无非就是通过获取linux命令的输出结果来解析出每个ip，试过很多命令加正则表达式的组合，实现是肯定可以实现，但是越弄越复杂，感觉不够优雅，而且不能保证适配所有版本的系统，最后竟然在一篇博客发现了一个命令只需要一行代码，当时的心情真的是哭笑不得。这里记录一下，以备不时之需。</p>
<p>命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrs</span>(<span class="params">self</span>):</span></span><br><span class="line">    p = Popen(<span class="string">&quot;hostname -I&quot;</span>, shell=<span class="literal">True</span>, stdout=PIPE)</span><br><span class="line">    data = p.stdout.read() <span class="comment"># 获取命令输出内容</span></span><br><span class="line">    data = <span class="built_in">str</span>(data,encoding = <span class="string">&#x27;UTF-8&#x27;</span>) <span class="comment"># 将输出内容编码成字符串</span></span><br><span class="line">    ip_list = data.split(<span class="string">&#x27; &#x27;</span>) <span class="comment"># 用空格分隔输出内容得到包含所有IP的列表</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;\n&quot;</span> <span class="keyword">in</span> ip_list: <span class="comment"># 发现有的系统版本输出结果最后会带一个换行符</span></span><br><span class="line">        ip_list.remove(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    print(ip_list)</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p> [202.196.1.0, 202.196.1.1] </p>
</blockquote>
<p>之前用的方法（Linux）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrsV2</span>(<span class="params">self</span>):</span></span><br><span class="line">    p = Popen(<span class="string">&quot;ifconfig | grep &#x27;inet &#x27; | grep -v &#x27;127.0.0.1&#x27; | awk &#x27;&#123;print $2&#125;&#x27;&quot;</span>, shell=<span class="literal">True</span>, stdout=PIPE)</span><br><span class="line">    data = p.stdout.read()</span><br><span class="line">    data = <span class="built_in">str</span>(data,encoding = <span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">    ip_list = data.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    ip_list.remove(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    ip_list2 = []</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> ip_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> ip:</span><br><span class="line">            ip_list2.append(ip.split(<span class="string">&quot;:&quot;</span>)[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip_list2.append(ip)</span><br><span class="line">    print(ip_list2)</span><br><span class="line">    <span class="keyword">return</span> ip_list2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrsV3</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">import</span> psutil</span><br><span class="line">    netcard_info = []</span><br><span class="line">    info = psutil.net_if_addrs()</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> info.items():</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> v:</span><br><span class="line">            <span class="keyword">if</span> item[<span class="number">0</span>] == <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> item[<span class="number">1</span>] == <span class="string">&#x27;127.0.0.1&#x27;</span>:</span><br><span class="line">                <span class="comment"># netcard_info.append((k, item[1]))</span></span><br><span class="line">                netcard_info.append( item[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> netcard_info</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrsV4</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">import</span> fcntl</span><br><span class="line">    <span class="keyword">import</span> struct</span><br><span class="line">    ifname = <span class="string">b&#x27;enp0s31f6&#x27;</span> <span class="comment"># 网卡名字</span></span><br><span class="line">    ip_list = []</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    ip = socket.inet_ntoa(fcntl.ioctl(s.fileno(),<span class="number">0x8915</span>,struct.pack(<span class="string">b&#x27;256s&#x27;</span>, ifname[:<span class="number">15</span>]))[<span class="number">20</span>:<span class="number">24</span>])</span><br><span class="line">    ip_list.append(ip)</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br></pre></td></tr></table></figure>
<p>之前用的方法（Windows）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;获取pc的IPv4地址&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIPAddrs</span>(<span class="params">self</span>):</span></span><br><span class="line">    ip_list = socket.gethostbyname_ex(socket.gethostname())</span><br><span class="line">    <span class="keyword">for</span> ips <span class="keyword">in</span> ip_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(ips) == <span class="built_in">list</span> <span class="keyword">and</span> <span class="built_in">len</span>(ips) != <span class="number">0</span>:</span><br><span class="line">            IPlist = ips</span><br><span class="line">    <span class="keyword">return</span> IPlist</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">getIPAddrsV2</span>(<span class="params">self</span>):</span></span><br><span class="line">     p = Popen(<span class="string">&#x27;ipconfig|findstr IPv4&#x27;</span>, shell=<span class="literal">True</span>, stdout=PIPE)</span><br><span class="line">     data = p.stdout.read().decode(encoding=<span class="string">&#x27;gb2312&#x27;</span>)</span><br><span class="line">     IPlist = []</span><br><span class="line">     splitlist = re.split(<span class="string">&#x27;[\r:]&#x27;</span>, data)</span><br><span class="line">     <span class="keyword">for</span> eachpart <span class="keyword">in</span> splitlist:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> eachpart <span class="keyword">and</span> <span class="string">&#x27;IP&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> eachpart:</span><br><span class="line">             IPlist.append(eachpart.strip())</span><br><span class="line">     <span class="keyword">return</span> IPlist</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>获取网卡ip</tag>
      </tags>
  </entry>
  <entry>
    <title>python3 线程池实现批量ping某一网段，获得可用ip列表——futures模块</title>
    <url>/2018/12/25/python3%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8Fping%E6%9F%90%E4%B8%80%E7%BD%91%E6%AE%B5%EF%BC%8C%E8%8E%B7%E5%BE%97%E5%8F%AF%E7%94%A8ip%E5%88%97%E8%A1%A8%E2%80%94%E2%80%94futures%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/85244394">https://blog.csdn.net/yushuaigee/article/details/85244394</a></p>
</blockquote>
<h2 id="一、工作中需要找出指定网段里，哪些ip是没被占用的，然后使用这些ip。"><a href="#一、工作中需要找出指定网段里，哪些ip是没被占用的，然后使用这些ip。" class="headerlink" title="一、工作中需要找出指定网段里，哪些ip是没被占用的，然后使用这些ip。"></a>一、工作中需要找出指定网段里，哪些ip是没被占用的，然后使用这些ip。</h2><p>实现方法很简单，就是依次ping一下，看看哪些是不通的，就代表没被占用。ping是很耗时间的，于是想到多线程，考虑到线程数量多且每个线程的任务很简单，所以使用线程池。参考了网上博主的代码，原文链接：《<a href="http://blog.51cto.com/maoxian/2119898">Python多线程批量Ping主机IP的脚本</a>》，主要学到了Python队列queue的概念和后台调用cmd控制台的方法。</p>
<p>我的代码如下：</p>
<p>第一个参数<code>net_segment</code>代表要查找的网段，第二个参数<code>ip_num</code>代表所需 ip 的数量。通过修改<code>max_workers=100</code> 的值可以调整程序运行的速度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_list</span>(<span class="params">net_segment, ip_num</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    IP_QUEUE = Queue()</span><br><span class="line">    ip_list = []</span><br><span class="line">    list_segment = net_segment.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    ip_index = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将需要 ping 的 ip 加入队列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">254</span>):</span><br><span class="line">        list_segment[-<span class="number">1</span>] = <span class="built_in">str</span>(ip_index + i)</span><br><span class="line">        addr = (<span class="string">&#x27;.&#x27;</span>).join(list_segment)</span><br><span class="line">        IP_QUEUE.put(addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个执行 ping 的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping_ip</span>(<span class="params">ip</span>):</span></span><br><span class="line">        res = subprocess.call(<span class="string">&#x27;ping -n 2 -w 5 %s&#x27;</span> % ip, stdout=subprocess.PIPE)  <span class="comment"># linux 系统将 &#x27;-n&#x27; 替换成 &#x27;-c&#x27;</span></span><br><span class="line">        <span class="comment"># 打印运行结果</span></span><br><span class="line">        print(ip, <span class="literal">True</span> <span class="keyword">if</span> res == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> res != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> lock.acquire():</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(ip_list) &amp;lt; ip_num:</span><br><span class="line">                    ip_list.append(ip)</span><br><span class="line">                lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个最大任务为100的线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">100</span>)</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    all_task = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> IP_QUEUE.empty():</span><br><span class="line">        all_task.append(pool.submit(ping_ip, IP_QUEUE.get()))</span><br><span class="line">    <span class="comment"># 等待所有任务结束</span></span><br><span class="line">    wait(all_task, return_when=ALL_COMPLETED)</span><br><span class="line">    print(<span class="string">&#x27;ping耗时：%s&#x27;</span> % (time.time() - start_time))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ip_list) &amp;lt; ip_num:</span><br><span class="line">        print(<span class="string">&quot;Warning：当前网段可用ip不够，需要数量：%s，可用数量：%s&quot;</span> % (<span class="built_in">str</span>(ip_num), <span class="built_in">str</span>(<span class="built_in">len</span>(ip_list))))</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_list = get_ip_list(<span class="string">&quot;202.169.50.0&quot;</span>, <span class="number">200</span>)</span><br><span class="line">    print(ip_list)</span><br><span class="line">    print(<span class="built_in">len</span>(ip_list))</span><br></pre></td></tr></table></figure>
<p>部分运行结果：</p>
<blockquote>
<p>202.169.50.238 False<br>202.169.50.253 False<br>202.169.50.239 False<br>202.169.50.230 False<br>ping耗时：6.348670959472656<br>Warning：当前网段可用ip不够，需要数量：200，可用数量：168<br>[‘202.169.50.3’, ‘202.169.50.20’, ‘202.169.50.19’, ‘202.169.50.78’,…………………………………………………………]<br>168 </p>
</blockquote>
<h2 id="二、代码稍作修改，可以查看某两个ip之间哪些地址ping的通，哪些ping不通。"><a href="#二、代码稍作修改，可以查看某两个ip之间哪些地址ping的通，哪些ping不通。" class="headerlink" title="二、代码稍作修改，可以查看某两个ip之间哪些地址ping的通，哪些ping不通。"></a>二、代码稍作修改，可以查看某两个ip之间哪些地址ping的通，哪些ping不通。</h2><p>这里用到处理ip地址的标准库 <code>ipaddress</code> 模块，来处理ip地址的计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, ALL_COMPLETED</span><br><span class="line"><span class="keyword">from</span> ipaddress <span class="keyword">import</span> ip_address</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_list</span>(<span class="params">ip_start, ip_end</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个队列</span></span><br><span class="line">    IP_QUEUE = Queue()</span><br><span class="line">    ip_used = []</span><br><span class="line">    ip_not_used = []</span><br><span class="line">    ip_start = ip_address(ip_start)</span><br><span class="line">    ip_end = ip_address(ip_end)</span><br><span class="line">    <span class="keyword">while</span> ip_start &amp;lt;= ip_end:</span><br><span class="line">        IP_QUEUE.put(<span class="built_in">str</span>(ip_start))</span><br><span class="line">        ip_start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个执行 ping 的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping_ip</span>(<span class="params">ip</span>):</span></span><br><span class="line">        res = subprocess.call(<span class="string">&#x27;ping -n 2 -w 5 %s&#x27;</span> % ip, stdout=subprocess.PIPE)  <span class="comment"># linux 系统将 &#x27;-n&#x27; 替换成 &#x27;-c&#x27;</span></span><br><span class="line">        <span class="comment"># 打印运行结果</span></span><br><span class="line">        print(ip, <span class="literal">True</span> <span class="keyword">if</span> res == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> lock.acquire():</span><br><span class="line">            <span class="keyword">if</span> res == <span class="number">0</span>:</span><br><span class="line">                ip_used.append(ip)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ip_not_used.append(ip)</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个最大任务为100的线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">120</span>)</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    all_task = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> IP_QUEUE.empty():</span><br><span class="line">        all_task.append(pool.submit(ping_ip, IP_QUEUE.get()))</span><br><span class="line">    <span class="comment"># 等待所有任务结束</span></span><br><span class="line">    wait(all_task, return_when=ALL_COMPLETED)</span><br><span class="line">    print(<span class="string">&#x27;ping耗时：%s&#x27;</span> % (time.time() - start_time))</span><br><span class="line">    <span class="keyword">return</span> ip_used, ip_not_used</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip_used, ip_not_used = get_ip_list(<span class="string">&quot;202.169.50.1&quot;</span>, <span class="string">&quot;202.169.51.255&quot;</span>)</span><br><span class="line">    print(<span class="built_in">str</span>(<span class="built_in">len</span>(ip_used))+<span class="string">&quot;已用&quot;</span>, <span class="string">&quot;\n&quot;</span>, ip_used)</span><br><span class="line">    print(<span class="built_in">str</span>(<span class="built_in">len</span>(ip_not_used))+<span class="string">&quot;未用&quot;</span>, <span class="string">&quot;\n&quot;</span>, ip_not_used)</span><br></pre></td></tr></table></figure>
<p>部分运行结果：</p>
<blockquote>
<p>202.169.51.222 False<br>202.169.51.249 False<br>202.169.51.200 False<br>202.169.51.208 False<br>ping耗时：10.248608827590942<br>86已用<br> [‘202.169.50.2’, ‘202.169.50.8’, ‘202.169.50.7’,…………………………………………]<br>425未用<br> [‘202.169.50.3’, ‘202.169.50.19’, ‘202.169.50.78’…………………………………………] </p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>批量ping</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</title>
    <url>/2021/01/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%83)%E2%80%94%E2%80%94%E8%BF%81%E7%A7%BB%20CSDN%20%E5%8D%9A%E5%AE%A2%E5%88%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<blockquote>
<p>   ​    本文是博客搭建系列文章第六篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaige.github.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaige.github.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaige.github.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——<a href="https://yushuaigee.gitee.io/2021/01/21/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%85%AD)%E2%80%94%E2%80%94%E4%B8%89%E4%B8%AA%E7%AB%99%E7%82%B9%E4%B8%80%E9%94%AE%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/">三个站点一键发布博客</a></li>
<li><strong>从零开始免费搭建自己的博客(七)——<a href="https://yushuaigee.gitee.io/2021/01/26/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%83)%E2%80%94%E2%80%94%E8%BF%81%E7%A7%BB%20CSDN%20%E5%8D%9A%E5%AE%A2%E5%88%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AB%99%E7%82%B9/">迁移 CSDN 博客到个人博客站点</a></strong></li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CSDN 没有提供文章导出功能，只有导入功能，我们想把自己以前写的文章迁移到其他平台或者自己的博客网站，还得自己想办法爬取下来。可是那是我写的文章啊，竟然不能想拿就拿回来。。。</p>
<p>我看到需多人的实现思路，是使用文章界面点击编辑按钮的接口，获取自己之前的文章 Markdown 源码。这样还得先登录自己的账号，而且前提是之前文章是用 Markdown 编辑器写的。其实不管是富文本编辑器还是 Markdown 编辑器写的，最终呈现的都是一个 html 网页，不需要登录就可以看到。之前介绍 Typora 时说过， Markdown 语法和 html 语法本来就类似，所以本文思路是直接下载 html 然后转化为 Markdown 格式。</p>
<p>在 CSDN 页面结构不发生改变的情况下，我们可以用这种方法下载 CSDN 上任意文章并保存成 Markdown 格式。只有写过博客的人才知道原创一篇文章要花费多少精力，所以希望大家如果下载别人的文章一定要标明原地址，这是基本节操。</p>
<h2 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h2><p>语言：<code>Python3</code>。</p>
<p>第三方库：<code>requests</code>、<code>parsel </code>、<code>tomd</code>。</p>
<p>当然可以使用上一篇用到的 <a href="https://github.com/miyakogi/pyppeteer">pyppeteer</a>，不多对于这个需求来说速度太慢。CSDN 目前没有设置很多反爬虫机制，所以用轻量的 <a href="https://github.com/psf/requests">requests</a> 就够了。</p>
<p><code>parsel </code>是 <a href="https://github.com/scrapy">Scrapy</a> 框架内置的 html 解析库，后来独立出来。选择 <a href="https://github.com/scrapy/parsel">parsel </a>也是因为够用，且比 <a href="https://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</a> 更轻。</p>
<p>html 转 Markdown 的库找到两个：<a href="https://github.com/gaojiuli/tomd">tomd</a> 和 <a href="https://github.com/aaronsw/html2text">html2text</a> ，试了一下都挺好用的，美中不足的是两个库转换完的代码块都没有标识语言类别，导致代码无法高亮。我看了 html 源码是有是语言类别信息的，所以需要对库稍作改动才能达到完美的效果。<code>tomd</code> 的原理比较简单粗暴，直接是正则表达式查找替换，源码就一个文件，比较好改，改动点和源码在下面。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><ol>
<li>获取自己主页文章列表，包括标题和文章地址。</li>
<li>根据上一步获取的文章地址，获取文章的标题、正文、标签、分类、发布时间。</li>
<li>根据上一步获取的文章正文，将 html 格式文本转为 md 格式。</li>
<li>新建<code>.md</code>文件，先添加标题、标签、分类、发布时间，再写入 md 正文。</li>
<li>使用上一篇文章中实现的一键发布脚本将本地保存的博客发布到自己的博客。</li>
</ol>
<h2 id="tomd修改"><a href="#tomd修改" class="headerlink" title="tomd修改"></a>tomd修改</h2><p>在使用<code>tomd</code>的过程中遇到两个问题，好在源码只有一个文件，原理也很简单，稍微看一下代码逻辑就可以解决。</p>
<ol>
<li><p>无序列表转化后没有换行，导致无序列表只有一行。需要修改<code>tomd.py</code>文件第<code>103</code>行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126224109198.png" alt="image-20210126224109198"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">elif</span> self.tag == <span class="string">&#x27;ul&#x27;</span> <span class="keyword">and</span> tag == <span class="string">&#x27;li&#x27;</span>:</span><br><span class="line">    self.content = re.sub(pattern, <span class="string">&#x27;\n- \g&lt;1&gt;&#x27;</span>, self.content)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126224458389.png" alt="image-20210126224458389"></p>
</li>
<li><p>代码块没有标识语言类别，无法代码高亮。需要修改<code>tomd.py</code>文件第<code>19</code>行和第<code>50</code>行。各加三行，根据实际用到的语言。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126230335050.png" alt="image-20210126230335050"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126230422905.png" alt="image-20210126230422905"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &#x27;block_code&#x27;: (&#x27;\n```\n&#x27;, &#x27;\n```\n&#x27;),</span></span><br><span class="line"><span class="string">&#x27;block_code_go&#x27;</span>: (<span class="string">&#x27;\n```go\n&#x27;</span>, <span class="string">&#x27;\n```\n&#x27;</span>),</span><br><span class="line"><span class="string">&#x27;block_code_py&#x27;</span>: (<span class="string">&#x27;\n```python\n&#x27;</span>, <span class="string">&#x27;\n```\n&#x27;</span>),</span><br><span class="line"><span class="string">&#x27;block_code_java&#x27;</span>: (<span class="string">&#x27;\n```java\n&#x27;</span>, <span class="string">&#x27;\n```\n&#x27;</span>),   </span><br><span class="line"><span class="string">&#x27;block_code_cpp&#x27;</span>: (<span class="string">&#x27;\n```c\n&#x27;</span>, <span class="string">&#x27;\n```\n&#x27;</span>), </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># &#x27;block_code&#x27;: &#x27;&lt;pre.*?&gt;&lt;code.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;,</span></span><br><span class="line">   <span class="string">&#x27;block_code_go&#x27;</span>: <span class="string">&#x27;&lt;pre.*?&gt;&lt;code.*?Go.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;block_code_py&#x27;</span>: <span class="string">&#x27;&lt;pre.*?&gt;&lt;code.*?python.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;block_code_java&#x27;</span>: <span class="string">&#x27;&lt;pre.*?&gt;&lt;code.*?java.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;block_code_cpp&#x27;</span>: <span class="string">&#x27;&lt;pre.*?&gt;&lt;code.*?cpp.*?&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;&#x27;</span>,</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/image-20210126230230535.png" alt="image-20210126230230535"></p>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">csdn_to_md.py</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> parsel</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> tomd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_article_info</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = requests.get(url, headers=headers).text</span><br><span class="line">    selector = parsel.Selector(html)</span><br><span class="line">    urls = selector.css(<span class="string">&#x27;#articleMeList-blog &gt; div.article-list &gt; div &gt; h4 &gt; a&#x27;</span>).xpath(<span class="string">&#x27;.//@href&#x27;</span>).getall()</span><br><span class="line">    print(<span class="string">&#x27;共找到%d篇文章...&#x27;</span> % <span class="built_in">len</span>(urls))</span><br><span class="line">    <span class="keyword">return</span> urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html_from_csdn</span>(<span class="params">url</span>):</span></span><br><span class="line">    html = requests.get(url, headers=headers).text</span><br><span class="line">    selector = parsel.Selector(html)</span><br><span class="line">    title = selector.css(<span class="string">&#x27;div.article-title-box &gt; h1::text&#x27;</span>).get()</span><br><span class="line">    article = selector.css(<span class="string">&#x27;div.article_content&#x27;</span>).get()</span><br><span class="line">    category = selector.css(<span class="string">&#x27;div.blog-tags-box &gt; div &gt; a::text&#x27;</span>).getall()[<span class="number">0</span>]</span><br><span class="line">    tags = selector.css(<span class="string">&#x27;div.blog-tags-box &gt; div &gt; a[data-report-click*=&quot;mod&quot;]::text&#x27;</span>).getall()</span><br><span class="line">    time_stamp = selector.css(<span class="string">&#x27;div &gt; span.time::text&#x27;</span>).get()</span><br><span class="line">    author = selector.css(<span class="string">&#x27;#uid &gt; span.name::text&#x27;</span>).get()</span><br><span class="line">    origin = url</span><br><span class="line">    <span class="keyword">return</span> title, article, category, tags, time_stamp, author, origin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">html_to_md</span>(<span class="params">title, article, category, tags, time_stamp, author, origin</span>):</span></span><br><span class="line">    md = tomd.convert(article)</span><br><span class="line">    <span class="comment"># 图片url标准化</span></span><br><span class="line">    url_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;img.*?(https://.*?\.gif|https://.*?\.png).*?&quot;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> src_url <span class="keyword">in</span> url_pattern.finditer(md):</span><br><span class="line">        img_name = src_url.group(<span class="number">1</span>).split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        md = md.replace(src_url.group(<span class="number">0</span>), <span class="string">&#x27;![%s](%s)&#x27;</span> % (img_name, src_url.group(<span class="number">1</span>)))</span><br><span class="line">    print(<span class="string">&#x27;正在下载 %s&#x27;</span> % title)</span><br><span class="line">    text = <span class="string">&quot;---\ntitle: %s\ndate: %s\ntags: [%s]\ncategories: %s\n---\n\n&gt; 作者: %s\n&gt; 原文链接: %s\n%s&quot;</span> % (</span><br><span class="line">        title, time_stamp, <span class="string">&#x27;, &#x27;</span>.join(tags), category, author, origin, md)</span><br><span class="line">    <span class="comment"># Windows下文件名字不能包含特殊符号</span></span><br><span class="line">    file_name = re.sub(<span class="string">r&#x27;[\\/:*?&quot;&lt;&gt;|]&#x27;</span>, <span class="string">&#x27; &#x27;</span>, title)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;articles/%s.md&#x27;</span> % file_name.strip(), <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;articles&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;articles&#x27;</span>)</span><br><span class="line">    article_urls = get_article_info(url)</span><br><span class="line">    <span class="keyword">for</span> article_url <span class="keyword">in</span> article_urls:</span><br><span class="line">        title, article, category, tags, time_stamp, author, origin = get_html_from_csdn(article_url)</span><br><span class="line">        html_to_md(title, article, category, tags, time_stamp, author, origin)</span><br><span class="line">    print(<span class="string">&#x27;完成%d篇文章的下载&#x27;</span> % <span class="built_in">len</span>(article_urls))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;blog.csdn.net&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://blog.csdn.net&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3542.0 Safari/537.36&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    start_url = <span class="string">&quot;https://blog.csdn.net/用户名&quot;</span></span><br><span class="line">    main(start_url)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>本文解决了将 CSDN 上使用富文本编辑器写的文章下载到本地转化成 Markdown 格式的问题，然后再配合上一篇中实现的一键发布脚本，就可以实现三个博客站点的同步了。到这里，已经实现了我自认为很完美的效果，以后就可以开开心心安安静静的写博客了。</p>
<p>我们看别人的独立博客，包括一些博主自己定制的博客园页面时，经常会看到一些有意思的特效，比如切换页签时原标题会变成调皮搞笑的文字，页面点击出现文字或爱心，页面出现跟随鼠标的随机线条，页面动态下雨或雪花，还有可以点击互动的小老鼠、二次元妹子等等，这些效果有的 Hexo 主题就内置了只需要把开关打开，有的需要自己手动加代码实现，因为它们本质上就是一段 js 代码(突然想起在以前公司有一次被安排到前端帮忙，曾经“沉迷”于在系统登录页面添加这些特效，hh)。还有一些针对 Hexo 的优化内容，比如提升页面加载速度，seo 优化，全文搜索插件等。这两项内容准备在最后一篇文章介绍。</p>
<p>写本系列文章第一篇之前，我并没有接触过 Hexo 这些东西，不知道 GitHub Pages 还能这样用，更不知道原来搭建博客里面有这么大的名堂，甚至一直没用 Markdown 写博客。决定自己搭建博客后，我先大概查了一下资料，然后把 8 篇文章的标题确定下来，形成一个大纲。其实在写前面几篇文章的时候，我还没把自己的博客搭起来，是后面一边学习一边操作一边记录，从小白的角度去弄懂每个步骤的原理，将过程记录下来，希望可以帮助更多的小伙伴。还有个意外收获，那就是发现了这是一个学习新东西的好方法。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>html转markdown</tag>
        <tag>下载csdn文章</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(三)——基于 Gitee pages 建站</title>
    <url>/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%89)%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%20Gitee%20pages%20%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>​    本文是博客搭建系列文章第三篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li>从零开始免费搭建自己的博客(二)——<a href="https://yushuaigee.gitee.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></li>
<li><strong>从零开始免费搭建自己的博客(三)——<a href="https://yushuaigee.gitee.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></strong></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第一篇文章里，我们利用 Hexo 框架在本地搭建了一个精美的博客，第二篇文章里，我们利用 GitHub 提供的免费静态网页托管服务建立了个人博客网站，将博客发布到了互联网上。</p>
<p>可是我们写博客的原因，一个是方便自己在不同的地方能直接打开网页就可以回顾知识，一个是为了方便他人查阅参考。由于国内网络环境的原因，某些地方某些时间，访问 GitHub 会比较慢，这就会导致博客无法被别人访问或者自己换个地方上网时也打不开自己的博客。</p>
<p>好消息是现在国内有和 GitHub 功能类似的 Gitee，中文名码云。之前也有注意到这个平台，当时以为他仅仅是山寨 GitHub 而已，肯定火不起来。没想到随着 GitHub 网络环境越来越差，下载个工程才几kb的速度，经常等了很久之后下载失败。有一次尝试了下将 GitHub 项目同步到 Gitee 再下载，速度直接起飞，真香。随着许多有影响力的项目加入了 Gitee ，一些大佬的博客也开始推荐使用码云了，使用的人也越来越多了。</p>
<p>当然了，使用 Gitee Pages 相对于 GitHub Pages 网速是上来了，也有很多缺点。我在实际使用过程中遇到了许多DAN疼的地方，比如每次提交需要手动更新部署，以及大于1M图片登陆后可见等，我会在下面文章中用<strong>加粗</strong>字体指出。没办法，鱼和熊掌不可兼得( ╯▽╰)。准备在第八篇讲优化的文章中尝试一种完美解决方案(GitHub + CDN加速)。</p>
<p>本篇文章介绍怎样利用 Gitee  提供的免费静态网页托管服务 Gitee Pages 建站。</p>
<h2 id="一、-Gitee-Pages-简介"><a href="#一、-Gitee-Pages-简介" class="headerlink" title="一、 Gitee Pages 简介"></a>一、 Gitee Pages 简介</h2><p>上篇说了，GitHub 设计 Pages 功能是为了让用户能设计一个图文并茂的网页作为项目首页，提升新手友好度。那么Gitee为什么要提供网页托管服务呢？应该是同样的原因，或者说是因为 GitHub 有这个功能？( ╯▽╰)</p>
<p><a href="https://gitee.com/help/articles/4136">Gitee pages 官网</a> 的介绍：Gitee Pages 是一个免费的静态网页托管服务，您可以使用 Gitee Pages 托管博客、项目官网等静态网页。如果您使用过 Github Pages 那么您会很快上手使用 Gitee 的 Pages服务。目前 Gitee Pages 支持 Jekyll、Hugo、Hexo编译静态资源。</p>
<h2 id="二、Gitee-Pages-准备"><a href="#二、Gitee-Pages-准备" class="headerlink" title="二、Gitee Pages 准备"></a>二、Gitee Pages 准备</h2><p>在发布之前，要先准备好自己的 Gitee Pages 。</p>
<p>Gitee Pages 仓库的创建方法和 GitHub 略有不同，官网的帮助文档提供了两种创建方法，第一种是直接在 Gitee 上创建仓库，第二种是直接把 GitHub 创建好的仓库同步过来。比如已经按照上一篇的方法在 GitHub 建立了博客，想在 Gitee 再搭建一次作为一个备份，可以直接用第二种方法同步过来。</p>
<h3 id="1-注册-Gitee-账号"><a href="#1-注册-Gitee-账号" class="headerlink" title="1. 注册 Gitee 账号"></a>1. 注册 Gitee 账号</h3><p>首先需要注册一个 Gitee 账号，如果已经有账号直接看下一步。</p>
<p>打开 Gitee 官网：<a href="https://gitee.com/">gitee.com</a>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231193126082.png" alt="image-20201231193126082"></p>
<p>点击右上角<kbd>注册</kbd>按钮，填写用户名，手机，验证码。也可以根据下面的选项使用其他平台账号登录。注意，此处用户名是唯一ID，建议取个有意义的名字。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231193349306.png" alt="image-20201231193349306"></p>
<h3 id="2-创建-Gitee-Pages-仓库"><a href="#2-创建-Gitee-Pages-仓库" class="headerlink" title="2. 创建 Gitee Pages 仓库"></a>2. 创建 Gitee Pages 仓库</h3><p>登录账号后，点击页面右上角的<kbd>+</kbd>，选择<kbd>新建仓库</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231193543517.png" alt="image-20201231193543517"></p>
<p>仓库名称这里建议填写<code>你的用户名</code>，这样生成出来的网页地址是比较纯净的形式，如<code>https://&lt;你的用户名&gt;.github.io</code>。当然也可以自定义名称，比如<code>blog </code>，但是这样后面生成出来的网页地址会带一个子目录，像<code>https://&lt;你的用户名&gt;.github.io/blog</code>这样。</p>
<p>仓库介绍填写仓库描述，比如 <code>jacksparrow&#39;s blog</code>等，可不填。</p>
<p>注意勾选 <code>使用Readme文件初始化这个仓库</code>，会自动创建<code>master</code>分支并生成一个 <code>readme.md</code>文件。</p>
<p>最后点击下面的<kbd>创建</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231214142085.png" alt="image-20201231214142085"></p>
<p>点击页面右上角的<kbd>服务</kbd>，选择<kbd>Gitee Pages</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231215720997.png" alt="image-20201231215720997"></p>
<p>勾选<code>强制使用HTTPS</code>，点击<kbd>启动</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231220540958.png" alt="image-20201231220540958"></p>
<h3 id="3-测试-Gitee-Pages-页面"><a href="#3-测试-Gitee-Pages-页面" class="headerlink" title="3. 测试  Gitee Pages 页面"></a>3. 测试  Gitee Pages 页面</h3><p>创建 Gitee Pages 仓库后，为了测试能否访问 Pages 服务，我们给它添加一个静态网页。</p>
<p>先点击左边的<kbd>代码</kbd>回到文件页面，然后点击<kbd>文件</kbd> – <kbd>新建文件</kbd>在仓库下新建文件。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231220911962.png" alt="image-20201231220911962"></p>
<p>输入文件名<code>index.html</code>，在下面输入内容<code>&lt;h1&gt;这是我的博客!&lt;/h1&gt;</code>，这是 html 标记语言，表示一级标题。</p>
<p>其他保持默认，点击最下面的<kbd>提交</kbd>，提交文件到仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231221057010.png" alt="image-20201231221057010"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231195353883.png" alt="image-20201231195353883"></p>
<p><strong>与 GitHub 提交自动部署不同的是，Gitee上提交后需要手动部署。</strong>(网上有许多实现了 Gitee Pages 自动部署的脚本，其实就是用脚本模拟下面的操作，可以参考)</p>
<p>点击页面右上角的<kbd>服务</kbd>，选择<kbd>Gitee Pages</kbd>回到部署界面。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231222024946.png" alt="image-20201231222024946"></p>
<p>点击下面的<kbd>更新</kbd>，下图中红框圈出的就是你的博客地址了，格式为<code>https://&lt;你的用户名&gt;.github.io</code>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231222215450.png" alt="image-20201231222215450"></p>
<p>点击博客地址或者在浏览器输入博客地址。此时就可以看见我们刚创建的网页，其中的内容就是刚才写的内容。说明 Gitee Pages 服务已经正常。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231222626659.png" alt="image-20201231222626659"></p>
<h2 id="三、Gitee-Pages-发布"><a href="#三、Gitee-Pages-发布" class="headerlink" title="三、Gitee Pages 发布"></a>三、Gitee Pages 发布</h2><p>上一步 “测试  Gitee Pages 页面” 中，我们在 Gitee Pages 仓库目录下新建了一个<code>index.html</code>，就可以在自己的专属网址看到这个网页了。同理我们把自己的博客生成静态 html 网页，提交到这个仓库目录下，就可以在我们的网址看到博客页面了，这就是 Hexo 框架部署博客的原理。当然，对于 Hexo 来说，部署提交只需要几条命令。</p>
<h3 id="1-配置-Git-参数"><a href="#1-配置-Git-参数" class="headerlink" title="1. 配置 Git 参数"></a>1. 配置 Git 参数</h3><p>过程跟上篇文章一样，已经做过的步骤不用再重复，直接到复制公钥那一步。</p>
<p>在博客根目录下，右键，打开<kbd>Git Bash Here</kbd>。</p>
<p>配置用户名和邮箱，这两个参数用于 Git 提交时的身份识别。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中 username 和 username@XXX.com 是你注册 Gitee 的用户名和邮箱，如果账号不是邮箱注册的话，填自己的一个邮箱地址就行了</span></span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233907818.png" alt="image-20201229233907818"></p>
<p>生成 SSH keys，主要用于Git 提交时的权限控制和加密，本地根据 RSA 算法生成公私密钥对，然后将公钥添加到 Gitee 上，本机就可以提交代码到自己的 GitHub 库了。这个是根据当前使用的电脑的一些信息生成的，所以换电脑提交时要重新生成并添加。</p>
<p>输入下面命令，然后一直按<kbd>回车</kbd>，直到结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中 username@XXX.com 同上，是你的注册邮箱</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233801498.png" alt="image-20201229233801498"></p>
<p>输入下面的命令，查看公钥内容，应该是一个<code>ssh-rsa</code>开头，以<code>你的邮箱</code>结尾的长字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat后面的路径就是上图中的公钥文件路径，直接复制过来就可以。其中XXX是你的电脑用户名。</span></span><br><span class="line">cat /c/Users/XXX/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229234452012.png" alt="image-20201229234452012"></p>
<p>复制公钥内容（其实在<kbd>Git Bash</kbd>命令行里，默认选中文字松开鼠标就会自动把选中内容复制到剪贴板，点击鼠标中键是粘贴）。</p>
<p>打开自己的 Gitee 主页，点击右上角的头像，点击<kbd>设置</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231223248489.png" alt="image-20201231223248489"></p>
<p>点击<kbd>SSH公钥</kbd>。<code>标题</code>可以随便起一个名字，<code>公钥</code>填写上一步复制的公钥内容，然后点击<kbd>确定</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201231223630767.png" alt="image-20201231223630767"></p>
<p>最后执行下面的命令，测试一下 Git 参数是否配置成功。出现<code>你的用户名</code>和<code>successfully</code>字样，说明配置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面的命令什么都不用改</span></span><br><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210101125339173.png" alt="image-20210101125339173"></p>
<h3 id="2-安装-Hexo-发布插件"><a href="#2-安装-Hexo-发布插件" class="headerlink" title="2. 安装 Hexo 发布插件"></a>2. 安装 Hexo 发布插件</h3><p>上一篇已经安装过可以跳过这一步。</p>
<p>在博客根目录下，右键，打开<kbd>Git Bash Here</kbd>。</p>
<p>输入下面的命令，安装<code>hexo-deployer-git</code>。（安装失败或者卡住，参考第一篇文章修改 npm 源。）</p>
<p>这个插件用于把生成好的静态页面上传到 Gitee Pages 仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230001107308.png" alt="image-20201230001107308"></p>
<h3 id="3-发布"><a href="#3-发布" class="headerlink" title="3.  发布 ! ! !"></a>3.  发布 ! ! !</h3><p>从第一篇到现在这么多步骤过去了，可以说前面的所有操作都是在为最后的这一步<code>发布</code>做准备，现在终于到了见证奇迹的时刻了。</p>
<p>先别着急激动，让我们完成最最后一步配置，我们需要告诉 hexo 发布到哪里去，也就是把文件上传到哪个仓库。</p>
<p>打开博客<code>根目录配置文件</code>(<code>D:\MyBlog\_config.yaml</code>)，拉到文件最后一行，修改为下面的配置（没有的配置项自行添加），保存。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其中 xxxxxx 是前面多次用到的你的GitHub用户名，注意是master分支</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@gitee.com:xxxxxx/xxxxxx.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>OK，现在万事俱备了，执行下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意最后变成d了，原来的s表示服务起在本地，现在的d表示部署在远端</span></span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>待命令执行完毕，还记得<strong>Gitee上提交后需要手动部署</strong>吗？此时需要按照<code>3. 测试  Gitee Pages 页面</code>的方法更新部署。</p>
<p>打开浏览器，输入网址<code>https://你的用户名.gitee.io</code>，可以看到一个和第一篇中本地部署的一模一样的博客出现了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210102003427597.png" alt="image-20210102003427597"></p>
<p>之前为了测试而发布的文章也在。<code>https://你的用户名.gitee.io</code>就是你的个人博客地址了，其他人都可以访问。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20210102003454287.png" alt="image-20210102003454287"></p>
<h2 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h2><p>至此，我们从零开始搭建一个博客的任务初步完成了。</p>
<p>本篇文章介绍了利用 Gitee Pages 发布个人博客的方法，如果觉得 Gitee 每次发布博客需要手动更新太麻烦，可以参考上一篇文章，基于 Github Pages 搭建博客站点。</p>
<p>我看到许多人的博客搭建好了，一直停留在一开始初始化的状态，没有新增过一篇文章，希望大家别把最重要事情忘了，我们搭网站是为了写博客，一定要坚持下去。工欲善其事，必先利其器，接下来第四篇文章，介绍怎么更方便地写 Markdown 格式的博客。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始免费搭建自己的博客(二)——基于 GitHub pages 建站</title>
    <url>/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%8C)%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%20GitHub%20pages%20%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>​    本文是博客搭建系列文章第二篇，其他文章链接：</p>
<ol>
<li>从零开始免费搭建自己的博客(一)——<a href="https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80-%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/">本地搭建 Hexo 框架</a></li>
<li><strong>从零开始免费搭建自己的博客(二)——<a href="https://yushuaigee.gitee.io/2021/01/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-GitHub-pages-%E5%BB%BA%E7%AB%99/">基于 GitHub pages 建站</a></strong></li>
<li>从零开始免费搭建自己的博客(三)——<a href="https://yushuaigee.gitee.io/2021/01/02/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89-%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E-Gitee-pages-%E5%BB%BA%E7%AB%99/">基于 Gitee pages 建站</a></li>
<li>从零开始免费搭建自己的博客(四)——<a href="https://yushuaigee.gitee.io/2021/01/11/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E5%9B%9B)%E2%80%94%E2%80%94%E7%BC%96%E5%86%99Markdown%E6%96%87%E7%AB%A0%E5%88%A9%E5%99%A8%20Typora/">编写Markdown文章利器 Typora</a></li>
<li>从零开始免费搭建自己的博客(五)——<a href="https://yushuaigee.gitee.io/2021/01/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%BA%94)%E2%80%94%E2%80%94Typora%20+%20PicGo%20+%20GitHub%20Gitee%E5%9B%BE%E5%BA%8A/">Typora + PicGo + GitHub/Gitee图床</a></li>
<li>从零开始免费搭建自己的博客(六)——三个站点一键发布博客</li>
<li>从零开始免费搭建自己的博客(七)——迁移 CSDN 博客到个人博客站点</li>
<li>从零开始免费搭建自己的博客(八)——博客网站个性化设置及优化</li>
</ol>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第一篇文章里，我们利用 Hexo 框架在本地搭建了一个精美的博客，可是只能本地访问，要想发布到互联网上，还需要将它部署在网站上。</p>
<p>博客的功能只要能阅读文章就够了，因此可以考虑将其部署在提供静态网页托管服务的网站上，这样就省去了购买服务器(云主机)，购买域名，购买大网 IP 这些步骤，不仅省钱，更重要的是省事儿。</p>
<p>当前云计算如此流行，许多平台都提供了静态网页托管服务，其中最方便的当然是 GitHub Pages，只需要注册一个账号就可以使用。GitHub Pages的服务器毕竟在国外，如果觉得访问太慢，也可以选择国内功能相似的 Gitee Pages。</p>
<p>本篇文章介绍怎样利用 GitHub 提供的免费静态网页托管服务 GitHub Pages 建站。</p>
<h2 id="一、-GitHub-Pages-简介"><a href="#一、-GitHub-Pages-简介" class="headerlink" title="一、 GitHub Pages 简介"></a>一、 GitHub Pages 简介</h2><p>GitHub 是世界上最流行的软件源代码托管服务平台，为什么要提供网页托管服务呢？</p>
<p>这是因为一个项目的主页如果只有源码，对新接触的人很不友好，不知从何处下手。虽然已经有了 readme.md 文件，但毕竟不如一个直观的网页来的直接。于是 GitHub 就设计了 Pages 功能，允许用户设计一个图文并茂的网页作为项目首页。</p>
<p>虽然 GitHub Pages 的初衷是提供自定义的项目首页，但是它的玩法不止这一个。因此许多博主都用这个功能来搭建自己的博客，因为它实在是太太方便了。</p>
<p>去GitHub Pages 官网 <a href="https://pages.github.com/">pages.github</a> ，拉到最后，可以看到官方也推荐使用 GitHub Pages 搭建博客，并且提供了示例教程。</p>
<h2 id="二、GitHub-Pages-准备"><a href="#二、GitHub-Pages-准备" class="headerlink" title="二、GitHub Pages 准备"></a>二、GitHub Pages 准备</h2><p>在发布之前，要先准备好自己的GitHub Pages 。</p>
<h3 id="1-注册-GitHub-账号"><a href="#1-注册-GitHub-账号" class="headerlink" title="1. 注册 GitHub 账号"></a>1. 注册 GitHub 账号</h3><p>首先需要注册一个 GitHub 账号，如果已经有账号直接看下一步。</p>
<p>打开 GitHub 官网：<a href="https://github.com/">github.com</a>。如果这里打开速度已经不容忍受了，建议直接看下一篇使用 Gitee 建站。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229223941265.png" alt="image-20201229223941265"></p>
<p>点击右上角<kbd>Sign up</kbd>注册，填写用户名，邮箱，密码。注意，此处用户名是唯一ID，建议取个有意义的名字。点击注册后会发送一封验证邮件到填写的邮箱，登录自己的邮箱点击链接进行验证，GitHub 账号就注册好了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224251159.png" alt="image-20201229224251159"></p>
<h3 id="2-创建-GitHub-Pages-仓库"><a href="#2-创建-GitHub-Pages-仓库" class="headerlink" title="2. 创建 GitHub Pages 仓库"></a>2. 创建 GitHub Pages 仓库</h3><p>点击右上角<kbd>Sign in</kbd>登录后，点击左上角<kbd>New</kbd>新建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224505117.png" alt="image-20201229224505117"></p>
<p>由于每个 GitHub 账户只能建立一个 GitHub Pages 页面，所以 Repository name 必须填<code>&lt;你的用户名&gt;.github.io</code>，否则就会建立一个普通仓库，GitHub Pages 功能不会生效。比如用户名是<code>jacksparrow</code>，Repository name 这里就填<code>jacksparrow.github.io</code>，不知道用户名是哪个，可以点击页面右上角头像，看到第一行“Signed in as <code>xxx</code>”字样， <code>xxx</code>即为这里的用户名。</p>
<p>Description 填写仓库描述，比如 <code>jacksparrow&#39;s blog</code>等，可不填。</p>
<p>注意勾选 <code>Public</code> ，否则 GitHub Pages 功能不会生效。建议勾选 <code>Add a README file</code>，会自动生成一个 <code>readme.md</code>文件。</p>
<p>最后点击<kbd>Create repository</kbd>创建仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224741804.png" alt="image-20201229224741804"></p>
<h3 id="3-测试-GitHub-Pages-页面"><a href="#3-测试-GitHub-Pages-页面" class="headerlink" title="3. 测试  GitHub Pages 页面"></a>3. 测试  GitHub Pages 页面</h3><p>创建 GitHub Pages 仓库后，为了测试能否访问 GitHub Pages 服务，我们给它添加一个静态网页。</p>
<p>点击<kbd>Add file</kbd> – <kbd>Create new file</kbd>在仓库下新建文件。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225208056.png" alt="image-20201229225208056"></p>
<p>输入文件名<code>index.html</code>，在下面输入内容<code>&lt;h1&gt;Hello My Blog!&lt;/h1&gt;</code>，这是 html 标记语言，表示一级标题。</p>
<p>其他保持默认，点击最下面<kbd>Commit new file</kbd>提交文件到仓库。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225639083.png" alt="image-20201229225639083"></p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225731351.png" alt="image-20201229225731351"></p>
<p>然后在浏览器打开一个新的网页，输入网址<code>https://&lt;你的用户名&gt;.github.io</code>，就可以看见我们刚创建的网页，其中的内容就是刚才写的内容。说明 GitHub Pages 服务已经正常。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229230057034.png" alt="image-20201229230057034"></p>
<h2 id="三、GitHub-Pages-发布"><a href="#三、GitHub-Pages-发布" class="headerlink" title="三、GitHub Pages 发布"></a>三、GitHub Pages 发布</h2><p>上一步 “测试  GitHub Pages 页面” 中，我们在 GitHub Pages 仓库目录下新建了一个<code>index.html</code>，就可以在自己的专属网址看到这个网页了。同理我们把自己的博客生成静态 html 网页，提交到这个仓库目录下，就可以在我们的网址看到博客页面了，这就是 Hexo 框架部署博客的原理。当然，对于 Hexo 来说，提交部署只需要几条命令。</p>
<h3 id="1-配置-Git-参数"><a href="#1-配置-Git-参数" class="headerlink" title="1. 配置 Git 参数"></a>1. 配置 Git 参数</h3><p>在博客根目录下，右键，打开<kbd>Git Bash Here</kbd>。</p>
<p>配置用户名和邮箱，这两个参数用于 Git 提交时的身份识别。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中 username 和 username@XXX.com 是你注册 GitHub 的用户名和邮箱</span></span><br><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233907818.png" alt="image-20201229233907818"></p>
<p>生成 SSH keys，主要用于Git 提交时的权限控制和加密，本地根据 RSA 算法生成公私密钥对，然后将公钥添加到 GitHub 上，本机就可以提交代码到自己的 GitHub 库了。这个是根据当前使用的电脑的一些信息生成的，所以换电脑提交时要重新生成并添加。</p>
<p>输入下面命令，然后一直按<kbd>回车</kbd>，直到结束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中 username@XXX.com 是你注册 GitHub 的邮箱</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;username@XXX.com&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233801498.png" alt="image-20201229233801498"></p>
<p>输入下面的命令，查看公钥内容，应该是一个<code>ssh-rsa</code>开头，以<code>你的邮箱</code>结尾的长字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat后面的路径就是上图中的公钥文件路径，直接复制过来就可以</span></span><br><span class="line">cat /c/Users/XXX/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229234452012.png" alt="image-20201229234452012"></p>
<p>复制公钥内容（其实在<kbd>Git Bash</kbd>命令行里，默认选中文字松开鼠标就会自动把选中内容复制到剪贴板，默认鼠标中键是粘贴）。</p>
<p>打开自己的 Github 主页，点击右上角的头像，点击<kbd>Settings</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235035462.png" alt="image-20201229235035462"></p>
<p>点击<kbd>SSH and GPG keys</kbd>，然后点击<kbd>New SSH keys</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235220955.png" alt="image-20201229235220955"></p>
<p>Title 可以随便起一个名字，Key 填写上一步复制的公钥内容，然后点击<kbd>Add SSH key</kbd>。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235704322.png" alt="image-20201229235704322"></p>
<p>最后执行下面的命令，测试一下 Git 参数是否配置成功。出现<code>你的用户名</code>和<code>successfully</code>字样，说明配置成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下面的命令什么都不用改</span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230000424483.png" alt="image-20201230000424483"></p>
<h3 id="2-安装-Hexo-发布插件"><a href="#2-安装-Hexo-发布插件" class="headerlink" title="2. 安装 Hexo 发布插件"></a>2. 安装 Hexo 发布插件</h3><p>在博客根目录下，右键，打开<kbd>Git Bash Here</kbd>。</p>
<p>输入下面的命令，安装<code>hexo-deployer-git</code>。（安装失败或者卡住，参考第一篇文章修改 npm 源。）</p>
<p>这个插件用于把生成好的静态页面上传到 GitHub Pages 仓库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230001107308.png" alt="image-20201230001107308"></p>
<h3 id="3-发布"><a href="#3-发布" class="headerlink" title="3.  发布 ! ! !"></a>3.  发布 ! ! !</h3><p>从第一篇到现在这么多步骤过去了，可以说前面的所有操作都是在为最后的这一步<code>发布</code>做准备，现在终于到了见证奇迹的时刻了。</p>
<p>先别着急激动，让我们完成最最后一步配置，我们需要告诉 hexo 发布到哪里去，也就是把文件上传到哪个仓库。</p>
<p>打开博客<code>根目录配置文件</code>(<code>D:\MyBlog\_config.yaml</code>)，拉到文件最后一行，修改为下面的配置（没有的配置项自行添加），保存。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其中 xxxxxx 是前面多次用到的你的GitHub用户名</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xxxxxx/xxxxxx.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<p>OK，现在万事俱备了，执行下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意最后变成d了，原来的s表示服务起在本地，现在的d表示部署在远端</span></span><br><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>待命令执行完毕，打开浏览器，输入网址<code>https://你的用户名.github.io</code>，可以看到一个和第一篇中本地部署的一模一样的博客出现了。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230002849289.png" alt="image-20201230002849289"></p>
<p>之前为了测试而发布的文章也在。<code>https://你的用户名.github.io</code>就是你的个人博客地址了，其他人都可以访问。</p>
<p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201230003033418.png" alt="image-20201230003033418"></p>
<h2 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h2><p>至此，我们从零开始搭建一个博客的任务初步完成了。</p>
<p>本篇文章介绍了利用 GitHub Pages 发布个人博客的方法，如果觉得 GitHub 访问速度太慢，可以参考下面一篇文章，基于 Gitee Pages 搭建国内博客站点。如果觉得 GitHub Pages 很满意了，可以关注本系列后续文章，会继续介绍怎么更方便地写博客、老博客迁移到新站点以及主题个性化设置等内容。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>实用软件推荐(一)——自动更换壁纸 (Dynamic theme)</title>
    <url>/2020/08/23/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90(%E4%B8%80)%E2%80%94%E2%80%94%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E5%A3%81%E7%BA%B8%20(Dynamic%20theme)/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/107904698">https://blog.csdn.net/yushuaigee/article/details/107904698</a></p>
</blockquote>
<p>我对自己的电脑整洁要求比较高，安装的软件都要精挑细选，每次都要去找几个同类功能的软件下载下来，比较一番，最终留下最合适的一个。如果没有一个满足要求的又必须使用这个软件功能，那就装完用一下赶紧卸载，所以最后电脑上剩下的软件都是“精品”，哈哈(●´∀｀●)。平时逛网站看到一些比较强大、方便、有意思的软件，即使暂时用不到我也会收藏起来，积累了一大批实用工具，前段时间趁着换硬盘迁移数据的机会，我又把这些软件筛选了一下，把一些过时的、有更好的替代品的软件都删掉了。现在我就把这些“宝藏”分享一下。</p>
<p>我自己选择软件，有几个原则，优先级由高到低：</p>
<ul>
<li> 功能满足。肯定肯定要满足需要的功能，不然下载它干啥 </li>
<li> 界面美观。软件的界面一定要让人看着舒服，但是也不能花里胡哨。 </li>
<li> 功能简洁。我不喜欢一个软件塞很多根本用不到的功能，看见就很烦，破坏简洁美。 </li>
<li> 最好开源。这个原因是一般开源软件都会满足上面三个条件，而且比较好获取，直接去下载就行了。 </li>
<li> 绿色免安装。绿色软件解压即用，免去纠结安装在哪个盘，要不要检查开机启动之类的烦恼。 </li>
</ul>
<p><strong>Dynamic theme</strong></p>
<p>今天推荐的第一款软件 Dynamic theme，每天自动更新桌面壁纸，壁纸源可以选Windows聚焦和Bing每日壁纸。微软Bing搜索的首页每天会更新一张非常漂亮图片，相信很多人看到都会有把这些图片设为桌面壁纸的冲动，这款软件就满足了这个功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823174716788.png" alt="20200823174716788.png"></p>
<p>Dynamic theme的界面非常简洁，模仿Win10的风格，用起来感觉是系统自带的设置一样。</p>
<p><strong>图标：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823175437664.png" alt="20200823175437664.png"></p>
<p><strong>主界面：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823175419211.png" alt="20200823175419211.png"></p>
<p>默认是从Bing首页下载壁纸，可以点击切换。点击“查看历史”，可以查看最近更新的壁纸。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823192343810.gif" alt="20200823192343810.gif"></p>
<p>它不仅能自动换桌面壁纸，也可以换锁屏界面和windows动态磁贴的背景。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823182101938.png" alt="20200823182101938.png"></p>
<p>有些图片可能太美了想收藏到电脑里，这里可以设置每日壁纸自动保存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823182343564.png" alt="20200823182343564.png"></p>
<p>软件安装打开后默认会开机启动，但是除了每天桌面壁纸会自动更换之外，你不会有任何感觉，系统托盘也不会出现图标。如果不想使用，可以直接卸载。如果不想卸载，可以到windows设置里把它的“后台应用”权限关闭。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823184026498.png" alt="20200823184026498.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823184102552.png" alt="20200823184102552.png"></p>
<h3 id="下载方法"><a href="#下载方法" class="headerlink" title="下载方法"></a>下载方法</h3><p>Win10或Win8系统，下载方法非常简单，直接在应用商店搜索Dynamic theme下载安装即可，软件一共就100多k，即使微软商店很慢也不用等很久。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823182924271.png" alt="20200823182924271.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200823183354895.png" alt="20200823183354895.png"></p>
<h3 id="WinDynamicDesktop"><a href="#WinDynamicDesktop" class="headerlink" title="WinDynamicDesktop"></a>WinDynamicDesktop</h3><p>如果是Win7用户，可以试试这款功能类似的开源软件 WinDynamicDesktop，它是模仿macOS的动态桌面，可以根据时间变化动态调整桌面壁纸，让我们的桌面壁纸跟随一天从早到晚的时间变化呈现不同的视觉效果。这个软件比 Dynamic theme 强大，不过设置也更复杂，我还是推荐上面说的 Dynamic theme。</p>
<p>软件发布地址：<a href="https://github.com/t1m0thyj/WinDynamicDesktop/releases">https://github.com/t1m0thyj/WinDynamicDesktop/releases</a></p>
<p>源码地址：<a href="https://github.com/t1m0thyj/WinDynamicDesktop">https://github.com/t1m0thyj/WinDynamicDesktop</a></p>
<p>因为我是Win10，这个我没有亲测过，截图是在网上找的，详细介绍看这篇 <a href="https://sspai.com/post/59458">WinDynamicDesktop：让 Windows 10 拥有随时间变化的动态壁纸</a>。</p>
<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc3NwYWkuY29tLzIwMjAvMDMvMTMvNDczMjY3MTRiN2JmYmQyMzRmNDFkYjc0YzlhMWFmM2EucG5n?x-oss-process=image/format,png">

<img alt="" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc3NwYWkuY29tLzIwMjAvMDMvMTMvY2IzZDE5MDJjYTM0NWE0NWI4M2ZlYzEwZWJiMDIyYzgucG5n?x-oss-process=image/format,png">
]]></content>
      <categories>
        <category>软件推荐</category>
      </categories>
  </entry>
  <entry>
    <title>彻底弄懂 Linux 下的文件描述符（fd）</title>
    <url>/2020/08/14/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Linux%20%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88fd%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/107883964">https://blog.csdn.net/yushuaigee/article/details/107883964</a></p>
</blockquote>
<p><strong>目录</strong></p>
<p><a href="#1%E3%80%81%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BE%8B%E5%AD%90%E8%AF%B4%E8%B5%B7">1、从一个最常见的例子说起</a></p>
<p><a href="#2%E3%80%81Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%88file%20descriptor%EF%BC%89">2、Linux中的文件描述符（file descriptor）</a></p>
<p><a href="#3%E3%80%81Linux%E4%B8%8A%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B8%BE%E4%BE%8B">3、Linux上打开文件举例</a></p>
<p><a href="#4%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8">4、C语言中文件描述符的使用</a></p>
<p><a href="#5%E3%80%81Python%E4%B8%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8">5、Python中文件描述符的使用</a></p>
<p><a href="#6%E3%80%81Linux%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AA%E6%95%B0">6、Linux配置系统最大打开文件描述符个数</a></p>
<p><a href="#7%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">7、参考链接</a></p>
<h3 id="1、从一个最常见的例子说起"><a href="#1、从一个最常见的例子说起" class="headerlink" title="1、从一个最常见的例子说起"></a>1、从一个最常见的例子说起</h3><p>在使用Linux的过程中， 我们平时经常看到下面这样的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">5、Python中文件描述符的使用&lt;/h3&gt; </span><br><span class="line">Python中通过 sys 模块封装了标准输入、标准输出和错误输出。通过我们平时常用的内建函数 <span class="built_in">open</span> 可以获取一个文件的文件描述符，首先创建一个 test.py 文件用于打开，然后创建一个 test2.py 文件，输入下面代码保存。 执行，发现新打开文件的文件描述符是**<span class="number">3</span>**。 </span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import sys</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;stdin fd = &#x27;</span>, sys.stdin.fileno())</span><br><span class="line">print(<span class="string">&#x27;stdout fd = &#x27;</span>, sys.stdout.fileno())</span><br><span class="line">print(<span class="string">&#x27;stderr fd = &#x27;</span>, sys.stderr.fileno())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.py&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">&#x27;test.py fd = &#x27;</span>, f.fileno())</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;fcntl.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;unistd.h&amp;gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;test.py&quot;</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test.py fd = %d \n&quot;</span>, fd);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）</li>
<li>打开文件时的标识（open()的flags参数）</li>
<li>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）</li>
<li>与信号驱动相关的设置</li>
<li>对该文件i-node对象的引用，即i-node 表指针<h3 id="5、Python中文件描述符的使用"><a href="#5、Python中文件描述符的使用" class="headerlink" title="5、Python中文件描述符的使用"></a>5、Python中文件描述符的使用</h3></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200814153527763.png" alt="20200814153527763.png"></p>
<h3 id="6、Linux配置系统最大打开文件描述符个数"><a href="#6、Linux配置系统最大打开文件描述符个数" class="headerlink" title="6、Linux配置系统最大打开文件描述符个数"></a>6、Linux配置系统最大打开文件描述符个数</h3><p><strong>（1）系统级限制</strong></p>
<p>理论上系统内存有多少就可以打开多少的文件描述符，但是在实际中内核是会做相应的处理，一般最大打开文件数会是系统内存的10%（以KB来计算），称之为系统级限制。这个数字可以通过 <strong>cat /proc/sys/fs/file-max **或者 **sysctl -a | grep fs.file-max</strong> 命令查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200814163652926.png" alt="20200814163652926.png"></p>
<p>更改系统级限制有临时更改和永久更改两种方式：</p>
<ul>
<li> 临时更改：session断开或者系统重启后会恢复原来的设置值。使用命令 <strong>sysctl -w fs.file-max=xxxx</strong>，其中xxxx就是要设置的数字。 </li>
<li> 永久更改：vim编辑 <strong>/etc/sysctl.conf **文件，在后面添加 **fs.file-max=xxxx</strong>，其中xxxx就是要设置的数字。保存退出后还要使用<strong>sysctl -p</strong> 命令使其生效。 </li>
</ul>
<p><strong>（2）用户级限制</strong></p>
<p>同时为了控制每个进程消耗的文件资源，内核也会对单个进程最大打开文件数做默认限制，即用户级限制。32位系统默认值一般是1024，64位系统默认值一般是65535，可以使用 <strong>ulimit -n</strong> 命令查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200814164901907.png" alt="20200814164901907.png"></p>
<p>更改用户级限制也有临时更改和永久更改两种方式：</p>
<ul>
<li> 临时更改：session断开或者系统重启后会恢复原来的设置值。使用命令 <strong>ulimit -SHn xxxx</strong> 命令来修改，其中xxxx就是要设置的数字。 </li>
<li> 永久更改：vim编辑 <strong>/etc/security/limits.conf**</strong> <strong>文件，修改其中的 **hard nofile xxxx</strong> 和 <strong>soft nofile xxxx</strong>，其中xxxx就是要设置的数字。保存后退出。关于hard和soft的区别，参照下面参考链接中的第5个。 <h3 id="7、参考链接"><a href="#7、参考链接" class="headerlink" title="7、参考链接"></a>7、参考链接</h3></li>
</ul>
<ol>
<li><a href="https://blog.csdn.net/cywosp/article/details/38965239">每天进步一点点——Linux中的文件描述符与打开文件之间的关系——cywosp</a>1. <a href="http://c.biancheng.net/view/3066.html">Linux文件描述符到底是什么？——C语言中文网</a>1. <a href="https://www.jianshu.com/p/0ff9ff1d108e">句柄和文件描述符（FD）——阳光丶不锈</a>1. <a href="https://juejin.im/post/6844903962043236365#heading-0">带你破案：文件描述符到底是什么？——vran</a>1. <a href="http://www.ideabuffer.cn/2016/11/20/Linux%E9%85%8D%E7%BD%AE%E8%B0%83%E4%BC%98%EF%BC%9A%E6%9C%80%E5%A4%A7%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%AA%E6%95%B0/">Linux配置调优：最大打开文件描述符个数——Idea Buffer</a>1. <a href="https://blog.csdn.net/BlueguyChui/article/details/5676059">修改Linux系统下的最大文件描述符限制——BlueguyChui</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂 Python3中入参里的*号的作用</title>
    <url>/2020/07/25/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Python3%E4%B8%AD%E5%85%A5%E5%8F%82%E9%87%8C%E7%9A%84%20%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/107567001">https://blog.csdn.net/yushuaigee/article/details/107567001</a></p>
</blockquote>
<p><strong>目录</strong></p>
<p><a href="#Python3%E4%B8%AD%E5%87%A0%E7%A7%8D%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A">Python3中几种传递参数的方式：</a></p>
<p><a href="#1.%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">1.位置参数</a></p>
<p><a href="#2.%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">2.默认参数</a></p>
<p><a href="#3.%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">3.关键字参数</a></p>
<p><a href="#4.%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">4.可变参数</a></p>
<p><a href="#5.keyword-only%E5%8F%82%E6%95%B0">5.keyword-only参数</a></p>
<p><a href="#6.%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">6.参考链接</a></p>
<p>我们在看代码时，除了能看到普通的定义函数的入参写法，比如 <strong>def func(param1, param2):</strong> ，可能也会看到入参用 <em>args, **kwargs 来代替的写法，比如 **def func(*args, *</em>kwargs):*<em>，此外还有一种写法，比如 **def func(param1, <em>, param2):</em></em>，中间多了一个单纯的星号，这个用法又是什么意思呢？先从Python中的几种传递参数的方式说起。</p>
<h3 id="Python3中几种传递参数的方式："><a href="#Python3中几种传递参数的方式：" class="headerlink" title="Python3中几种传递参数的方式："></a>Python3中几种传递参数的方式：</h3><p><strong>位置参数、默认参数、关键字参数、可变参数</strong>(包括可变位置参数，可变关键字参数)<strong>、keyword-only参数</strong>(命名关键字参数)</p>
<h3 id="1-位置参数"><a href="#1-位置参数" class="headerlink" title="1.位置参数"></a>1.位置参数</h3><p>位置参数是最普通、最常见的传参方式，位置参数必须按照先后顺序传入，传入的参数和定义时的参数，一一对应，例如下面的“1”传给了param1，“2”传给了param2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">param1, param2</span>):</span></span><br><span class="line">    print(<span class="string">&quot;param1:&quot;</span>, param1)</span><br><span class="line">    print(<span class="string">&quot;param2:&quot;</span>, param2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># param1: 1</span></span><br><span class="line"><span class="comment"># param2: 2</span></span><br></pre></td></tr></table></figure>
<h3 id="2-默认参数"><a href="#2-默认参数" class="headerlink" title="2.默认参数"></a>2.默认参数</h3><p>默认参数也比较常见，函数定义时给某个参数设置默认值，调用函数时如果不传这个参数，就使用默认值，如果传了就用传入值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">param1, param2=<span class="number">1</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;param1:&quot;</span>, param1)</span><br><span class="line">    print(<span class="string">&quot;param2:&quot;</span>, param2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;未传入默认参数时&quot;</span>)</span><br><span class="line">    func(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;传入默认参数时&quot;</span>)</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 未传入默认参数时</span></span><br><span class="line"><span class="comment"># param1: 1</span></span><br><span class="line"><span class="comment"># param2: 1</span></span><br><span class="line"><span class="comment"># 传入默认参数时</span></span><br><span class="line"><span class="comment"># param1: 1</span></span><br><span class="line"><span class="comment"># param2: 2</span></span><br></pre></td></tr></table></figure>
<p>但是这里要注意，定义函数时如果同时有位置参数和默认参数，默认参数一定要在普通参数的后面，否则会报错如。这是Python语法规定，其实也很好理解，如果不规定顺序，像下面这个函数 <strong>def func(param1, param2=1, param3): ，</strong>如果传入2个参数，**func(1, 2)**，这个“2”是传给param2的还是param3的会有歧义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200725192042437.png" alt="20200725192042437.png"></p>
<p>使用默认参数还有一个需要注意的地方，默认参数的默认值尽量使用不可变对象，**param2=1、param2=”txt”**这种，否则会引起意想不到的问题。关于不可变对象可以参考：<a href="https://blog.csdn.net/yushuaigee/article/details/96745994#%E4%BA%8C%E3%80%81Python%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">Python中的不可变对象和可变对象</a></p>
<h3 id="3-关键字参数"><a href="#3-关键字参数" class="headerlink" title="3.关键字参数"></a>3.关键字参数</h3><p>关键字参数其实不能单独算作一类参数，是Python中比较方便的一个传参方式。就是在调用函数时，指定将哪个实参传给哪个形参，当然指定的形参名字必须是函数定义时所用的名字。其实普通的位置参数、默认参数、可变参数、keyword-only参数都可以用关键字参数的方式传参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b,  c=<span class="number">3</span>, d=<span class="number">4</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">    print(<span class="string">&quot;b:&quot;</span>, b)</span><br><span class="line">    print(<span class="string">&quot;c:&quot;</span>, c)</span><br><span class="line">    print(<span class="string">&quot;d:&quot;</span>, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">4</span>, c=<span class="number">3</span>)</span><br><span class="line">    func(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line">    func(d=<span class="number">4</span>, c=<span class="number">3</span>, b=<span class="number">2</span>, a=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出都是:</span></span><br><span class="line"><span class="comment"># a: 1</span></span><br><span class="line"><span class="comment"># b: 2</span></span><br><span class="line"><span class="comment"># c: 3</span></span><br><span class="line"><span class="comment"># d: 4</span></span><br></pre></td></tr></table></figure>
<h3 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.<strong>可变</strong>参数</h3><p>可变参数也叫动态参数，在Python标准库中见到的比较多。使用可变参数传入的参数的个数是动态的，可以是1个、2个到任意个，还可以是0个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    print(<span class="string">&quot;type of args: &quot;</span>, <span class="built_in">type</span>(args))</span><br><span class="line">    print(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    print(<span class="string">&quot;type of kwargs: &quot;</span>, <span class="built_in">type</span>(kwargs))</span><br><span class="line">    print(<span class="string">&quot;kwargs:&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, a=<span class="number">3</span>, b=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># type of args:  &amp;lt;class &#x27;tuple&#x27;&amp;gt;</span></span><br><span class="line"><span class="comment"># args: (1, 2)</span></span><br><span class="line"><span class="comment"># type of kwargs:  &amp;lt;class &#x27;dict&#x27;&amp;gt;</span></span><br><span class="line"><span class="comment"># kwargs: &#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到动态参数分两种，一个是<em>开头，例如</em>args，另一个是<strong>开头，例如</strong>kwargs。其中args和kwargs完全可以像其他参数一样自己命名，只是约定俗成的用*args和**kwargs，使用这两个IDE也会自动联想补全。args的类型是元组，调用函数时可以传入任意多的参数，这些参数会自动封装到args里，成为一个元组。kwargs的类型是字典，调用函数时可以传入任意多的自定义键值对参数，这些参数会自动封装到kwargs里，成为一个字典。</p>
<p>用<em>args，**kwargs组合的方式理论上可以传入任意值，许多标准库代码都是这样写的，</em>args必须写在**kwargs前面。但是我觉得如果真的所有函数入参都这样写，代码看起来会比较难懂，还是尽量不用这种方法。</p>
<p>那么在函数里面args和<em>args，kwargs、</em>kwargs、*<em>kwargs有什么区别呢？可以试一下对比看看，下图中可以看出，</em>号在这里只是一个标识作用，是给解释器看的，相当于把元组和字典的键的内容取出来，不用太纠结这个，就是一种规定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200725195231373.png" alt="20200725195231373.png"></p>
<p>同样可变参数位置参数和默认参数使用时也要注意顺序：位置参数、默认参数或*args、**kwargs。也就是说下面这两种方式都是可以的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200725200127553.png" alt="20200725200127553.png"></p>
<h3 id="5-keyword-only参数"><a href="#5-keyword-only参数" class="headerlink" title="5.keyword-only参数"></a>5.keyword-only参数</h3><p>keyword-only参数是Python3中新加入的特性，比较不多见。</p>
<p>定义时有一个单独的<em>号，其实这也只是一种规定，</em>号看上去像是一个参数，其实它不占参数个数，是给解释器看的。规定*号后面的参数，能且只能用key=value的方式传入，也就是上面第3步那种关键字参数传参形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, *, c=<span class="number">3</span>, d=<span class="number">4</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;a:&quot;</span>, a)</span><br><span class="line">    print(<span class="string">&quot;b:&quot;</span>, b)</span><br><span class="line">    print(<span class="string">&quot;c:&quot;</span>, c)</span><br><span class="line">    print(<span class="string">&quot;d:&quot;</span>, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># a: 1</span></span><br><span class="line"><span class="comment"># b: 2</span></span><br><span class="line"><span class="comment"># c: 3</span></span><br><span class="line"><span class="comment"># d: 4</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数如果没有单独的星号，我们可以** func(1, 2, 3, 4), func(1, 2, c=3, 4), func(1, 2, c=3, d=4)<strong>这样调用，而有了这个星号标识，就只能用 **func(1, 2, c=3, d=4)</strong> 这种方式调用。</p>
<h3 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6.参考链接"></a>6.参考链接</h3><p><a href="https://www.liujiangblog.com/course/python/31">Python参数类型——刘江</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python中的GIL锁</title>
    <url>/2019/08/04/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E4%B8%AD%E7%9A%84GIL%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/86537474">https://blog.csdn.net/yushuaigee/article/details/86537474</a></p>
</blockquote>
<p>刚学习python时，我关注了许多介绍python的公众号，也经常会在头条和知乎上收到关于python的文章的推送。在这些文章的评论区中，我经常会看到这样的说法：“Python是垃圾语言，先把GIL解决再说吧”，“又在吹Python，GIL不解决我永远不用Python”。刚开始，我也没去关注。后来Python用的越来越多，我不禁纳闷儿，我没感觉到GIL锁在使用python过程中有什么影响啊，事实上我根本感受不到它的存在，怎么会有这么多人因为GIL对python做出如此极端的评价？于是我决定研究一下GIL，看看这些人究竟是因为将Python的性能发挥到了极限，还是因为他们是一些Python的误(wu)解(nao)者(pen)。</p>
<h3 id="一、初识GIL"><a href="#一、初识GIL" class="headerlink" title="一、初识GIL"></a>一、初识GIL</h3><p>GIL，全称 Global Interpreter Lock ，全局解释锁。下面是<a href="https://wiki.python.org/moin/GlobalInterpreterLock">官方解释</a>中第一段：</p>
<blockquote>
<p> In CPython, the <strong>global interpreter lock</strong>, or <strong>GIL</strong>, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.) </p>
</blockquote>
<p>我在金山词霸的帮助下翻译一下： </p>
<blockquote>
<p> 在cpython中，gil是一个互斥锁，用来保护对python对象的访问，防止多个线程同时执行python字节码。这个锁是必要的，主要是因为cpython的内存管理不是线程安全的。(然而，由于GIL的存在，其他新增的特性，为了省事都在默认线程安全的前提下进行，导致GIL成了不可或缺的依赖。) </p>
</blockquote>
<p>就是说，GIL在多线程编程时才会起作用，你如果用不到多线程就不必关心这个问题了。在多线程编程时，为了防止多个线程同时操作一个变量时发生冲突，我们会设置一个互斥锁，只有获取到这个锁的线程才可以操作这个变量，这样就确保了同一时间只有一个线程操作这个变量，这样做虽然安全了，但是并行变串行影响了程序的效率。而GIL是Python解释器为了程序的稳定性，在解释多线程的程序时加一把全局解释锁，保证同一时刻只有一个线程在被解释，也是并行变串行，效率自然也就变低了。本来我用了多线程就是为了并行提高效率，可是Python解释器告诉我，不好意思在我这里只有串行，那也怪不得有这么多人会很生气。</p>
<p>不过要明确一点，GIL不是Python的特性，它是Python的C解释器在实现的时候引入的特性，不是说我们的Python代码写出来就自带了GIL，而是在执行时，CPython解释器在解释多线程程序时会受到GIL锁的影响。 </p>
<p>首先说什么是解释器，我们知道像Python这样的动态语言，是边解释边执行的。我们写的源代码在运行时要先被转换成字节码，然后再转换为机器码，CPU才能执行。这个源代码–&gt;字节码–&gt;机器码的过程，就是Python解释器帮我们完成的。其实和C语言这种静态语言程序写好之后的编译链接的过程差不多，不过C语言只需要一次，而python是每次执行都要来一遍。那什么是Python的C解释器呢？因为Python的解释器有很多种，用C语言实现的就叫做CPython。此外还有IPython，PyPy，Jython，IronPython等，这么多类型有啥区别，下篇博客再做研究。而使用最广泛的、我们绝大多数使用的都是CPython，因为我们从官网下载python自带的解释器就是CPython，这就是为什么大家都把GIL作为诟病Python的理由。</p>
<p>我在想，既然有的解释器不存在GIL，那它们的流行程度为什么没有超过CPyhon呢？我猜想有两种可能，一是GIL锁这个缺点影响并不大，二就是因为CPython有着其他解释器无法替代的更多优点。到底是哪一个？下面继续研究。</p>
<h3 id="二、引入GIL的原因"><a href="#二、引入GIL的原因" class="headerlink" title="二、引入GIL的原因"></a>二、引入GIL的原因</h3><p>为什么说GIL的产生是历史原因？因为多线程编程是随着多核CPU发展而发展的，而Python第一版出来的时候还是单核CPU的时代，所以都是在单核CPU的前提下设计的。任由Guido这样的神人也不会想到多核CPU会发展的如此之快，再说当时Python的产生也是个“意外”，Guido也不会想到他1989年为了打发圣诞节假期发明的一种编程语言需要好好设计一下多线程的部分，否则会影响2019年地球对面的程序员在使用这个语言做多线程编程的效率。</p>
<p>以下引用自<a href="https://www.cnblogs.com/SuKiWX/p/8804974.html">python中的GIL详解——背着吉他的王小可</a></p>
<blockquote>
<p> 为了利用多核，Python开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。 于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受了这种设定后，他们开始大量依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作）。<br> 慢慢的这种实现方式被发现是蛋疼且低效的。但当大家试图去拆分和去除GIL的时候，发现大量库代码开发者已经重度依赖GIL而非常难以去除了。有多难？做个类比，像MySQL这样的“小项目”为了把Buffer Pool Mutex这把大锁拆分成各个小锁也花了从5.5到5.6再到5.7多个大版为期近5年的时间，本且仍在继续。MySQL这个背后有公司支持且有固定开发团队的产品走的如此艰难，那又更何况Python这样核心开发和代码贡献者高度社区化的团队呢？<br> 所以简单的说GIL的存在更多的是历史原因。如果推到重来，多线程的问题依然还是要面对，但是至少会比目前GIL这种方式会更优雅。  </p>
</blockquote>
<h3 id="三、解决GIL？"><a href="#三、解决GIL？" class="headerlink" title="三、解决GIL？"></a>三、解决GIL？</h3><p>Python社区这么多大牛，不会没有人想过去解决这个问题，只是到现在没有找到比现有方案更加有效和优雅的方案。经过几天的查阅资料，我意识到GIL在某些情况下确实算作Python的一个缺陷，但仅仅是某些情况下，所以不能因为这个全盘而否定Python这门编程语言，事实上否定也没用了，因为它现在实在是太火了。</p>
<p>我认为我们要认清事情的本质，不要谈GIL色变。作为编程语言的使用者，我们先分析自己的需求。</p>
<p>首先，如果没有用到多线程编程，整个程序只需要串行执行，你完全不必在意GIL的存在，看看热闹就行了。</p>
<p>其次，用到了多线程编程，但是对并行（同时做不同事情）没有要求，只是对并发（交替做不同事情）有要求。例如设想这样一个场景：一个服务器接收端，需要时刻监听发送端发送的消息，进行不同的操作，如果所做的操作需要耗时较长，这时如果只有一个线程，去执行耗时较长的操作时，会造成监听下一条消息的阻塞，这时候我们可以启动一个子线程去执行耗时的操作，同时主线程又继续监听下一条消息。这个情况下，我们受到GIL锁的影响不大，完全可以接受。</p>
<p>再者，如果确实对并行要求比较高，那么Python还有用multiprocess（多进程）替代Thread可供选择。multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。</p>
<p>最后，你如果觉得无论如何Python也不能解决你的问题，它实在太影响程序的效率了，那么为什么不换一个语言呢，从来没有人说速度是Python的强项。编程语言只是一门工具，程序员才是工具的使用者，我们不能让工具限制人，而是要合理利用不同的工具来达到自己的目的。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>最后总结，我的两个问题也得到了答案，首先听到Python就喷GIL肯定是不对的。为什么其他解释器无法替代CPython的地位，既是因为GIL锁这个缺点影响并没有想像的那么大，也是因为CPython有着其他解释器无法替代的更多优点。GIL锁由于历史局限性而存在，作为一个效率方面的缺陷，它正在被积极的解决，但毫无疑问的是它还将继续长期存在。联想到最近香港的新闻，这使我想起了我们国家的“一国两制”和“搁置争议”，虽然看起来后面带来了一些难题，但是这不能改变这是当时最富有智慧的解决办法的事实。竟然和GIL的问题有些许的异曲同工之妙。。。</p>
<p>参考链接：</p>
<ul>
<li>1. GlobalInterpreterLock：<a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a></li>
<li>2. Inside the Python GIL (David Beazley)：<a href="http://www.dabeaz.com/python/GIL.pdf">http://www.dabeaz.com/python/GIL.pdf</a></li>
<li>3. Understanding the Python GIL (David Beazley)：<a href="http://www.dabeaz.com/python/UnderstandingGIL.pdf">http://www.dabeaz.com/python/UnderstandingGIL.pdf</a></li>
<li>4. python中的GIL详解 (背着吉他的王小可)：<a href="https://www.cnblogs.com/SuKiWX/p/8804974.html">https://www.cnblogs.com/SuKiWX/p/8804974.html</a></li>
<li>5. 聊聊Python中的GIL (青山牧云人)：<a href="https://www.cnblogs.com/ArsenalfanInECNU/p/9968621.html">https://www.cnblogs.com/ArsenalfanInECNU/p/9968621.html</a></li>
<li>6. Python简史 (Vamei)：<a href="https://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html">https://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gil</tag>
        <tag>GIL</tag>
        <tag>全局解释锁</tag>
        <tag>全局锁</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python标准库源码（零）—— 学习计划</title>
    <url>/2020/05/25/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%EF%BC%88%E9%9B%B6%EF%BC%89%E2%80%94%E2%80%94%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/106329590">https://blog.csdn.net/yushuaigee/article/details/106329590</a></p>
</blockquote>
<p>之前看到一张图，把各种编程语言比作不同的工具，非常形象生动。这里把Python比作电锯，简单粗暴，威力巨大，用起来得心应手。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200525220244606.png" alt="20200525220244606.png"></p>
<p>这张图片说明了编程语言只是一种工具，我们要善于根据不同的实际情况选择趁手的工具。但是作为一个Coder，要想达到更高的水平，不仅要把工具用起来得心应手，还要明白工具背后设计的原理。这样我们才能够深入地学习这些编程语言作者们的思想，先不说自己是否能成长为大神，至少可以更好地理解和使用这些编程语言吧。本着“知其然，还要知其所以然”的态度，我决定系统地学习一下Python的源码。</p>
<p>我暂且把学习计划分为三步：第一步，学习Python标准库源码，也就是Python自带模块中那些用纯Python实现的部分，源码文件在Lib目录下，参考这个<a href="https://docs.python.org/zh-cn/3/library/index.html">官方标准库文档</a>。第二步，学习Python内置模块源码和内置类型的实现源码，也就是Python自带模块中那些用C语言实现的部分，源码文件在Modules和Objects目录目录下，参考这个<a href="https://docs.python.org/zh-cn/3/py-modindex.html">官方模块索引</a>。第三步，学习Python解释器的实现源码，源码文件在Python目录下。</p>
<p>本次研究的是CPython的源码，使用当前最新版本Python3.8.3，源码在<a href="https://www.python.org/downloads/source/">这里</a>下载。考虑到自己的水平和时间，如果还没完成我的学习计划，Python就已经发布了新版本，那就换新版本研究吧，反正也不会有太大的区别，总之要紧跟时代潮流，hh。</p>
<p>《<a href="https://blog.csdn.net/yushuaigee/article/details/106329590">彻底弄懂Python标准库源码</a>》系列作为学习计划的第一部分，<strong>首先要明确学习目的和学习目标：通过阅读分析标准库的Python代码，学习Pythonic的风格和习惯，同时熟悉常用库的常用API （有需要的时候不用再百度），并了解一些不常用库的作用（有需要的时候能想到）。</strong></p>
<p>学习Python源码这个计划几个月前就在想了，奈何拖延症发作，希望这个博客系列以后可以做到每月更新一篇！</p>
<p> </p>
<h3 id="Python-源代码主要目录结构"><a href="#Python-源代码主要目录结构" class="headerlink" title="Python 源代码主要目录结构"></a>Python 源代码主要目录结构</h3><ul>
<li>Grammar。EBNF描述的语法规则在这个目录下。</li>
<li>Include。整个解释器所有的头文件放在这个目录下。</li>
<li>Lib。纯Python实现的标准库。</li>
<li>Modules。C实现的标准库。</li>
<li>Objects。所有的内置类型的实现。</li>
<li>Python。Python虚拟机的核心代码。
 </li>
</ul>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ol>
<li><a href="https://www.cnblogs.com/pluse/p/8667864.html">Python内置模块与标准库 - impluse</a> </li>
</ol>
<p>2. <a href="https://www.lightxue.com/python-internals-locate-source-code">Python源码寻宝记——地图篇 — 0xFEE1C001</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂python3中的回调函数</title>
    <url>/2019/03/01/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82python3%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/86313697">https://blog.csdn.net/yushuaigee/article/details/86313697</a></p>
</blockquote>
<p><strong>百度百科说：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</strong></p>
<p><strong>通俗理解就是：把一个函数作为参数传给另一个函数，第一个函数称为回调函数。</strong>这个被传入的参数其实是函数指针，即指向一个函数的指针（地址）。在python中，指针的概念被淡化，先举个c++的例子：</p>
<blockquote>
<p> 本段引用自  <a href="https://blog.csdn.net/qq_21210467/article/details/80706277">python 回调函数（Callback）——天涯海阁未走远</a><br> 编写一个计算函数computer，对于两个整数进行各种计算（通用的，什么计算都能做）。有一个形参是指向具体算法函数的指针，根据不同的实参函数，用不同的算法进行计算。<br> 编写三个函数：求两个整数的最大值，最小值，和。分别用这三个函数作为实参，测试computer函数。<br> 那么肯定有人会问，一个函数怎么可能做各种计算呢？——这个时候，我们在computer的形参中设置一个函数指针，每次调用的时候传递给它一个函数指针。<br> 用函数名去初始化形参函数指针。这样的话，我们写computer函数的时候就只管说我要调用一个对两个整数做运算的函数，至于要做什么运算，只需要把代表这个运算的函数名传给我，我用函数指针来接收，用函数指针充当函数名，去调用函数体。这就是函数指针的好处，也就是函数回调。<br> <pre class="has"><code class="language-cpp">#include&lt;iostream&gt;</p>
</blockquote>
<p>using namespace std;</p>
<p>int computer(int a, int b, int(*func)(int, int)) &#123;<br>    return func(a, b);<br>&#125;</p>
<p>int max(int a, int b) &#123;<br>    return (a &gt; b ? a : b);<br>&#125;</p>
<p>int min(int a, int b) &#123;<br>    return (a &gt; b ? b : a);<br>&#125;</p>
<p>int sum(int a, int b) &#123;<br>    return a + b;<br>&#125;</p>
<p>int main() &#123;<br>    int a, b, res;<br>    cout &lt;&lt; “请输入整数a：”; cin &gt;&gt; a;<br>    cout &lt;&lt; “请输入整数b：”; cin &gt;&gt; b;<br>    res = computer(a, b, &amp;max);<br>    cout &lt;&lt; “Max of “ &lt;&lt; a &lt;&lt; “ and “ &lt;&lt; b &lt;&lt; “ is “ &lt;&lt; res &lt;&lt; endl;<br>    res = computer(a, b, &amp;min);<br>    cout &lt;&lt; “Min of “ &lt;&lt; a &lt;&lt; “ and “ &lt;&lt; b &lt;&lt; “ is “ &lt;&lt; res &lt;&lt; endl;<br>    res = computer(a, b, &amp;sum);<br>    cout &lt;&lt; “Sum of “ &lt;&lt; a &lt;&lt; “ and “ &lt;&lt; b &lt;&lt; “ is “ &lt;&lt; res &lt;&lt; endl;<br>    return 0;<br>&#125;</code></pre><br> 结果：<br> <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20190301101204190.png" alt="20190301101204190.png"> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;/p&gt; </span><br><span class="line">类似上面，编写三个函数：求两个整数的最大值，最小值，和。分别用这三个函数作为实参，测试computer函数。在调用<span class="built_in">max</span>,<span class="built_in">min</span>,<span class="built_in">sum</span>时，这三个函数就是此处的回调函数。 </span><br><span class="line">&lt;pre class=&quot;has&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;def computer(a, b, func):</span><br><span class="line">    <span class="keyword">return</span> func(a, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [a, b][a &amp;lt; b]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [a, b][a &amp;gt; b]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(a) + <span class="built_in">int</span>(b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&quot;请输入整数a:&quot;</span>)</span><br><span class="line">    b = <span class="built_in">input</span>(<span class="string">&quot;请输入整数b:&quot;</span>)</span><br><span class="line">    res = computer(a, b, <span class="built_in">max</span>)</span><br><span class="line">    print(<span class="string">&quot;Max of &quot;</span> + a + <span class="string">&quot; and &quot;</span> + b + <span class="string">&quot; is &quot;</span> + res)</span><br><span class="line">    res = computer(a, b, <span class="built_in">min</span>)</span><br><span class="line">    print(<span class="string">&quot;Min of &quot;</span> + a + <span class="string">&quot; and &quot;</span> + b + <span class="string">&quot; is &quot;</span> + res)</span><br><span class="line">    res = computer(a, b, <span class="built_in">sum</span>)</span><br><span class="line">    print(<span class="string">&quot;Sum of &quot;</span> + a + <span class="string">&quot; and &quot;</span> + b + <span class="string">&quot; is &quot;</span> + res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20190301105100724.png" alt="20190301105100724.png"></p>
<blockquote>
<p> PS：一开始在测试上面python代码的时候，我没有加类型转换str()和int()，出现了输出 Sum of 5 and 12 is 512 的情况。看来python用起来是方便，但是编译器帮我们做了太多的事情，有时候会让我们忽略一些程序的本质，所以不能光学python啊，c++还是要多看看，有助于对程序本质的理解。 </p>
</blockquote>
<p>说白了，回调函数和普通函数在定义的时候没有什么区别，只有在调用时才看出来是不是回调函数，正常调用就是普通函数，作为一个函数的参数在需要的时候分情况调用，就是回调函数。</p>
<p>另外，回调函数还可以进行异步调用，即非阻塞调用，通常用在多线程或者多进程中。暂时没用到，先了解。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>回调函数</tag>
        <tag>Callback</tag>
      </tags>
  </entry>
  <entry>
    <title>我认识到了记录博客对于工作和学习的重要性</title>
    <url>/2018/12/24/%E6%88%91%E8%AE%A4%E8%AF%86%E5%88%B0%E4%BA%86%E8%AE%B0%E5%BD%95%E5%8D%9A%E5%AE%A2%E5%AF%B9%E4%BA%8E%E5%B7%A5%E4%BD%9C%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/85138684">https://blog.csdn.net/yushuaigee/article/details/85138684</a></p>
</blockquote>
<p><strong>我为什么要写博客？</strong></p>
<p>在学习和工作的过程中，不管是安装软件，还是配置环境，或者写代码的过程中，总会遇到很多问题。常规问题还好，跟着教程按步骤进行就行了。一旦遇到刁钻的问题，或者在教程里没有出现的错误，就很让人头大，而且更令人头疼的是感觉我们遇到的问题大多数都是刁钻的问题，很少有跟着教程一步一步顺利完成的。这时候就只能寄希望于各大搜索引擎了，经过不断更换关键字，废了九牛二虎之力，如果能解决问题，那还是很开心的，如果通过自己尝试解决了问题，那就更开心了。这时候如果能记录一下，以后有其他人遇到这种问题，看到你的博客就能够很快定位并解决。因为平时在别人的博客学到很多东西，许多博主的那种乐于助人的精神令我很佩服，我常常在想：如果自己有机会能将这份“赠人玫瑰，手有余香”的差事传递下去，那也算为这个代码世界里贡献了一份微薄的力量。</p>
<p>上面的原因只是其一，更重要的一个原因是，记录博客可以有利于自己的学习和成长。首先，学习一个新的知识，你感觉自己学会了其实不一定，只有你能给别人讲明白，才算真正掌握了。而写博客的过程，可以看做给别人讲解的过程。在写博客时，对新学习的知识做一个回顾和总结，也可以方便以后自己忘了的时候进行快速查阅。正所谓“学而时习之”。</p>
<p><strong>我为什么现在才开始写博客？</strong></p>
<p>说来惭愧，我在大学时就知道写博客有很多好处，也曾经听师兄说过坚持写博客是一件很有意义的事。但是由于自己的懒散，导致迟迟也没有开始。我在大四的时候曾经用有道云笔记记录自己学习python的笔记，当做一种回顾，很可惜后来老是感觉只是把人家的东西抄了一遍，从而中途中断了，后来也没有再看过那些笔记。在做毕设的时候，我那个课题是个那年老师新出的题目，遇到一个问题卡住了，当时找遍了各个网站，使用中文英文关键字进行搜索，大概花了一星期时间，终于在一篇英文博客里摘到了一些线索，然后自己尝试了一下搞定了。当时寻找解决办法的过程中就想着，等解决了，一定把解决方案写成一个博客，以方便自己和别人查询。可是搞定了之后离交论文就剩一星期时间了，当然没有立刻实行，然后……，等交完论文，光想着放松，更没有了提笔的动力。这件事不了了之，果不其然，现在毕业仅仅5个月时间，回想一下，只记得是关于AR和MFC的东西，然后记得当时很费劲，根本不记得具体细节。如果当时我能马上记录下来，是多么有意义的事情啊。</p>
<p><strong>为什么现在终于要开始了？</strong></p>
<p>7月2号参加工作，到现在有差不多6个月了。从一开始接触什么都是新鲜的东西，到现在感觉逐渐适应工作。有时候仔细想想，这看似忙忙碌碌的半年自己真正学到了什么？最大的感受就是，虽然感觉了解到了很多新东西，但是只是了解了一些皮毛而已，而且了解的新事物越多，越感到要学的东西更多，自己真的是一个小小的小菜鸟。看到那些工作一年多的老员工，就已经懂那么多，随便说起一个自己刚刚百度到的东西，他们竟然都能说出一堆关于这个的话题，这让我既佩服又羡慕，同时也反省自己，等我工作一年之后能达到那个水平吗？如果达不到，自己是不是也太弱了？回顾半年来的工作，我竟然不能思路清晰地列出所学到的东西，然后只能得出结论：没学到啥……。半年时间，说长也长，说短也短，人生又有几个半年呢？如果一直这样浑浑噩噩地混下去，没有什么提高，那就要注定过一个得过且过没有意义的人生。</p>
<p>我认识到了记录博客对于工作和学习的重要性。以后每学到一个东西或者解决一个难题，就记录成博客，即使是一条命令的用法，也可以当做笔记记下来，方便以后查阅和总结，同时也能够激励自己，万一有别人看到呢。我希望当我下一个半年，来回顾工作和学习时，可以打开自己的博客，总结一下这一段时间的成果，就不会感觉自己碌碌无为了。真的是想想都感觉美滋滋啊。</p>
<p>这就是我的第一篇博客了，万事开头难，总算开始了~~加油！</p>
<p> </p>
<p> </p>
]]></content>
      <categories>
        <category>感想随笔</category>
      </categories>
      <tags>
        <tag>个人感想</tag>
        <tag>写博客的意义</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式初探——六大设计原则</title>
    <url>/2020/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2%E2%80%94%E2%80%94%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/104543281">https://blog.csdn.net/yushuaigee/article/details/104543281</a></p>
</blockquote>
<p>最近看了两本关于设计模式的书，在此记录一下感想。</p>
<p>第一次听说设计模式是在网上查询MVC模式的时候，顺便搜了一下设计模式，才了解到武林中存在着“23种设计模式”这么个东西。当时以为觉得设计模式就是倚天剑、屠龙刀，一个代码写的很烂的菜鸟看了设计模式就会成为“武林至尊”，代码水平立刻变得很厉害。学习了之后才知道我想错了，设计模式只是倚天剑和屠龙刀中的“九阴真经”，就算得到了还是要苦苦练习，结合实际的编程和项目才能够把其中的思想融会贯通，真正成为一个编程高手。</p>
<p>“设计模式”是一套被反复利用、被多数人知晓的、被无数工程师实践的代码设计经验的总结。因为它比较抽象，没有一定编程经验很难读懂，更不能理解其精髓。23种设计模式总体看下来，有的当时就能理解，有的需要思考一番才能理解，就像以前不会的很难的那种数学题，看了答案，跟着答案的思路捋一捋就理解了，然后下次遇到类似的题稍微变一变又不会做了。这次初探设计模式也是一样，合上书之后自己写代码，很难想到该怎么将刚学到的设计模式用到自己代码中去，或许这就是经验太少的原因吧。</p>
<p>我最大的感受就是<strong>单一职责原则、开放封闭原则、依赖倒转原则、里氏代换原则、迪米特法则、接口隔离原则</strong>这六大设计原则比设计模式更加重要，如果说设计模式是面向对象编程的编程思想，那么设计原则就是这些编程思想的指导总纲，而这六大设计原则的目的又可以概括为六个字，就是<strong>“高内聚，低耦合”</strong>。（感觉看完书我就记住了这六个字）高内聚就是说，设计的接口内部功能要单一紧凑，不要想起什么都往里面塞，最后搞的非常臃肿，没有办法复用。然后低耦合是说，设计的接口之间的关联要尽量小，不要出现更改一个地方的时候牵一发而动全身，几十个地方都要跟着改，要不就没法用。说起来我们学习设计模式的最终目的就是要实现代码的最大化复用。</p>
<p>单一职责原则：一个类只负责一项功能或相似的功能，承担尽可能少的职责。这样可以增强可读性，方便维护和修改，当然缺点就是在小的项目里运用会显得拆分的太详细，类的数量会急剧增加。（然后就想着反正是小项目没必要考虑单一职责原则，然后后后来项目的功能越加越多，又变成了又臭又长的烂代码。。。）</p>
<p>开放封闭原则：类、模块、函数等对扩展开放，对修改封闭。增加一个功能时，应当尽可能的不去改动已有的代码，当修改一个模块时不应该影响到其他模块。（这个相信大家不能同意更多，因为谁也不想让原来跑的好好的代码经过自己的手之后，出现各种奇怪的问题，所以不会去想动以前的代码。问题是根据我的经验，由于“已有”的代码在设计的时候没有考虑“低耦合”，导致改动的时候牵一发而动全身，不得不去动已有的代码。。。）</p>
<p>里氏替换原则：所有能引用基类的地方必须能透明地使用其子类的对象。只要父类能出现的地方，就可以用子类来替换它，反之，子类能出现地方父类不一定能出现，因为子类拥有父类的所有属性和行为，但是子类拓展了更多的功能。子类重写父类方法的时候功能不能改动太多，功能实在差很多的话就不要重写了，应扩展一个新方法，这一点我做的很不好。</p>
<p>依赖倒置原则：高层模块不应该依赖低层模块，二者应该依赖其抽象。把具有相同特征或相似功能的类，抽象成接口或者抽象类，让具体的实现类继承这个抽象类。抽象类（接口）负责定义统一的方法，实现类负责具体功能的实现。</p>
<p>接口隔离原则：用多个细粒度的接口来代替由多个方法组成的复杂接口，每一个接口服务于一个子模块，不要试图建立一个很庞大的接口供所有依赖它的类调用。这其实还是强调“高内聚”的事儿。</p>
<p>迪米特原则：一个对象应该对其他对象有最少的了解。对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系。这其实还是强调“低耦合”的事儿。</p>
<p>设计模式在编程中的作用，就像《孙子兵法》在战争中的作用。设计模式是前辈们归纳总结出来的指导思想，对设计模式的运用不能纸上谈兵，丰富的项目经验是很重要的。不同的阶段来看看这些理论，会有不同的收获。这次只是初探，随着以后的代码写的越来越多，还要随时注意学习和运用这些设计模式。</p>
]]></content>
      <categories>
        <category>感想随笔</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python标准库源码（一）—— os模块</title>
    <url>/2020/06/15/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20os%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/106755148">https://blog.csdn.net/yushuaigee/article/details/106755148</a></p>
</blockquote>
<p><strong>目录</strong></p>
<p><a href="#%E7%AC%AC1~22%E8%A1%8C%20%E6%A8%A1%E5%9D%97%E6%95%B4%E4%BD%93%E6%B3%A8%E9%87%8A%E3%80%81nt%E4%B8%8Eposix">第1~22行 模块整体注释、nt与posix</a></p>
<p><a href="#%E7%AC%AC24~46%E8%A1%8C%20%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E3%80%81_exists%E6%96%B9%E6%B3%95%E3%80%81_get_exports_list%E6%96%B9%E6%B3%95">第24~46行 模块引入、_exists方法、_get_exports_list方法</a></p>
<p><a href="#%E7%AC%AC48~97%E8%A1%8C%20%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%90%8C%E5%AF%BC%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7">第48~97行 根据系统不同导入不同的方法和属性</a></p>
<p><a href="#%E7%AC%AC100~185%E8%A1%8C%20?%5B1%5D">第100~185行 ?[1]</a></p>
<p><a href="#%E7%AC%AC188~193%E8%A1%8C%C2%A0%E5%AE%9A%E4%B9%89%E4%B8%89%E4%B8%AA%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F">第188~193行 定义三个枚举变量</a></p>
<p><a href="#%E7%AC%AC195~228%E8%A1%8C%20makedirs%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95">第195~228行 makedirs——创建多级目录</a></p>
<p><a href="#%E7%AC%AC230~250%E8%A1%8C%20removedirs%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95">第230~250行 removedirs——删除多级目录</a></p>
<p><a href="#%E7%AC%AC252~278%E8%A1%8C%20renames%E2%80%94%E2%80%94%E9%87%8D%E5%91%BD%E5%90%8D%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6">第252~278行 renames——重命名目录或文件</a></p>
<p><a href="#%E7%AC%AC280~421%E8%A1%8C%20walk%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E6%A0%91%E7%94%9F%E6%88%90%E5%99%A8">第280~421行 walk——目录树生成器</a></p>
<p><a href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%E2%80%A6%E2%80%A6">未完待续……</a></p>
<p>os模块包含了一些与操作系统相关的函数接口，而且它是支持跨平台的，它封装了 nt.py(windows) 和 posix.py (类Unix)两个模块的接口，而后面两个模块是由C语言实现的、直接和系统交互的底层接口。也就是说os模块能够处理平台间的差异问题，使得编写好的程序无需做任何改动就能在不同的平台上运行。如果想要查看os模块的所有内容，可以使用<code>dir(os)</code>方法查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200529172306851.png" alt="20200529172306851.png"></p>
<p>可以看到os模块中有这么多属性和方法，这些都是可以通过“os.”访问的。因为os模块是使用纯Python实现的标准库，所以在Python安装目录中也可以找到os模块的源码。打开Python安装目录下 \Lib\os.py 文件，或者源码目录下 \Lib\os.py 文件，就可以查看os模块的源码了。整个代码看下来，os.py 主要是将底层接口进行了一层封装，不知道其他标准库是不是也是这样。</p>
<p>以下标题中的行数是与我所用的3.8.4版本os.py文件真实的行数对应的，而分析文字部分所说的行数，是对应截取的代码段的行数，这样比较方便看。</p>
<h3 id="第1-22行-模块整体注释、nt与posix"><a href="#第1-22行-模块整体注释、nt与posix" class="headerlink" title="第1~22行 模块整体注释、nt与posix"></a>第1~22行 模块整体注释、nt与posix</h3><p>首先是第1行到第22行，这是一段整个模块的注释。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;/pre&gt; </span><br><span class="line">这段代码的意思看懂了，但是没有明白它的作用。将一些 globals 里和 _have_functions 同时出现的方法名加到 一个set里，并重新赋值给supports_dir_fd、supports_effective_ids、supports_fd、supports_follow_symlinks四个集合。但是只有supports_dir_fd和supports_fd在后面的代码中用到了，另外两个集合整个代码里都没有用过，不知道是什么作用，先跳过，保留疑问[<span class="number">1</span>]。 </span><br><span class="line">&lt;h3 id=&quot;%E7%AC%AC188~193%E8%A1%8C%C2%A0%E5%AE%9A%E4%B9%89%E4%B8%89%E4%B8%AA%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F&quot;&gt;第188~193行 定义三个枚举变量&lt;/h3&gt; </span><br><span class="line">&lt;pre&gt;&lt;code class=<span class="string">&quot;language-python&quot;</span>&gt;# Python uses fixed values <span class="keyword">for</span> the SEEK_ constants; they are mapped</span><br><span class="line"># to native constants <span class="keyword">if</span> necessary in posixmodule.c</span><br><span class="line"># Other possible SEEK values are directly imported from posixmodule.c</span><br><span class="line">SEEK_SET = <span class="number">0</span></span><br><span class="line">SEEK_CUR = <span class="number">1</span></span><br><span class="line">SEEK_END = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r&quot;&quot;&quot;OS routines for NT or Posix depending on what system we&#x27;re on.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This exports:</span></span><br><span class="line"><span class="string">  - all functions from posix or nt, e.g. unlink, stat, etc.</span></span><br><span class="line"><span class="string">  - os.path is either posixpath or ntpath</span></span><br><span class="line"><span class="string">  - os.name is either &#x27;posix&#x27; or &#x27;nt&#x27;</span></span><br><span class="line"><span class="string">  - os.curdir is a string representing the current directory (always &#x27;.&#x27;)</span></span><br><span class="line"><span class="string">  - os.pardir is a string representing the parent directory (always &#x27;..&#x27;)</span></span><br><span class="line"><span class="string">  - os.sep is the (or a most common) pathname separator (&#x27;/&#x27; or &#x27;\\&#x27;)</span></span><br><span class="line"><span class="string">  - os.extsep is the extension separator (always &#x27;.&#x27;)</span></span><br><span class="line"><span class="string">  - os.altsep is the alternate pathname separator (None or &#x27;/&#x27;)</span></span><br><span class="line"><span class="string">  - os.pathsep is the component separator used in $PATH etc</span></span><br><span class="line"><span class="string">  - os.linesep is the line separator in text files (&#x27;\r&#x27; or &#x27;\n&#x27; or &#x27;\r\n&#x27;)</span></span><br><span class="line"><span class="string">  - os.defpath is the default search path for executables</span></span><br><span class="line"><span class="string">  - os.devnull is the file path of the null device (&#x27;/dev/null&#x27;, etc.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Programs that import and use &#x27;os&#x27; stand a better chance of being</span></span><br><span class="line"><span class="string">portable between different platforms.  Of course, they must then</span></span><br><span class="line"><span class="string">only use functions that are defined by all platforms (e.g., unlink</span></span><br><span class="line"><span class="string">and opendir), and leave all pathname manipulation to os.path</span></span><br><span class="line"><span class="string">(e.g., split and join).</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">第<span class="number">3</span>行引入sys模块，这是一个C实现的内置模块，主要是实现Python解释器、操作系统相关的操作。 </span><br><span class="line">第<span class="number">4</span>行引入stat模块，这个模块主要实现文件状态检查之类的操作，也属于一个标准库，在os这里只是用到了 st.S_ISDIR 这个方法，判断是否是目录。 </span><br><span class="line">第<span class="number">6</span>行引入_collections_abc模块的_check_methods方法，这个模块是用于集合的抽象基类，也属于一个标准库，_check_methods用来判断一个对象是否含有某个属性。 </span><br><span class="line">第<span class="number">8</span>行 sys.builtin_module_names 返回一个包含内建模块名字的元组，包含所有已经编译到Python解释器的模块名字。这里就可以解释os模块怎么根据‘nt’和‘posix’两个字符串实现区分不同系统的：Window系统的Python会安装nt模块，这个返回的元组中就会包含‘nt’，而其他系统的Python在安装时不安装nt模块，而是安装posix模块，这个返回的元组中就会包含‘posix’。 </span><br><span class="line">下面一行是一个注释，提示：更多的名称会在后面慢慢加入到__all__中。 </span><br><span class="line">第<span class="number">11</span>行，__all__ 是针对模块公开接口的一种约定，以提供了”白名单“的形式暴露接口。如果定义了__all__，其他文件中使用from xxx <span class="keyword">import</span> *导入该文件时，只会导入 __all__ 列出的成员，其他成员都被排除在外。若没定义，则导入模块内的所有公有属性/方法和类 。因为只是一种约定，就像用__前缀表示私有成员一样，它只对<span class="keyword">import</span> `*`起作用，对from xxx <span class="keyword">import</span> xxx不起作用。  </span><br><span class="line">下面定义了_exists方法，用于通过名字获得全局变量中的对象。其中global()方法是解释器内置方法，不需要导入就可以直接用，会以字典类型返回当前位置的全部全局变量。类似的还有locals()方法，后者以字典类型返回当前位置的局部变量。 </span><br><span class="line">再下面是_get_exports_list方法，这个了解了上面的__all__就很好理解，就是通过模块名获得对应模块对外暴露的接口，如果该模块没有定义__all__，即发生了AttributeError，就返回模块所有接口里面不是以_前缀开头的接口。可以看出这是在遵守约定。 </span><br><span class="line">&lt;h3 id=&quot;%E7%AC%AC48~97%E8%A1%8C%20%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%90%8C%E5%AF%BC%E5%85%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7&quot;&gt;第48~97行 根据系统不同导入不同的方法和属性&lt;/h3&gt; </span><br><span class="line">&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Any new dependencies of the os module and/or changes in path separator</span><br><span class="line"># requires updating importlib as well.</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;posix&#x27;</span> in _names:</span><br><span class="line">    name = <span class="string">&#x27;posix&#x27;</span></span><br><span class="line">    linesep = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    from posix <span class="keyword">import</span> *</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        from posix <span class="keyword">import</span> _exit</span><br><span class="line">        __all__.append(<span class="string">&#x27;_exit&#x27;</span>)</span><br><span class="line">    except ImportError:</span><br><span class="line">        pass</span><br><span class="line">    <span class="keyword">import</span> posixpath as path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        from posix <span class="keyword">import</span> _have_functions</span><br><span class="line">    except ImportError:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> posix</span><br><span class="line">    __all__.extend(_get_exports_list(posix))</span><br><span class="line">    del posix</span><br><span class="line"></span><br><span class="line">elif <span class="string">&#x27;nt&#x27;</span> in _names:</span><br><span class="line">    name = <span class="string">&#x27;nt&#x27;</span></span><br><span class="line">    linesep = <span class="string">&#x27;\r\n&#x27;</span></span><br><span class="line">    from nt <span class="keyword">import</span> *</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        from nt <span class="keyword">import</span> _exit</span><br><span class="line">        __all__.append(<span class="string">&#x27;_exit&#x27;</span>)</span><br><span class="line">    except ImportError:</span><br><span class="line">        pass</span><br><span class="line">    <span class="keyword">import</span> ntpath as path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> nt</span><br><span class="line">    __all__.extend(_get_exports_list(nt))</span><br><span class="line">    del nt</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        from nt <span class="keyword">import</span> _have_functions</span><br><span class="line">    except ImportError:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="function">raise <span class="title">ImportError</span><span class="params">(<span class="string">&#x27;no os specific module found&#x27;</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">sys.modules[&#x27;os.path&#x27;] </span>= path</span><br><span class="line">from os.<span class="function">path <span class="title">import</span> <span class="params">(curdir, pardir, sep, pathsep, defpath, extsep, altsep,</span></span></span><br><span class="line"><span class="function"><span class="params">    devnull)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">del _names</span></span><br></pre></td></tr></table></figure>
<h3 id="第188-193行-定义三个枚举变量"><a href="#第188-193行-定义三个枚举变量" class="headerlink" title="第188~193行 定义三个枚举变量"></a>第188~193行 定义三个枚举变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python uses fixed values for the SEEK_ constants; they are mapped</span></span><br><span class="line"><span class="comment"># to native constants if necessary in posixmodule.c</span></span><br><span class="line"><span class="comment"># Other possible SEEK values are directly imported from posixmodule.c</span></span><br><span class="line">SEEK_SET = <span class="number">0</span></span><br><span class="line">SEEK_CUR = <span class="number">1</span></span><br><span class="line">SEEK_END = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>注释的意思是: Python对SEEK_常量使用固定值，如果需要，它们在 posixmodule.c 中被映射到本机常量。其他可能的SEEK_常量值直接从posixmodule.c 导入。</p>
<p>这三个常量一般用作fseek函数的一个入参。fseek函数是C语言中用于二进制方式打开的文件时，移动文件读写指针位置。原型是int fseek(FILE *stream, long offset, int fromwhere);  第一个参数stream为文件指针第，第二个参数offset为偏移量，整数表示正向偏移，负数表示负向偏移， 第三个参数设定从文件的哪里开始偏移,可能取值为：SEEK_SET： 文件开头；SEEK_CUR： 当前位置；EEK_END： 文件结尾。这三个变量我觉得不用深究，鉴于模块开头的 <strong>all</strong> 里也加入了这三个变量名，应该是在模块外面调用别的函数的时候作为入参使用的，这里定义一下可以起到枚举的作用。</p>
<h3 id="第195-228行-makedirs——创建多级目录"><a href="#第195-228行-makedirs——创建多级目录" class="headerlink" title="第195~228行 makedirs——创建多级目录"></a>第195~228行 makedirs——创建多级目录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;/pre&gt; </span><br><span class="line">注释是说: 创建必要的目录，并删除所有空的。类似于重命名，不同的是本函数会首先尝试创建使新路径名有效所需的中间目录。在重命名之后，与旧名称最右边路径段对应的目录将被删除，直到把旧的路径都删完或找到一个非空目录。注意:如果您缺乏断开子目录或文件链接所需的权限，那么在创建新目录结构时，此函数可能会失败。 </span><br><span class="line">还是直接看代码好理解一点，第<span class="number">16</span>~<span class="number">18</span>行，先判断新目录的倒数第二层路径是否存在，如果不存在就创建。所以这个函数不仅支持<span class="string">&quot;D:/ttt/eee/ --&amp;gt; D:/ttt/sss&quot;</span> 这种只改最后一层子目录的形式，也支持 <span class="string">&quot;D:/ttt/eee/ --&amp;gt; D:/111/222&quot;</span> 这种同时重命名多级目录的形式，要不说是超级版本呢。只是要注意，不管哪种形式，原来的目录为空的话会被删除，所以这个函数不能用于新建目录，新建目录还是用makedirs吧。  </span><br><span class="line">下面还是调用 <span class="string">&quot;nt&quot;</span>或<span class="string">&quot;posix&quot;</span>里的方法，进行重命名，前面已经把新目录的上一层目录创建好了。再后面就是删除旧路径的过程，从最底层的目录开始，一层一层删过去，出现异常忽略。可以看出好多你自以为优雅的写法，只是标准库帮你把异常报错pass了而已。 </span><br><span class="line">最后把刚定义的三个函数加入到__all__里，前面说过__all__会不断进行扩充。 </span><br><span class="line">&lt;h3 id=&quot;%E7%AC%AC280~421%E8%A1%8C%20walk%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E6%A0%91%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;第280~421行 walk——目录树生成器&lt;/h3&gt; </span><br><span class="line">&lt;pre&gt;&lt;code class=<span class="string">&quot;language-python&quot;</span>&gt;def walk(top, topdown=True, onerror=None, followlinks=False):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Directory tree generator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For each directory in the directory tree rooted at top (including top</span></span><br><span class="line"><span class="string">    itself, but excluding &#x27;.&#x27; and &#x27;..&#x27;), yields a 3-tuple</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        dirpath, dirnames, filenames</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    dirpath is a string, the path to the directory.  dirnames is a list of</span></span><br><span class="line"><span class="string">    the names of the subdirectories in dirpath (excluding &#x27;.&#x27; and &#x27;..&#x27;).</span></span><br><span class="line"><span class="string">    filenames is a list of the names of the non-directory files in dirpath.</span></span><br><span class="line"><span class="string">    Note that the names in the lists are just names, with no path components.</span></span><br><span class="line"><span class="string">    To get a full path (which begins with top) to a file or directory in</span></span><br><span class="line"><span class="string">    dirpath, do os.path.join(dirpath, name).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If optional arg &#x27;topdown&#x27; is true or not specified, the triple for a</span></span><br><span class="line"><span class="string">    directory is generated before the triples for any of its subdirectories</span></span><br><span class="line"><span class="string">    (directories are generated top down).  If topdown is false, the triple</span></span><br><span class="line"><span class="string">    for a directory is generated after the triples for all of its</span></span><br><span class="line"><span class="string">    subdirectories (directories are generated bottom up).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When topdown is true, the caller can modify the dirnames list in-place</span></span><br><span class="line"><span class="string">    (e.g., via del or slice assignment), and walk will only recurse into the</span></span><br><span class="line"><span class="string">    subdirectories whose names remain in dirnames; this can be used to prune the</span></span><br><span class="line"><span class="string">    search, or to impose a specific order of visiting.  Modifying dirnames when</span></span><br><span class="line"><span class="string">    topdown is false has no effect on the behavior of os.walk(), since the</span></span><br><span class="line"><span class="string">    directories in dirnames have already been generated by the time dirnames</span></span><br><span class="line"><span class="string">    itself is generated. No matter the value of topdown, the list of</span></span><br><span class="line"><span class="string">    subdirectories is retrieved before the tuples for the directory and its</span></span><br><span class="line"><span class="string">    subdirectories are generated.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    By default errors from the os.scandir() call are ignored.  If</span></span><br><span class="line"><span class="string">    optional arg &#x27;onerror&#x27; is specified, it should be a function; it</span></span><br><span class="line"><span class="string">    will be called with one argument, an OSError instance.  It can</span></span><br><span class="line"><span class="string">    report the error to continue with the walk, or raise the exception</span></span><br><span class="line"><span class="string">    to abort the walk.  Note that the filename is available as the</span></span><br><span class="line"><span class="string">    filename attribute of the exception object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    By default, os.walk does not follow symbolic links to subdirectories on</span></span><br><span class="line"><span class="string">    systems that support them.  In order to get this functionality, set the</span></span><br><span class="line"><span class="string">    optional argument &#x27;followlinks&#x27; to true.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Caution:  if you pass a relative pathname for top, don&#x27;t change the</span></span><br><span class="line"><span class="string">    current working directory between resumptions of walk.  walk never</span></span><br><span class="line"><span class="string">    changes the current directory, and assumes that the client doesn&#x27;t</span></span><br><span class="line"><span class="string">    either.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    import os</span></span><br><span class="line"><span class="string">    from os.path import join, getsize</span></span><br><span class="line"><span class="string">    for root, dirs, files in os.walk(&#x27;python/Lib/email&#x27;):</span></span><br><span class="line"><span class="string">        print(root, &quot;</span>consumes<span class="string">&quot;, end=&quot;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">        print(sum(getsize(join(root, name)) for name in files), end=&quot;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">        print(&quot;</span>bytes in<span class="string">&quot;, len(files), &quot;</span>non-directory files<span class="string">&quot;)</span></span><br><span class="line"><span class="string">        if &#x27;CVS&#x27; in dirs:</span></span><br><span class="line"><span class="string">            dirs.remove(&#x27;CVS&#x27;)  # don&#x27;t visit CVS directories</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    top = fspath(top)</span><br><span class="line">    dirs = []</span><br><span class="line">    nondirs = []</span><br><span class="line">    walk_dirs = []</span><br><span class="line"></span><br><span class="line">    # We may not have read permission <span class="keyword">for</span> top, in which <span class="keyword">case</span> we can<span class="string">&#x27;t</span></span><br><span class="line"><span class="string">    # get a list of the files the directory contains.  os.walk</span></span><br><span class="line"><span class="string">    # always suppressed the exception then, rather than blow up for a</span></span><br><span class="line"><span class="string">    # minor reason when (say) a thousand readable directories are still</span></span><br><span class="line"><span class="string">    # left to visit.  That logic is copied here.</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        # Note that scandir is global in this module due</span></span><br><span class="line"><span class="string">        # to earlier import-*.</span></span><br><span class="line"><span class="string">        scandir_it = scandir(top)</span></span><br><span class="line"><span class="string">    except OSError as error:</span></span><br><span class="line"><span class="string">        if onerror is not None:</span></span><br><span class="line"><span class="string">            onerror(error)</span></span><br><span class="line"><span class="string">        return</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    with scandir_it:</span></span><br><span class="line"><span class="string">        while True:</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                try:</span></span><br><span class="line"><span class="string">                    entry = next(scandir_it)</span></span><br><span class="line"><span class="string">                except StopIteration:</span></span><br><span class="line"><span class="string">                    break</span></span><br><span class="line"><span class="string">            except OSError as error:</span></span><br><span class="line"><span class="string">                if onerror is not None:</span></span><br><span class="line"><span class="string">                    onerror(error)</span></span><br><span class="line"><span class="string">                return</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                is_dir = entry.is_dir()</span></span><br><span class="line"><span class="string">            except OSError:</span></span><br><span class="line"><span class="string">                # If is_dir() raises an OSError, consider that the entry is not</span></span><br><span class="line"><span class="string">                # a directory, same behaviour than os.path.isdir().</span></span><br><span class="line"><span class="string">                is_dir = False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            if is_dir:</span></span><br><span class="line"><span class="string">                dirs.append(entry.name)</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                nondirs.append(entry.name)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            if not topdown and is_dir:</span></span><br><span class="line"><span class="string">                # Bottom-up: recurse into sub-directory, but exclude symlinks to</span></span><br><span class="line"><span class="string">                # directories if followlinks is False</span></span><br><span class="line"><span class="string">                if followlinks:</span></span><br><span class="line"><span class="string">                    walk_into = True</span></span><br><span class="line"><span class="string">                else:</span></span><br><span class="line"><span class="string">                    try:</span></span><br><span class="line"><span class="string">                        is_symlink = entry.is_symlink()</span></span><br><span class="line"><span class="string">                    except OSError:</span></span><br><span class="line"><span class="string">                        # If is_symlink() raises an OSError, consider that the</span></span><br><span class="line"><span class="string">                        # entry is not a symbolic link, same behaviour than</span></span><br><span class="line"><span class="string">                        # os.path.islink().</span></span><br><span class="line"><span class="string">                        is_symlink = False</span></span><br><span class="line"><span class="string">                    walk_into = not is_symlink</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if walk_into:</span></span><br><span class="line"><span class="string">                    walk_dirs.append(entry.path)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # Yield before recursion if going top down</span></span><br><span class="line"><span class="string">    if topdown:</span></span><br><span class="line"><span class="string">        yield top, dirs, nondirs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # Recurse into sub-directories</span></span><br><span class="line"><span class="string">        islink, join = path.islink, path.join</span></span><br><span class="line"><span class="string">        for dirname in dirs:</span></span><br><span class="line"><span class="string">            new_path = join(top, dirname)</span></span><br><span class="line"><span class="string">            # Issue #23605: os.path.islink() is used instead of caching</span></span><br><span class="line"><span class="string">            # entry.is_symlink() result during the loop on os.scandir() because</span></span><br><span class="line"><span class="string">            # the caller can replace the directory entry during the &quot;yield&quot;</span></span><br><span class="line"><span class="string">            # above.</span></span><br><span class="line"><span class="string">            if followlinks or not islink(new_path):</span></span><br><span class="line"><span class="string">                yield from walk(new_path, topdown, onerror, followlinks)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        # Recurse into sub-directories</span></span><br><span class="line"><span class="string">        for new_path in walk_dirs:</span></span><br><span class="line"><span class="string">            yield from walk(new_path, topdown, onerror, followlinks)</span></span><br><span class="line"><span class="string">        # Yield after recursion if going bottom up</span></span><br><span class="line"><span class="string">        yield top, dirs, nondirs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__all__.append(&quot;walk&quot;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Super directory utilities.</span></span><br><span class="line"><span class="comment"># (Inspired by Eric Raymond; the doc strings are mostly his)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makedirs</span>(<span class="params">name, mode=<span class="number">0o777</span>, exist_ok=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;makedirs(name [, mode=0o777][, exist_ok=False])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Super-mkdir; create a leaf directory and all intermediate ones.  Works like</span></span><br><span class="line"><span class="string">    mkdir, except that any intermediate path segment (not just the rightmost)</span></span><br><span class="line"><span class="string">    will be created if it does not exist. If the target directory already</span></span><br><span class="line"><span class="string">    exists, raise an OSError if exist_ok is False. Otherwise no exception is</span></span><br><span class="line"><span class="string">    raised.  This is recursive.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    head, tail = path.split(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">        head, tail = path.split(head)</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">and</span> tail <span class="keyword">and</span> <span class="keyword">not</span> path.exists(head):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            makedirs(head, exist_ok=exist_ok)</span><br><span class="line">        <span class="keyword">except</span> FileExistsError:</span><br><span class="line">            <span class="comment"># Defeats race condition when another thread created the path</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        cdir = curdir</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(tail, <span class="built_in">bytes</span>):</span><br><span class="line">            cdir = <span class="built_in">bytes</span>(curdir, <span class="string">&#x27;ASCII&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tail == cdir:           <span class="comment"># xxx/newdir/. exists if xxx/newdir exists</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mkdir(name, mode)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="comment"># Cannot rely on checking for EEXIST, since the operating system</span></span><br><span class="line">        <span class="comment"># could give priority to other errors like EACCES or EROFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exist_ok <span class="keyword">or</span> <span class="keyword">not</span> path.isdir(name):</span><br><span class="line">            <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<h3 id="第252-278行-renames——重命名目录或文件"><a href="#第252-278行-renames——重命名目录或文件" class="headerlink" title="第252~278行 renames——重命名目录或文件"></a>第252~278行 renames——重命名目录或文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walk</span>(<span class="params">top, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Directory tree generator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For each directory in the directory tree rooted at top (including top</span></span><br><span class="line"><span class="string">    itself, but excluding &#x27;.&#x27; and &#x27;..&#x27;), yields a 3-tuple</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        dirpath, dirnames, filenames</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    dirpath is a string, the path to the directory.  dirnames is a list of</span></span><br><span class="line"><span class="string">    the names of the subdirectories in dirpath (excluding &#x27;.&#x27; and &#x27;..&#x27;).</span></span><br><span class="line"><span class="string">    filenames is a list of the names of the non-directory files in dirpath.</span></span><br><span class="line"><span class="string">    Note that the names in the lists are just names, with no path components.</span></span><br><span class="line"><span class="string">    To get a full path (which begins with top) to a file or directory in</span></span><br><span class="line"><span class="string">    dirpath, do os.path.join(dirpath, name).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If optional arg &#x27;topdown&#x27; is true or not specified, the triple for a</span></span><br><span class="line"><span class="string">    directory is generated before the triples for any of its subdirectories</span></span><br><span class="line"><span class="string">    (directories are generated top down).  If topdown is false, the triple</span></span><br><span class="line"><span class="string">    for a directory is generated after the triples for all of its</span></span><br><span class="line"><span class="string">    subdirectories (directories are generated bottom up).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When topdown is true, the caller can modify the dirnames list in-place</span></span><br><span class="line"><span class="string">    (e.g., via del or slice assignment), and walk will only recurse into the</span></span><br><span class="line"><span class="string">    subdirectories whose names remain in dirnames; this can be used to prune the</span></span><br><span class="line"><span class="string">    search, or to impose a specific order of visiting.  Modifying dirnames when</span></span><br><span class="line"><span class="string">    topdown is false has no effect on the behavior of os.walk(), since the</span></span><br><span class="line"><span class="string">    directories in dirnames have already been generated by the time dirnames</span></span><br><span class="line"><span class="string">    itself is generated. No matter the value of topdown, the list of</span></span><br><span class="line"><span class="string">    subdirectories is retrieved before the tuples for the directory and its</span></span><br><span class="line"><span class="string">    subdirectories are generated.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    By default errors from the os.scandir() call are ignored.  If</span></span><br><span class="line"><span class="string">    optional arg &#x27;onerror&#x27; is specified, it should be a function; it</span></span><br><span class="line"><span class="string">    will be called with one argument, an OSError instance.  It can</span></span><br><span class="line"><span class="string">    report the error to continue with the walk, or raise the exception</span></span><br><span class="line"><span class="string">    to abort the walk.  Note that the filename is available as the</span></span><br><span class="line"><span class="string">    filename attribute of the exception object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    By default, os.walk does not follow symbolic links to subdirectories on</span></span><br><span class="line"><span class="string">    systems that support them.  In order to get this functionality, set the</span></span><br><span class="line"><span class="string">    optional argument &#x27;followlinks&#x27; to true.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Caution:  if you pass a relative pathname for top, don&#x27;t change the</span></span><br><span class="line"><span class="string">    current working directory between resumptions of walk.  walk never</span></span><br><span class="line"><span class="string">    changes the current directory, and assumes that the client doesn&#x27;t</span></span><br><span class="line"><span class="string">    either.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    import os</span></span><br><span class="line"><span class="string">    from os.path import join, getsize</span></span><br><span class="line"><span class="string">    for root, dirs, files in os.walk(&#x27;python/Lib/email&#x27;):</span></span><br><span class="line"><span class="string">        print(root, &quot;consumes&quot;, end=&quot;&quot;)</span></span><br><span class="line"><span class="string">        print(sum(getsize(join(root, name)) for name in files), end=&quot;&quot;)</span></span><br><span class="line"><span class="string">        print(&quot;bytes in&quot;, len(files), &quot;non-directory files&quot;)</span></span><br><span class="line"><span class="string">        if &#x27;CVS&#x27; in dirs:</span></span><br><span class="line"><span class="string">            dirs.remove(&#x27;CVS&#x27;)  # don&#x27;t visit CVS directories</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    top = fspath(top)</span><br><span class="line">    dirs = []</span><br><span class="line">    nondirs = []</span><br><span class="line">    walk_dirs = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We may not have read permission for top, in which case we can&#x27;t</span></span><br><span class="line">    <span class="comment"># get a list of the files the directory contains.  os.walk</span></span><br><span class="line">    <span class="comment"># always suppressed the exception then, rather than blow up for a</span></span><br><span class="line">    <span class="comment"># minor reason when (say) a thousand readable directories are still</span></span><br><span class="line">    <span class="comment"># left to visit.  That logic is copied here.</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Note that scandir is global in this module due</span></span><br><span class="line">        <span class="comment"># to earlier import-*.</span></span><br><span class="line">        scandir_it = scandir(top)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">        <span class="keyword">if</span> onerror <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            onerror(error)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> scandir_it:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    entry = <span class="built_in">next</span>(scandir_it)</span><br><span class="line">                <span class="keyword">except</span> StopIteration:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">                <span class="keyword">if</span> onerror <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    onerror(error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                is_dir = entry.is_dir()</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="comment"># If is_dir() raises an OSError, consider that the entry is not</span></span><br><span class="line">                <span class="comment"># a directory, same behaviour than os.path.isdir().</span></span><br><span class="line">                is_dir = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> is_dir:</span><br><span class="line">                dirs.append(entry.name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nondirs.append(entry.name)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> topdown <span class="keyword">and</span> is_dir:</span><br><span class="line">                <span class="comment"># Bottom-up: recurse into sub-directory, but exclude symlinks to</span></span><br><span class="line">                <span class="comment"># directories if followlinks is False</span></span><br><span class="line">                <span class="keyword">if</span> followlinks:</span><br><span class="line">                    walk_into = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        is_symlink = entry.is_symlink()</span><br><span class="line">                    <span class="keyword">except</span> OSError:</span><br><span class="line">                        <span class="comment"># If is_symlink() raises an OSError, consider that the</span></span><br><span class="line">                        <span class="comment"># entry is not a symbolic link, same behaviour than</span></span><br><span class="line">                        <span class="comment"># os.path.islink().</span></span><br><span class="line">                        is_symlink = <span class="literal">False</span></span><br><span class="line">                    walk_into = <span class="keyword">not</span> is_symlink</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> walk_into:</span><br><span class="line">                    walk_dirs.append(entry.path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Yield before recursion if going top down</span></span><br><span class="line">    <span class="keyword">if</span> topdown:</span><br><span class="line">        <span class="keyword">yield</span> top, dirs, nondirs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recurse into sub-directories</span></span><br><span class="line">        islink, join = path.islink, path.join</span><br><span class="line">        <span class="keyword">for</span> dirname <span class="keyword">in</span> dirs:</span><br><span class="line">            new_path = join(top, dirname)</span><br><span class="line">            <span class="comment"># Issue #23605: os.path.islink() is used instead of caching</span></span><br><span class="line">            <span class="comment"># entry.is_symlink() result during the loop on os.scandir() because</span></span><br><span class="line">            <span class="comment"># the caller can replace the directory entry during the &quot;yield&quot;</span></span><br><span class="line">            <span class="comment"># above.</span></span><br><span class="line">            <span class="keyword">if</span> followlinks <span class="keyword">or</span> <span class="keyword">not</span> islink(new_path):</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> walk(new_path, topdown, onerror, followlinks)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Recurse into sub-directories</span></span><br><span class="line">        <span class="keyword">for</span> new_path <span class="keyword">in</span> walk_dirs:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> walk(new_path, topdown, onerror, followlinks)</span><br><span class="line">        <span class="comment"># Yield after recursion if going bottom up</span></span><br><span class="line">        <span class="keyword">yield</span> top, dirs, nondirs</span><br><span class="line"></span><br><span class="line">__all__.append(<span class="string">&quot;walk&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我觉得 walk 函数是这个模块看到现在最符合Python特点的方法，强大，方便，优雅。</p>
<p>首先一段很长的注释，主要介绍了出参和入参。该方法返回一个迭代器，包含一个三元元组，dirpath, dirnames, filenames。</p>
<p>dirpath 是当前遍历的目录的名字，从入参top开始(如果topdown为False的话)，字符串类型；</p>
<p>dirnames 是dirpath中的子目录的名字(路径名字)的列表，list类型；</p>
<p>filenames 是dirpath中的非目录的文件的名字(只有名字)的列表，list类型；</p>
<p>第一个入参 top 就是要遍历的文件夹，字符串类型。如果第二个可选入参 topdown 为 True 或未指定，目录是自顶向下生成的。如果 topdown 为 False ，则目录是自底向上生成的。举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前目录结构：</span></span><br><span class="line"><span class="comment"># ttt</span></span><br><span class="line"><span class="comment">#  ├── sss</span></span><br><span class="line"><span class="comment">#  ├    └──333.txt</span></span><br><span class="line"><span class="comment">#  ├── 111.txt</span></span><br><span class="line"><span class="comment">#  └── 222.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> os.walk(<span class="string">&#x27;ttt&#x27;</span>):</span><br><span class="line">    print(a, b, c)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># ttt [&#x27;sss&#x27;] [&#x27;111.txt&#x27;, &#x27;222.txt&#x27;]</span></span><br><span class="line"><span class="comment"># ttt\sss [] [&#x27;333.txt&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> os.walk(<span class="string">&#x27;ttt&#x27;</span>, topdown=<span class="literal">True</span>):</span><br><span class="line">    print(a, b, c)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># ttt\sss [] [&#x27;333.txt&#x27;].</span></span><br><span class="line"><span class="comment"># ttt [&#x27;sss&#x27;] [&#x27;111.txt&#x27;, &#x27;222.txt&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>第三个入参 onerror 是一个回调函数，默认情况下，onerror 参数未指定，此时调用 scandir 方法时，出现的错误将被忽略 (scandir 方法就是 nt 或 posix模块里的底层遍历目录的方法，这个内置方法只能遍历一层目录，所以像前面几个函数一样，walk 方法其实可以看做 scandir 方法的超级版本)。如果可选参数 onerror 被指定，它必须是一个包含一个入参的函数，因为后面的循环中如果出现OSError异常，会将OSError类型实例作为参数传给它。</p>
<p>默认情况下，walk方法不遵循符号链接跳转到它们指向的子目录。为了获得此功能，将可选参数 followlinks 设置为True。这里应该是说类似Linux系统的软连接硬连接那种，该参数用来选择是否迭代它们所指向的目录。我在Windows测试，快捷方式文件是不生效的，它会把快捷方式当成一个普通文件。</p>
<p>注意：如果为top传递的是相对路径名，不要在 walk 函数执行期间之间更改当前工作目录。walk 从不更改当前目录，并假设客户机也不更改当前目录。</p>
<p>看看代码部分：第60行将 top 参数传到 fspath 转换了一下，这个方法是在本模块后面1060行定义的，主要作用是判断传入的参数是不是字符串类型的目录名，如果不是，直接报错。fspath 实现细节后面再具体看。在一些其他语言比如C语言中，要调用一个方法和属性必须在调用出现之前进行定义，在Python这里对这个顺序要求不是很在意。</p>
<p>第61~63行，定义了三个列表，dirs用来存放遍历过程中的目录名，nondirs用来存放遍历过程中的文件的名字，walk_dirs 用来存放要遍历的子目录，用于后面继续迭代它们的子目录。</p>
<p>第65~69行注释，在没有top目录的读权限的情况下，无法获得目录中包含的文件列表。大部分情况下walk总是忽略一些异常，这样避免(比方说)在还有1000个可读目录需要访问时，因为一个小原因而崩溃。这个逻辑复制到这里。</p>
<p>第71~73行，这里是walk函数的核心部分，调用 scandir (nt或posix里的)，这个方法返回一个迭代器，包含入参目录下的所有DirEntry类型的子目录和文件，DirEntry是nt(或posix)模块定义的一个类，包含一个目录或文件的基本信息。这里将其返回的迭代器赋值给scandir_it。这里的注释是提醒scandir是在前面对 nt 模块或者 posix 模块 import * 时引入的。我怀疑os模块不是一个人完成的，因为上面几个函数在调用别的模块的方法时，就没有这种提示，还需要自己去找一些方法或属性的出处。</p>
<p>第74~77行，如果第一级目录再进行遍历的时候就出现了 OSError 类型的异常，就调用回调函数 onerror 方法处理(如果有定义的话)，然后直接返回。</p>
<p>79行开始进入循环。第81~89行取出迭代器 scandir_it 的下一个元素，也就是 top 目录下的第一个子目录或者文件，如果迭代器被迭代完了，就pass。这里同遇到异常，会和74到77行的处理方法一样。</p>
<p>第91~101行，判断取出的第一个元素是不是目录，is_dir 方法是DirEntry类型实例的一个方法。（还记得吗，73行scandir_it = scandir(top)返回的迭代器，里面包含的实例是DirEntry类型的，在83行entry = next(scandir_it)取出）。如果该元素是目录就加到列表 dirs 里，否则加到列表 nondirs 里。</p>
<p>此时，如果 topdown 为True 或未指定，循环体就执行完了。接下来继续遍历，直到把第一层目录下的子目录和文件都分类保存在两个列表里（这里应该想到后面肯定会有递归）。如果topdown 参数为False，而且当前元素是个目录(这里来看链接也算目录)，第103~119行，这里又要考虑followlinks参数，如果为True，就将当前元素的路径加入到列表 walk_dirs 里，如果为Flase或者未指定，当前元素是链接的话就不加入待迭代目录列表walk_dirs，不是链接(普通目录)就加入到walk_dirs。</p>
<p>第121~134行，如果是自顶向下生成的，这时候就可以 yield walk这个迭代器的第一个元素了。然后准备第二个元素(这么说可能不对) ：将 top 和 dirs 里的路径名字组合，形成新的路径名，在for循环中调用walk就完成第二层目录的迭代，这样递归下去就可以遍历到所有的子目录，递归的跳出点就在两个return那里。</p>
<p>第135~140行，如果是自底向上生成的，就先不yield，先去处理待迭代的列表里的路径，层层递归，这样就会先 yield 最低层目录，再 yield 上层的目录。</p>
<p>最后，将walk函数加入到__all__列表里。总的来说，walk这个函数利用Python的迭代器，设计的很巧妙，都看完了让我写也写不出来。</p>
<h3 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a><strong>未完待续……</strong></h3><p>今天写了一下午不知道为啥没保存上，晚上回来打开进度又回到上次写的那里，一下午白干了，刚刚才又凭着记忆重写回来，感觉有的地方跟第一遍用词不一样了。</p>
<p>os模块源码共1115行，到现在才写到421行，这篇文章已经太长了，我决定分成两篇文章，后续写在<a href="https://blog.csdn.net/yushuaigee/article/details/108492310">彻底弄懂Python标准库源码（二）—— os模块（续）</a>里。</p>
<p>这篇文章是我看着源码凭自己理解写的，里面有一些自己的臆断，有看到错误的朋友，麻烦帮忙指出来更正，感谢！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编程语言</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python标准库源码（三）—— pprint模块</title>
    <url>/2020/12/11/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20pprint%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/109100139">https://blog.csdn.net/yushuaigee/article/details/109100139</a></p>
</blockquote>
<p> </p>
<p><strong>目录</strong></p>
<p><a href="#%E7%AC%AC1~22%E8%A1%8C%20%E6%A8%A1%E5%9D%97%E6%95%B4%E4%BD%93%E6%B3%A8%E9%87%8A%E3%80%81nt%E4%B8%8Eposix">模块整体注释</a></p>
<p><a href="#%E7%AC%AC37~44%E8%A1%8C%20%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E3%80%81%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E6%8E%A5%E5%8F%A3">依赖模块导入、对外暴露接口</a></p>
<p><a href="#saferepr%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%EF%BC%8C%E5%B9%B6%E4%B8%BA%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%90%E4%BE%9B%E4%BF%9D%E6%8A%A4">saferepr函数——返回对象的字符串表示，并为无限递归数据结构提供保护</a></p>
<p><a href="#isreadable%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%98%AF%E5%90%A6%E2%80%9C%E5%8F%AF%E8%AF%BB%E2%80%9D">isreadable函数——返回对象的是否“可读”</a></p>
<p><a href="#isrecursive%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%98%AF%E5%90%A6%E6%98%AF%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84">isrecursive函数——返回对象的是否是无限递归结构</a></p>
<p><a href="#PrettyPrinter%E2%80%94%E2%80%94%E4%BC%98%E9%9B%85%E6%A0%BC%E5%BC%8F%E5%8C%96Python%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB">PrettyPrinter——优雅格式化Python对象的类</a></p>
<p><a href="#pprint%E2%80%94%E2%80%94%E6%9B%B4%E6%96%B9%E4%BE%BF%E6%9B%B4%E7%BE%8E%E8%A7%82%E5%9C%B0%E6%89%93%E5%8D%B0">pprint——更方便更美观地打印</a></p>
<p><a href="#pformat%E2%80%94%E2%80%94%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E9%80%A0%E5%99%A8">pformat——格式化字符串构造器</a></p>
<p><a href="#pp%E2%80%94%E2%80%94%E5%90%8Cpprint">pp——同pprint</a></p>
<p><code>print</code> 模块能够美观地对数据结构进行格式化。不仅可以由解释器正确地解析，而且便于人类阅读。输出尽可能地保持在一行，需要分拆到多行时会有缩进表示。 </p>
<p>想象一下，你有下面这么一串 json (这个是我随机生成的)需要打印出来，或者调试程序的时候需要看一下 json 中某个字段的值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20201015163424822.png" alt="20201015163424822.png"></p>
<p> 用 print() 打印出来回事这么一坨，根本没有可读性：</p>
<blockquote>
<p> {‘_id’: ‘5f8808d57ac946ae591e8929’, ‘index’: 0, ‘guid’: ‘b41b3b14-1ae2-4cc4-b443-105bda03f4f0’, ‘isActive’: True, ‘balance’: ‘$1,985.20’, ‘picture’: ‘<a href="http://placehold.it/32x32&#39;">http://placehold.it/32x32&#39;</a>, ‘age’: 37, ‘eyeColor’: ‘brown’, ‘name’: ‘Alexandra Atkins’, ‘gender’: ‘female’, ‘company’: ‘COSMETEX’, ‘email’: ‘alexandraatkins@cosmetex.com’, ‘phone’: ‘+1 (999) 588-3661’, ‘address’: ‘779 Beayer Place, Belvoir, Washington, 5395’, ‘about’: ‘Laborum Lorem labore sint excepteur ad do esse veniam sunt cillum. Magna ipsum id aliqua consequat. Commodo enim occaecat pariatur ullamco irure incididunt et incididunt. Dolor aliqua eiusmod id laboris non laborum aliqua sunt occaecat eu commodo elit consequat. In mollit aute ullamco officia exercitation eiusmod ea labore id magna adipisicing.\r\n’, ‘registered’: ‘2018-12-29T09:52:41 -08:00’, ‘latitude’: 66.079339, ‘longitude’: 68.156168, ‘tags’: [‘mollit’, ‘velit’, ‘do’, ‘velit’, ‘Lorem’, ‘qui’, ‘irure’], ‘friends’: [{‘id’: 0, ‘name’: ‘Latonya Pena’}, {‘id’: 1, ‘name’: ‘Marion Ayers’}, {‘id’: 2, ‘name’: ‘Bishop Day’}], ‘greeting’: ‘Hello, Alexandra Atkins! You have 3 unread messages.’, ‘favoriteFruit’: ‘banana’} </p>
</blockquote>
<p> 在IDE中调试时，可能打印出来变成了一眼看不到头的一行，然后你就需要拖着进度条一个字段一个字段去找。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20201015164001778.png" alt="20201015164001778.png"></p>
<p> 而用 pprint() 打印出来会自动变成这样美观可读的格式，这就是 pprint 库的作用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20201015165529215.png" alt="20201015165529215.png"></p>
<p> pprint 模块主要包含 “pprint”,”pformat”,”isreadable”,”isrecursive”,”saferepr”, “pp” 方法和一个类“PrettyPrinter”，其中核心是 PrettyPrinter 类，其他方法都是调用的这个类。以下文章中的行数是与我所用的3.8.4版本 pprint.py 文件真实的行数对应的。</p>
<h3 id="模块整体注释"><a href="#模块整体注释" class="headerlink" title="模块整体注释"></a>模块整体注释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  Author:      Fred L. Drake, Jr.</span></span><br><span class="line"><span class="comment">#               fdrake@acm.org</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  This is a simple little module I wrote to make life easier.  I didn&#x27;t</span></span><br><span class="line"><span class="comment">#  see anything quite like it in the library, though I may have overlooked</span></span><br><span class="line"><span class="comment">#  something.  I wrote this when I was trying to read some heavily nested</span></span><br><span class="line"><span class="comment">#  tuples with fairly non-descriptive content.  This is modeled very much</span></span><br><span class="line"><span class="comment">#  after Lisp/Scheme - style pretty-printing of lists.  If you find it</span></span><br><span class="line"><span class="comment">#  useful, thank small children who sleep at night.</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;Support to pretty-print lists, tuples, &amp;amp; dictionaries recursively.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Very simple, but useful, especially in debugging data structures.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Classes</span></span><br><span class="line"><span class="string">-------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">PrettyPrinter()</span></span><br><span class="line"><span class="string">    Handle pretty-printing operations onto a stream using a configured</span></span><br><span class="line"><span class="string">    set of formatting parameters.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Functions</span></span><br><span class="line"><span class="string">---------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pformat()</span></span><br><span class="line"><span class="string">    Format a Python object into a pretty-printed representation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pprint()</span></span><br><span class="line"><span class="string">    Pretty-print a Python object to a stream [default is sys.stdout].</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">saferepr()</span></span><br><span class="line"><span class="string">    Generate a &#x27;standard&#x27; repr()-like value, but protect against recursive</span></span><br><span class="line"><span class="string">    data structures.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pp——同pprint&lt;/h3&gt; </span><br><span class="line">&lt;pre&gt;&lt;code <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;language-python&quot;</span>&gt;<span class="function">def <span class="title">pp</span><span class="params">(object, *args, sort_dicts=False, **kwargs)</span>:</span></span><br><span class="line">    &quot;&quot;&quot;Pretty-print a Python object&quot;&quot;&quot;</span><br><span class="line">    pprint(object, *args, sort_dicts=sort_dicts, **kwargs)</span><br></pre></td></tr></table></figure>
<h3 id="saferepr函数——返回对象的字符串表示，并为无限递归数据结构提供保护"><a href="#saferepr函数——返回对象的字符串表示，并为无限递归数据结构提供保护" class="headerlink" title="saferepr函数——返回对象的字符串表示，并为无限递归数据结构提供保护"></a>saferepr函数——返回对象的字符串表示，并为无限递归数据结构提供保护</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saferepr</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Version of repr() which can handle recursive data structures.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _safe_repr(<span class="built_in">object</span>, &#123;&#125;, <span class="literal">None</span>, <span class="number">0</span>, <span class="literal">True</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="isrecursive函数——返回对象的是否是无限递归结构"><a href="#isrecursive函数——返回对象的是否是无限递归结构" class="headerlink" title="isrecursive函数——返回对象的是否是无限递归结构"></a>isrecursive函数——返回对象的是否是无限递归结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isrecursive</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Determine if object requires a recursive representation.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _safe_repr(<span class="built_in">object</span>, &#123;&#125;, <span class="literal">None</span>, <span class="number">0</span>, <span class="literal">True</span>)[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>indent：</strong>每个嵌套级别要缩进的空格数，即第 1 层缩进 *<em>indent **个字符，第 2 层缩进 2 *  *</em>indent **个字符，默认值 1。</li>
<li><strong>width：</strong> 输出的字符的最大宽度，默认值 80。</li>
<li><strong>depth：</strong> 打印嵌套结构的最大深度，超过这个深度不再换行，默认None表示不限制。</li>
<li><strong>stream：**</strong> **所需的输出流。如果省略（或False），将使用标准输出流，即 sys.stdout ，这个和 print()一样。</li>
<li>*** ：** keyword-only参数标志，不占参数位置，详见我的另一篇博客 <a href="https://blog.csdn.net/yushuaigee/article/details/107567001">彻底弄懂 Python3中入参里的*号的作用</a> 第5节。</li>
<li><strong>compact：</strong> 如果为True，则多个元素将合并为一行，不会打印换行符，**width **参数依然生效，默认为 False。</li>
<li><strong>sort_dicts：</strong> 字典打印前是否排序，如果为 True，则打印前根据 key 进行排序。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pprint</span>(<span class="params">self, <span class="built_in">object</span></span>):</span></span><br><span class="line">    self._format(<span class="built_in">object</span>, self._stream, <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    self._stream.write(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recursion</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;&amp;lt;Recursion on %s with id=%s&amp;gt;&quot;</span></span><br><span class="line">            % (<span class="built_in">type</span>(<span class="built_in">object</span>).__name__, <span class="built_in">id</span>(<span class="built_in">object</span>)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format</span>(<span class="params">self, <span class="built_in">object</span>, context, maxlevels, level</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Format object for a specific context, returning a string</span></span><br><span class="line"><span class="string">    and flags indicating whether the representation is &#x27;readable&#x27;</span></span><br><span class="line"><span class="string">    and whether the object represents a recursive construct.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> _safe_repr(<span class="built_in">object</span>, context, maxlevels, level, self._sort_dicts)</span><br></pre></td></tr></table></figure>
<h3 id="pprint——更方便更美观地打印"><a href="#pprint——更方便更美观地打印" class="headerlink" title="pprint——更方便更美观地打印"></a>pprint——更方便更美观地打印</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pprint</span>(<span class="params"><span class="built_in">object</span>, stream=<span class="literal">None</span>, indent=<span class="number">1</span>, width=<span class="number">80</span>, depth=<span class="literal">None</span>, *,</span></span></span><br><span class="line"><span class="function"><span class="params">           compact=<span class="literal">False</span>, sort_dicts=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pretty-print a Python object to a stream [default is sys.stdout].&quot;&quot;&quot;</span></span><br><span class="line">    printer = PrettyPrinter(</span><br><span class="line">        stream=stream, indent=indent, width=width, depth=depth,</span><br><span class="line">        compact=compact, sort_dicts=sort_dicts)</span><br><span class="line">    printer.pprint(<span class="built_in">object</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pformat</span>(<span class="params">self, <span class="built_in">object</span></span>):</span></span><br><span class="line">    sio = _StringIO()</span><br><span class="line">    self._format(<span class="built_in">object</span>, sio, <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> sio.getvalue()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pp——同pprint"><a href="#pp——同pprint" class="headerlink" title="pp——同pprint"></a>pp——同pprint</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pp</span>(<span class="params"><span class="built_in">object</span>, *args, sort_dicts=<span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Pretty-print a Python object&quot;&quot;&quot;</span></span><br><span class="line">    pprint(<span class="built_in">object</span>, *args, sort_dicts=sort_dicts, **kwargs)</span><br></pre></td></tr></table></figure>
<p>原来和pprint是一样的，看来以后只需要 from pprint import pp 了。欧耶，没白看。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pprint</tag>
        <tag>Python标准库</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python实现一个软件自动升级系统</title>
    <url>/2020/04/25/%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%8D%87%E7%BA%A7%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/105140425">https://blog.csdn.net/yushuaigee/article/details/105140425</a></p>
</blockquote>
<p><strong>目录</strong></p>
<p><a href="#%E4%B8%80%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF">一、服务端</a></p>
<p><a href="#1.%C2%A0XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1. XML配置文件</a></p>
<p><a href="#%C2%A02.%C2%A0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1"> 2. 服务端代码设计</a></p>
<p><a href="#%E4%BA%8C%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF">二、客户端</a></p>
<p><a href="#1.%C2%A0XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">1. XML配置文件</a></p>
<p><a href="#2.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1">2. 客户端代码设计</a></p>
<p><a href="#%E4%B8%89%E3%80%81%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">三、运行效果</a></p>
<p><a href="#1.%20%E7%A8%8B%E5%BA%8F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">1. 程序目录结构</a></p>
<p><a href="#2.%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">2. 服务端运行效果</a></p>
<p><a href="#3.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C">3. 客户端运行效果</a></p>
<p><a href="#%E5%9B%9B%E3%80%81%E6%94%B9%E8%BF%9B%E6%80%9D%E8%B7%AF">四、改进思路</a></p>
<p><a href="#%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD">五、文件下载</a></p>
<p>软件客户端在发布新版本的时候，有时候只修改了几个文件，没必要让用户重新下载整个客户端再重新安装，同时也不应要求用户每次去手动下载更新的文件，再手动覆盖本地文件。这个时候需要设计一个自动升级机制，在某些条件触发时(比如软件启动的时候)自动查看是否有更新，如果有就将改变的内容下载下来，更新本地旧文件，再根据情况判断是否重启客户端。这个功能现在是桌面程序必备的功能，基本所有的客户端都有这个检查更新的功能。我曾经用Python实现过一个基于http下载的简易自动升级系统，可以独立运行、复用在不同的情景下。</p>
<p>设计思路很简单：当有新版本需要发布时，将文件放在服务端，生成一个记录每个文件变化的配置文件。客户端本地也有一个记录文件信息的配置文件，客户端检查更新时，将服务端的配置文件下载下来，与本地配置文件进行比较，然后下载有变化的文件，覆盖本地文件（如果文件正在使用中，可能无法覆盖，这时候更新前应该先关闭正在运行的客户端），中间有Tkinter做的界面提示更新进度。更新结束后根据策略决定是否重启客户端。</p>
<h2 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h2><p>服务端要做的事，首先是选择一个端口号，开启用于响应客户端下载的http服务。然后把指定的目录下的所有文件都扫描一遍，给每个文件记录一个版本号和最后修改日期，再生成一个总版本号，写在XML配置文件里。</p>
<p>比如版本号从0开始，第一次发布程序时，每个文件的版本号都是0，总版本号也是0，第二次发布时，扫描每个文件的最后修改日期，如果日期大于XML文件中记录的日期，将这个文件的记录日期更新，版本号加1。扫描完毕，只要有任意文件的版本号发生变化，总版本号也加1。这样客户端在检查更新时，只需要先比较服务端的总版本号和自己本地的总版本号是否一致。如果不一致，再下载XML文件比较每一个文件版本号变化，如果一致就不用下载XML文件比较了（可以在服务端增加一个接口，客户端请求这个接口时返回一个总版本号字段）。</p>
<h3 id="1-XML配置文件"><a href="#1-XML配置文件" class="headerlink" title="1. XML配置文件"></a>1. <strong>XML</strong>配置文件</h3><p><strong>1.1 XML配置文件结构</strong></p>
<p>ServerInfo节点：记录服务端IP和端口号，可以让客户端知道去哪里下载，当下载地址或端口号变化时，通过更新这个节点，客户端下次更新时就会到新的地址和端口号下载。</p>
<p>ClientVersion节点：要升级的模块的文件信息，包含1个总版本号属性，子节点包括该模块下每个文件的相对路径、文件大小、最后更新时间和版本号。这个节点可以设计多个，用不同的节点名，区分不同的模块，每个模块都有自己的总版本号。这里以1个模块为例。</p>
<p><strong>1.2 XML配置文件示例：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理xml的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionInfoXml</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, xml_path, server_info=<span class="literal">None</span>, module_list=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.xml_path = xml_path</span><br><span class="line">        <span class="keyword">if</span> server_info <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> module_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                module_list = [<span class="string">&quot;ClientVersion&quot;</span>]</span><br><span class="line">            self.create_new_xml(server_info, module_list)</span><br><span class="line">        self.tree = ET.parse(self.xml_path)</span><br><span class="line">        self.root = self.tree.getroot()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_new_xml</span>(<span class="params">self, server_info, module_info</span>):</span></span><br><span class="line">        root = ET.Element(<span class="string">&quot;versionInfo&quot;</span>)</span><br><span class="line">        ServerInfo = ET.SubElement(root, <span class="string">&quot;ServerInfo&quot;</span>)</span><br><span class="line">        ET.SubElement(ServerInfo, <span class="string">&quot;ServerIp&quot;</span>).text = server_info[<span class="number">0</span>]</span><br><span class="line">        ET.SubElement(ServerInfo, <span class="string">&quot;ServerPort&quot;</span>).text = server_info[<span class="number">1</span>]</span><br><span class="line">        ET.SubElement(ServerInfo, <span class="string">&quot;XmlLocalPath&quot;</span>).text = server_info[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> each_module <span class="keyword">in</span> module_info:</span><br><span class="line">            ET.SubElement(root, each_module).<span class="built_in">set</span>(<span class="string">&quot;Version&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        self.save_change(root)</span><br><span class="line">        print(<span class="string">&quot;I created a new temp xml!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_change</span>(<span class="params">self, root=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            root = self.root</span><br><span class="line">        rough_bytes = ET.tostring(root, <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        rough_string = <span class="built_in">str</span>(rough_bytes, encoding=<span class="string">&quot;utf-8&quot;</span>).replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;    &quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        content = minidom.parseString(rough_string)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.xml_path, <span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> fs:</span><br><span class="line">            content.writexml(fs, indent=<span class="string">&quot;&quot;</span>, addindent=<span class="string">&quot;\t&quot;</span>, newl=<span class="string">&quot;\n&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">changeServerInfo</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(value) <span class="keyword">is</span> <span class="built_in">int</span>:</span><br><span class="line">            value = <span class="built_in">str</span>(value)</span><br><span class="line">        Xpath = <span class="string">&quot;ServerInfo/%s&quot;</span> % name</span><br><span class="line">        element = self.root.find(Xpath)</span><br><span class="line">        <span class="keyword">if</span> element <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            element.text = value</span><br><span class="line">            <span class="comment"># self.save_change()</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;I can&#x27;t find \&quot;ServerInfo/%s\&quot; in xml!&quot;</span> % name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addObject</span>(<span class="params">self, module_name, file_path, file_size, last_update_time, version</span>):</span></span><br><span class="line">        moduleVersion = self.root.find(module_name)</span><br><span class="line">        <span class="built_in">object</span> = ET.SubElement(moduleVersion, <span class="string">&quot;object&quot;</span>)</span><br><span class="line">        ET.SubElement(<span class="built_in">object</span>, <span class="string">&quot;FileRelativePath&quot;</span>).text = <span class="built_in">str</span>(file_path)</span><br><span class="line">        ET.SubElement(<span class="built_in">object</span>, <span class="string">&quot;FileSize&quot;</span>).text = <span class="built_in">str</span>(file_size)</span><br><span class="line">        ET.SubElement(<span class="built_in">object</span>, <span class="string">&quot;LastUpdateTime&quot;</span>).text = <span class="built_in">str</span>(last_update_time)</span><br><span class="line">        ET.SubElement(<span class="built_in">object</span>, <span class="string">&quot;Version&quot;</span>).text = <span class="built_in">str</span>(version)</span><br><span class="line">        <span class="comment"># self.save_change()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteObject</span>(<span class="params">self, module_name, file_name</span>):</span></span><br><span class="line">        Xpath = <span class="string">&quot;%s/object&quot;</span> % module_name</span><br><span class="line">        objects = self.root.findall(Xpath)</span><br><span class="line">        moudleVersion = self.root.find(module_name)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> objects:</span><br><span class="line">            <span class="keyword">if</span> element.find(<span class="string">&#x27;FileRelativePath&#x27;</span>).text == file_name:</span><br><span class="line">                moudleVersion.remove(element)</span><br><span class="line">                <span class="comment"># self.save_change()</span></span><br><span class="line">                print(<span class="string">&quot;Delete object: %s&quot;</span> % file_name)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;I can&#x27;t find \&quot;%s\&quot; in xml!&quot;</span> % file_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateObject</span>(<span class="params">self, module_name, file_name, version</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(version) <span class="keyword">is</span> <span class="built_in">int</span>:</span><br><span class="line">            version = <span class="built_in">str</span>(version)</span><br><span class="line">        Xpath = <span class="string">&quot;%s/object&quot;</span> % module_name</span><br><span class="line">        objects = self.root.findall(Xpath)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> objects:</span><br><span class="line">            <span class="keyword">if</span> element.find(<span class="string">&#x27;FileRelativePath&#x27;</span>).text == file_name:</span><br><span class="line">                element.find(<span class="string">&#x27;Version&#x27;</span>).text = version</span><br><span class="line">                <span class="comment"># self.save_change()</span></span><br><span class="line">                <span class="comment"># print(&quot;Update \&quot;%s\&quot; version: %s&quot; % (file_name, version))</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;I can&#x27;t find \&quot;%s\&quot; in xml!&quot;</span> % file_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateAttribute</span>(<span class="params">self, module_name, version</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(version) <span class="keyword">is</span> <span class="built_in">int</span>:</span><br><span class="line">            version = <span class="built_in">str</span>(version)</span><br><span class="line">        moduleVersion = self.root.find(module_name)</span><br><span class="line">        moduleVersion.<span class="built_in">set</span>(<span class="string">&quot;Version&quot;</span>, version)</span><br><span class="line">        <span class="comment"># self.save_change()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getObjects</span>(<span class="params">self, module_name</span>):</span></span><br><span class="line">        list_element = []</span><br><span class="line">        Xpath = <span class="string">&quot;%s/object&quot;</span> % module_name</span><br><span class="line">        objects = self.root.findall(Xpath)</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> objects:</span><br><span class="line">            dict_element = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(element):</span><br><span class="line">                dict_element[value.tag] = value.text</span><br><span class="line">            list_element.append(dict_element)</span><br><span class="line">        <span class="keyword">return</span> list_element</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addModule</span>(<span class="params">self, module</span>):</span></span><br><span class="line">        self.root.append(module)</span><br><span class="line">        <span class="comment"># self.save_change()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteModule</span>(<span class="params">self, module_name</span>):</span></span><br><span class="line">        module = self.root.find(module_name)</span><br><span class="line">        <span class="keyword">if</span> module <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.root.remove(module)</span><br><span class="line">            <span class="comment"># self.save_change()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getModules</span>(<span class="params">self</span>):</span></span><br><span class="line">        dict_element = &#123;&#125;</span><br><span class="line">        objects = self.root.getchildren()</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(objects):</span><br><span class="line">            dict_element[value.tag] = value.attrib.get(<span class="string">&quot;Version&quot;</span>)</span><br><span class="line">        <span class="keyword">del</span> dict_element[<span class="string">&quot;ServerInfo&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> dict_element</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAttribute</span>(<span class="params">self, module_name</span>):</span></span><br><span class="line">        moduleVersion = self.root.find(module_name)</span><br><span class="line">        <span class="keyword">return</span> moduleVersion.get(<span class="string">&quot;Version&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_node_value</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;查找某个路径匹配的第一个节点</span></span><br><span class="line"><span class="string">           tree: xml树</span></span><br><span class="line"><span class="string">           path: 节点路径&#x27;&#x27;&#x27;</span></span><br><span class="line">        node = self.tree.find(path)</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> node.text</span><br></pre></td></tr></table></figure>
<h3 id="2-服务端代码设计"><a href="#2-服务端代码设计" class="headerlink" title="2. 服务端代码设计"></a>2. <strong>服务端代码设计</strong></h3><p>源码文件太长，这里只贴出主要的两个方法，具体实现源码文件放在文末下载。</p>
<p>首先是根扫描所有文件，生成一个最新xml配置文件，然后再比较两个xml，分析出增删改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/4/25 20:16</span></span><br><span class="line"><span class="comment"># @Author  : yushuaige</span></span><br><span class="line"><span class="comment"># @File    : AutoCheckVersion.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Function: 实现客户端自动更新（服务端）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理xml的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionInfoXml</span>():</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 同上面xml类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AutoCheckVersion</span>(<span class="params">old_xml_path, new_xml_path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    比较两个xml的objects节点，分析出增加，更改，和删除的文件列表，并在新xml里更新版本号</span></span><br><span class="line"><span class="string">    :param old_xml: 旧xml的完整路径</span></span><br><span class="line"><span class="string">    :param new_xml: 新xml的完整路径</span></span><br><span class="line"><span class="string">    :return: len(add_list), len(delete_list), len(change_list),</span></span><br><span class="line"><span class="string">    :return: add_list: [filname1, filname2], delete_list: [filname1, filname2] change_list: [filname1, filname2]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;Analyze the xml files and update the version number ...&quot;</span>)</span><br><span class="line">    old_xml = VersionInfoXml(old_xml_path)</span><br><span class="line">    new_xml = VersionInfoXml(new_xml_path)</span><br><span class="line">    <span class="comment"># 先分析模块的增、删、改</span></span><br><span class="line">    old_modules = <span class="built_in">list</span>(old_xml.getModules().keys())</span><br><span class="line">    new_modules = <span class="built_in">list</span>(new_xml.getModules().keys())</span><br><span class="line">    add_modules_list = <span class="built_in">list</span>(<span class="built_in">set</span>(new_modules).difference(<span class="built_in">set</span>(old_modules)))</span><br><span class="line">    <span class="keyword">for</span> module_name <span class="keyword">in</span> add_modules_list:</span><br><span class="line">        ET.SubElement(old_xml.root, module_name).<span class="built_in">set</span>(<span class="string">&quot;Version&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    common_modules_list = [item <span class="keyword">for</span> item <span class="keyword">in</span> old_modules <span class="keyword">if</span> item <span class="keyword">in</span> new_modules]</span><br><span class="line">    <span class="comment"># 分析每个的模块中的每个文件的增、删、改</span></span><br><span class="line">    total_add_list = []</span><br><span class="line">    total_delete_list = []</span><br><span class="line">    total_change_list = []</span><br><span class="line">    common_modules_list.extend(add_modules_list)</span><br><span class="line">    <span class="keyword">for</span> module_name <span class="keyword">in</span> common_modules_list:</span><br><span class="line">        old_xml_objects = old_xml.getObjects(module_name)</span><br><span class="line">        new_xml_objects = new_xml.getObjects(module_name)</span><br><span class="line">        old_xml_objects_dict = &#123;file_info[<span class="string">&quot;FileRelativePath&quot;</span>]: file_info <span class="keyword">for</span> file_info <span class="keyword">in</span> old_xml_objects&#125;</span><br><span class="line">        new_xml_objects_dict = &#123;file_info[<span class="string">&quot;FileRelativePath&quot;</span>]: file_info <span class="keyword">for</span> file_info <span class="keyword">in</span> new_xml_objects&#125;</span><br><span class="line">        old_data_list = <span class="built_in">set</span>(old_xml_objects_dict.keys())</span><br><span class="line">        new_data_list = <span class="built_in">set</span>(new_xml_objects_dict.keys())</span><br><span class="line">        add_list = <span class="built_in">list</span>(new_data_list.difference(old_data_list))</span><br><span class="line">        delete_list = <span class="built_in">list</span>(old_data_list.difference(new_data_list))</span><br><span class="line">        common_list = <span class="built_in">list</span>(old_data_list.intersection(new_data_list))</span><br><span class="line">        change_list = []</span><br><span class="line">        <span class="comment"># 更新每个文件的版本号信息</span></span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> common_list:</span><br><span class="line">            new_version = <span class="built_in">int</span>(old_xml_objects_dict[file_name][<span class="string">&quot;Version&quot;</span>])</span><br><span class="line">            update = TimeFormatComp(new_xml_objects_dict[file_name][<span class="string">&quot;LastUpdateTime&quot;</span>],</span><br><span class="line">                                    old_xml_objects_dict[file_name][<span class="string">&quot;LastUpdateTime&quot;</span>])</span><br><span class="line">            <span class="keyword">if</span> update <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                change_list.append(file_name)</span><br><span class="line">                new_version += <span class="number">1</span></span><br><span class="line">            new_xml.updateObject(module_name, file_name, new_version)</span><br><span class="line">        <span class="comment"># 更新模块版本信息</span></span><br><span class="line">        new_module_version = <span class="built_in">int</span>(old_xml.getAttribute(module_name))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(add_list) <span class="keyword">or</span> <span class="built_in">len</span>(delete_list) <span class="keyword">or</span> <span class="built_in">len</span>(change_list):</span><br><span class="line">            new_module_version = new_module_version + <span class="number">1</span></span><br><span class="line">        new_xml.updateAttribute(module_name, new_module_version)</span><br><span class="line"></span><br><span class="line">        total_add_list.extend(add_list)</span><br><span class="line">        total_delete_list.extend(delete_list)</span><br><span class="line">        total_change_list.extend(change_list)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存到文件</span></span><br><span class="line">    new_xml.save_change()</span><br><span class="line">    print(<span class="string">&quot;Analysis update info done. Save the new xml ...&quot;</span>)</span><br><span class="line">    <span class="comment"># 结果提示</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(total_add_list) <span class="keyword">or</span> <span class="built_in">len</span>(total_delete_list) <span class="keyword">or</span> <span class="built_in">len</span>(total_change_list):</span><br><span class="line">        <span class="comment"># 替换旧的xml文件</span></span><br><span class="line">        os.remove(old_xml_path)</span><br><span class="line">        os.rename(new_xml_path, old_xml_path)</span><br><span class="line">        print(<span class="string">&quot;Done. add: %d, delete: %d, update: %d. The new client version: %s.&quot;</span> % (</span><br><span class="line">            <span class="built_in">len</span>(total_add_list), <span class="built_in">len</span>(total_delete_list), <span class="built_in">len</span>(total_change_list), <span class="built_in">str</span>(new_xml.getModules())))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        os.remove(new_xml_path)</span><br><span class="line">        print(<span class="string">&quot;No file changed! The current client version: %s.&quot;</span> % (<span class="built_in">str</span>(new_xml.getModules())))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(total_add_list), <span class="built_in">len</span>(total_delete_list), <span class="built_in">len</span>(total_change_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateNewXmlFromFiles</span>(<span class="params">client_dir</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    遍历文件夹所有文件，生成标准xml</span></span><br><span class="line"><span class="string">    :param client_dir: 要遍历的文件夹路径</span></span><br><span class="line"><span class="string">    :return: 生成的xml的完整路径</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;Scan the folder and create the temp xml file ...&quot;</span>)</span><br><span class="line">    config_parser = configparser.ConfigParser()</span><br><span class="line">    config_parser.read(os.path.dirname(sys.path[<span class="number">0</span>]) + <span class="string">&#x27;\\cfg.ini&#x27;</span>)</span><br><span class="line">    UPDATE_HOST = config_parser.get(<span class="string">&quot;mqtt&quot;</span>, <span class="string">&#x27;serv&#x27;</span>)</span><br><span class="line">    server_info = [UPDATE_HOST, <span class="string">&quot;8888&quot;</span>, <span class="string">&quot;dev_manage_win&quot;</span>]</span><br><span class="line">    module_list = os.listdir(client_dir)</span><br><span class="line">    new_xml = VersionInfoXml(<span class="string">&quot;VersionInfoTemp.xml&quot;</span>, server_info, module_list)</span><br><span class="line">    <span class="keyword">for</span> module_name <span class="keyword">in</span> module_list:</span><br><span class="line">        module_dir = os.path.join(client_dir, module_name)</span><br><span class="line">        <span class="keyword">for</span> (dirpath, dirnames, filenames) <span class="keyword">in</span> os.walk(module_dir):</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> filenames:</span><br><span class="line">                file_dir = os.path.join(dirpath, file)</span><br><span class="line">                file_path = file_dir.replace(client_dir, <span class="string">&quot;&quot;</span>).strip(<span class="string">&quot;\\&quot;</span>).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">                file_size = os.path.getsize(file_dir)</span><br><span class="line">                last_update_time = TimeStampFormat(os.path.getmtime(file_dir))</span><br><span class="line">                version = <span class="number">1</span></span><br><span class="line">                new_xml.addObject(module_name, file_path, file_size, last_update_time, version)</span><br><span class="line">    new_xml.save_change()</span><br><span class="line">    new_xml_path = os.path.join(sys.path[<span class="number">0</span>], <span class="string">&quot;VersionInfoTemp.xml&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> new_xml_path</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h2><h3 id="1-XML配置文件-1"><a href="#1-XML配置文件-1" class="headerlink" title="1. XML配置文件"></a>1. <strong>XML</strong>配置文件</h3><p>为了简便，客户端和服务端处理xml文件的类用同一个。</p>
<h3 id="2-客户端代码设计"><a href="#2-客户端代码设计" class="headerlink" title="2. 客户端代码设计"></a>2. 客户<strong>端代码设计</strong></h3><p>源码文件太长，这里只贴出主要的两个方法，具体实现源码文件放在文末下载。</p>
<p>下载最新xml配置文件和本地配置文件进行比较，然后分析出增删改，进行下载和删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/4/25 20:16</span></span><br><span class="line"><span class="comment"># @Author  : yushuaige</span></span><br><span class="line"><span class="comment"># @File    : AutoUpdate.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Function: 实现客户端自动更新（客户端）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理xml的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionInfoXml</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 同上面xml类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动更新时，检查更新</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CheckUpdate</span>(<span class="params">server_ip, server_port, module_name, order</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AutoUpdate</span>(<span class="params">server_ip, server_port, module_name, order</span>):</span></span><br><span class="line">    time_start = time.perf_counter()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        download_url = <span class="string">&quot;http://&#123;0&#125;:&#123;1&#125;/&#123;2&#125;&quot;</span>.<span class="built_in">format</span>(server_ip, server_port, <span class="string">&quot;VersionInfo.xml&quot;</span>)</span><br><span class="line">        local_path = os.path.join(sys.path[<span class="number">0</span>], <span class="string">&quot;VersionInfoTemp.xml&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;download_url: &quot;</span> + download_url)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> download_file_by_http(download_url, local_path):</span><br><span class="line">            <span class="keyword">raise</span> Exception()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># tkinter.messagebox.showerror(&quot;更新无法继续&quot;, &quot;获取最新版本列表文件出现异常！&quot;)</span></span><br><span class="line">        print(<span class="string">&quot;Update error: Can&#x27;t get the latest VersionInfo xml!&quot;</span>)</span><br><span class="line">        <span class="comment"># root.destroy()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    root.update()</span><br><span class="line">    root.deiconify()</span><br><span class="line">    <span class="comment"># 比较文件变化</span></span><br><span class="line">    add_dict, delete_list = analyze_update_info(local_xml_path, update_xml_path, module_name)</span><br><span class="line">    <span class="keyword">if</span> add_dict == &#123;&#125; <span class="keyword">and</span> delete_list == []:</span><br><span class="line">        os.remove(update_xml_path)</span><br><span class="line">        <span class="comment"># tkinter.messagebox.showinfo(&quot;更新无法继续&quot;, &quot;当前客户端已经是最新版本！&quot;)</span></span><br><span class="line">        print(<span class="string">&quot;No file changed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 下载需要更新的文件</span></span><br><span class="line">    download_progress(add_dict)</span><br><span class="line">    <span class="comment"># 文件覆盖到主目录</span></span><br><span class="line">    prompt_info11.<span class="built_in">set</span>(<span class="string">&quot;正在解压...&quot;</span>)</span><br><span class="line">    prompt_info13.<span class="built_in">set</span>(<span class="string">&quot;总体进度：99.9%&quot;</span>)</span><br><span class="line">    prompt_info21.<span class="built_in">set</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    root.update()</span><br><span class="line">    source_dir = os.path.join(sys.path[<span class="number">0</span>], <span class="string">&quot;TempFolder&quot;</span>)</span><br><span class="line">    dest_dir = os.path.dirname(sys.path[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># dest_dir = os.path.join(sys.path[0], &quot;test_main&quot;)</span></span><br><span class="line">    override_dir(source_dir, dest_dir)</span><br><span class="line">    <span class="comment"># 删除要删除的文件</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> delete_list:</span><br><span class="line">        delete_dir(os.path.join(dest_dir, file))</span><br><span class="line">    <span class="comment"># 更新xml文件</span></span><br><span class="line">    <span class="keyword">if</span> module_name == <span class="string">&quot;all_module&quot;</span>:</span><br><span class="line">        os.remove(local_xml_path)</span><br><span class="line">        os.rename(update_xml_path, local_xml_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        update_xml(local_xml_path, update_xml_path, module_name)</span><br><span class="line">    <span class="comment"># 客户端更新结束</span></span><br><span class="line">    time_end = time.perf_counter()</span><br><span class="line">    print(<span class="string">&quot;更新耗时：%ds&quot;</span> % (time_end - time_start))</span><br><span class="line">    prompt_info11.<span class="built_in">set</span>(<span class="string">&quot;更新完毕。&quot;</span>)</span><br><span class="line">    prompt_info13.<span class="built_in">set</span>(<span class="string">&quot;总体进度：100.0%&quot;</span>)</span><br><span class="line">    root.update()</span><br><span class="line">    <span class="comment"># tkinter.messagebox.showinfo(&quot;更新完成&quot;, &quot;更新完毕，耗时：%ds&quot; % (time_end - time_start))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析两个xml文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analyze_update_info</span>(<span class="params">local_xml, update_xml, module_name</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    分析本地xml文件和最新xml文件获得增加的文件和要删除的文件</span></span><br><span class="line"><span class="string">    :param local_xml: 本地xml文件路径</span></span><br><span class="line"><span class="string">    :param update_xml: 下载的最新xml文件路径</span></span><br><span class="line"><span class="string">    :return: download_info: &#123;filename1: fizesize1, filename2: fizesize2&#125;, delete_list: [filname1, filname2]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&quot;Analyze the xml files and check the version number ...&quot;</span>)</span><br><span class="line">    old_xml = VersionInfoXml(local_xml)</span><br><span class="line">    new_xml = VersionInfoXml(update_xml)</span><br><span class="line">    module_names = []</span><br><span class="line">    <span class="keyword">if</span> module_name == <span class="string">&quot;all_module&quot;</span>:</span><br><span class="line">        module_names = new_xml.getModules()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        module_names.append(module_name)</span><br><span class="line">    download_info_total = &#123;&#125;</span><br><span class="line">    delete_list_total = []</span><br><span class="line">    <span class="keyword">for</span> module_name <span class="keyword">in</span> module_names:</span><br><span class="line">        <span class="keyword">if</span> old_xml.getAttribute(module_name) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            ET.SubElement(old_xml.root, module_name).<span class="built_in">set</span>(<span class="string">&quot;Version&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> new_xml.getAttribute(module_name) &amp;lt;= old_xml.getAttribute(module_name):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        old_xml_objects = old_xml.getObjects(module_name)</span><br><span class="line">        new_xml_objects = new_xml.getObjects(module_name)</span><br><span class="line">        old_xml_objects_dict = &#123;file_info[<span class="string">&quot;FileRelativePath&quot;</span>]: file_info <span class="keyword">for</span> file_info <span class="keyword">in</span> old_xml_objects&#125;</span><br><span class="line">        new_xml_objects_dict = &#123;file_info[<span class="string">&quot;FileRelativePath&quot;</span>]: file_info <span class="keyword">for</span> file_info <span class="keyword">in</span> new_xml_objects&#125;</span><br><span class="line">        old_data_list = <span class="built_in">set</span>(old_xml_objects_dict.keys())</span><br><span class="line">        new_data_list = <span class="built_in">set</span>(new_xml_objects_dict.keys())</span><br><span class="line">        add_list = <span class="built_in">list</span>(new_data_list.difference(old_data_list))</span><br><span class="line">        delete_list = <span class="built_in">list</span>(old_data_list.difference(new_data_list))</span><br><span class="line">        common_list = <span class="built_in">list</span>(old_data_list.intersection(new_data_list))</span><br><span class="line"></span><br><span class="line">        download_info = &#123;file_name: new_xml_objects_dict[file_name][<span class="string">&quot;FileSize&quot;</span>] <span class="keyword">for</span> file_name <span class="keyword">in</span> add_list&#125;</span><br><span class="line">        <span class="comment"># 根据每个文件的版本号，确定是否需要更新</span></span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> common_list:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(new_xml_objects_dict[file_name][<span class="string">&quot;Version&quot;</span>]) &amp;gt; <span class="built_in">int</span>(old_xml_objects_dict[file_name][<span class="string">&quot;Version&quot;</span>]):</span><br><span class="line">                download_info.update(&#123;file_name: new_xml_objects_dict[file_name][<span class="string">&quot;FileSize&quot;</span>]&#125;)</span><br><span class="line"></span><br><span class="line">        download_info_total.update(download_info)</span><br><span class="line">        delete_list_total.extend(delete_list)</span><br><span class="line">    <span class="comment"># return download_info, delete_list</span></span><br><span class="line">    <span class="keyword">return</span> download_info_total, delete_list_total</span><br></pre></td></tr></table></figure>
<h2 id="三、运行效果"><a href="#三、运行效果" class="headerlink" title="三、运行效果"></a>三、运行效果</h2><h3 id="1-程序目录结构"><a href="#1-程序目录结构" class="headerlink" title="1. 程序目录结构"></a>1. 程序目录结构</h3><p><strong>1.1 服务端</strong></p>
<p>ClientFolder目录用来存放要更新的文件夹，</p>
<p>venv是python目录，</p>
<p>cfg.ini文件用来配置ip、端口等信息，</p>
<p>server.py是主程序，</p>
<p>start.bat用来双击启动server.py，</p>
<p>VersionInfo.xml是存放文件信息的xml</p>
<p>       <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425213341739.png" alt="20200425213341739.png"></p>
<p><strong>1.2 客户端</strong></p>
<p>TempFolder目录用来存放下载下来的文件，</p>
<p>venv是python目录，</p>
<p>client.py是主程序，</p>
<p>start.bat用来双击启动server.py，</p>
<p>VersionInfo.xml是存放文件信息的xml，</p>
<p>VersionInfoTemp.xml是更新时自动生成的，是下载的最新配置文件</p>
<p>       <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425213310466.png" alt="20200425213310466.png"></p>
<h3 id="2-服务端运行效果"><a href="#2-服务端运行效果" class="headerlink" title="2. 服务端运行效果"></a>2. 服务端运行效果</h3><p>默认使用本地测试ip 127.0.0.1，默认端口8888</p>
<p>     <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425214624388.png" alt="20200425214624388.png"></p>
<h3 id="3-客户端运行效果"><a href="#3-客户端运行效果" class="headerlink" title="3. 客户端运行效果"></a>3. 客户端运行效果</h3><p>上面窗口是控制台窗口，显示运行过程的日志，下面是更新界面。</p>
<p>如果不想显示控制台界面，只需要把start.bat里前三行的注释打开即可。</p>
<p>文件太小可能会一闪而过，因为程序默认更新完立即退出。</p>
<p>    <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425215953325.png" alt="20200425215953325.png"></p>
<p>   <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20200425215030334.png" alt="20200425215030334.png"></p>
<h2 id="四、改进思路"><a href="#四、改进思路" class="headerlink" title="四、改进思路"></a>四、改进思路</h2><p><strong>1.多线程提高效率</strong></p>
<p>因为没有测试过文件数量和大小非常大的情况，现在程序的所有步骤都是单线程执行，可以将文件扫描和下载等耗时间的步骤，改进成多线程或者协程同时运行，提高程序的运行效率。</p>
<p><strong>2.文件扫描方式</strong></p>
<p>当前只根据文件相对路径加文件全名的方式，进行文件区分，然后根据最后修改时间来判断是否需要更新，可以增加MD5校验来保证文件的唯一性。</p>
<p><strong>3.界面完善</strong></p>
<p>当前只有在下载文件时有界面提示，可以改进界面，使整个更新过程可视化。</p>
<p><strong>4.启动方式</strong></p>
<p>当前使用bat脚本调命令行的方式启动程序，会有一个黑色窗口，可以将程序打包成exe文件发布。</p>
<h2 id="五、文件下载"><a href="#五、文件下载" class="headerlink" title="五、文件下载"></a>五、文件下载</h2><p>零积分下载整个程序源码：<a href="https://download.csdn.net/download/yushuaigee/12362232">用Python实现一个软件自动升级系统</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底弄懂Python标准库源码（二）—— os模块（续）</title>
    <url>/2020/09/09/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Python%E6%A0%87%E5%87%86%E5%BA%93%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20os%E6%A8%A1%E5%9D%97%EF%BC%88%E7%BB%AD%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/108492310">https://blog.csdn.net/yushuaigee/article/details/108492310</a></p>
</blockquote>
<p>本文续 <a href="https://blog.csdn.net/yushuaigee/article/details/106755148">彻底弄懂Python标准库源码（一）—— os模块</a></p>
<p>本文所用 Python3.8.3 标准库 os.py文件, 可以在CPython<a href="https://github.com/python/cpython/blob/3.8/Lib/os.py">官方GitHub地址</a>下载 。</p>
<p><strong>目录</strong></p>
<p><a href="#%E7%AC%AC423~529%E8%A1%8C%20fwalk%E2%80%94%E2%80%94%E7%9B%AE%E5%BD%95%E6%A0%91%E7%94%9F%E6%88%90%E5%99%A8">第423~529行 fwalk——目录树生成器</a></p>
<p><a href="#%E7%AC%AC531~654%E8%A1%8C%20exec%E5%87%BD%E6%95%B0%E6%97%8F">第531~654行 exec函数族</a></p>
<p><a href="#%E7%AC%AC657~713%E8%A1%8C%20_Environ%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BF%A1%E6%81%AF%E7%9A%84%E7%B1%BB">第657~713行 _Environ——环境变量信息的类</a></p>
<p><a href="#%E7%AC%AC715~721%E8%A1%8C%20os.putenv%E2%80%94%E2%80%94%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第715~721行 os.putenv——设置环境变量</a></p>
<p><a href="#%E7%AC%AC723~729%E8%A1%8C%20os.unsetenv%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第723~729行 os.unsetenv——删除环境变量</a></p>
<p><a href="#%E7%AC%AC731~759%E8%A1%8C%20os.environ%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BF%A1%E6%81%AF">第731~759行 os.environ——环境变量信息</a></p>
<p><a href="#%E7%AC%AC766~770%E8%A1%8C%20getenv%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第766~770行 getenv——获取环境变量</a></p>
<p><a href="#%E7%AC%AC772~794%E8%A1%8C%20environb%EF%BC%8Cgetenvb%E2%80%94%E2%80%94%E5%AD%97%E8%8A%82%E5%9E%8B(byte)%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">第772~794行 environb，getenvb——字节型(byte)环境变量</a></p>
<p><a href="#%E7%AC%AC796~827%E8%A1%8C%20fsencode%EF%BC%8Cfsdecode%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E5%90%8D%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81">第796~827行 fsencode，fsdecode——路径名的编码和解码</a></p>
<p><a href="#%E7%AC%AC829~970%E8%A1%8C%20spawn%E5%87%BD%E6%95%B0%E6%97%8F">第829~970行 spawn函数族</a></p>
<p><a href="#%E7%AC%AC973~1016%E8%A1%8C%20popen%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8Ccmd%E6%88%96%E8%80%85shell%E5%91%BD%E4%BB%A4">第973~1016行 popen——执行cmd或者shell命令</a></p>
<p><a href="#%E7%AC%AC1018~1023%E8%A1%8C%20fdopen%E2%80%94%E2%80%94%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">第1018~1023行 fdopen——打开文件</a></p>
<p><a href="#%E7%AC%AC1026~1061%E8%A1%8C%20fspath%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E6%A0%87%E5%87%86%E5%8C%96">第1026~1061行 fspath——路径标准化</a></p>
<p><a href="#%E7%AC%AC1064~1077%E8%A1%8C%20PathLike%E2%80%94%E2%80%94%E4%BB%80%E4%B9%88%E6%98%AFPathLike">第1064~1077行 PathLike——什么是PathLike</a></p>
<p><a href="#%E7%AC%AC1080~1115%E8%A1%8C%20add_dll_directory%E2%80%94%E2%80%94%20%E6%B7%BB%E5%8A%A0DLL%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84">第1080~1115行 add_dll_directory—— 添加DLL文件搜索路径</a></p>
<p><a href="#%E6%80%BB%E7%BB%93">总结</a></p>
<p><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></p>
<h3 id="第423-529行-fwalk——目录树生成器"><a href="#第423-529行-fwalk——目录树生成器" class="headerlink" title="第423~529行 fwalk——目录树生成器"></a>第423~529行 fwalk——目录树生成器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;<span class="built_in">open</span>, stat&#125; &amp;lt;= supports_dir_fd <span class="keyword">and</span> &#123;scandir, stat&#125; &amp;lt;= supports_fd:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fwalk</span>(<span class="params">top=<span class="string">&quot;.&quot;</span>, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, *, follow_symlinks=<span class="literal">False</span>, dir_fd=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Directory tree generator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This behaves exactly like walk(), except that it yields a 4-tuple</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            dirpath, dirnames, filenames, dirfd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        `dirpath`, `dirnames` and `filenames` are identical to walk() output,</span></span><br><span class="line"><span class="string">        and `dirfd` is a file descriptor referring to the directory `dirpath`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The advantage of fwalk() over walk() is that it&#x27;s safe against symlink</span></span><br><span class="line"><span class="string">        races (when follow_symlinks is False).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If dir_fd is not None, it should be a file descriptor open to a directory,</span></span><br><span class="line"><span class="string">          and top should be relative; top will then be relative to that directory.</span></span><br><span class="line"><span class="string">          (dir_fd is always supported for fwalk.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Caution:</span></span><br><span class="line"><span class="string">        Since fwalk() yields file descriptors, those are only valid until the</span></span><br><span class="line"><span class="string">        next iteration step, so you should dup() them if you want to keep them</span></span><br><span class="line"><span class="string">        for a longer period.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        import os</span></span><br><span class="line"><span class="string">        for root, dirs, files, rootfd in os.fwalk(&#x27;python/Lib/email&#x27;):</span></span><br><span class="line"><span class="string">            print(root, &quot;consumes&quot;, end=&quot;&quot;)</span></span><br><span class="line"><span class="string">            print(sum(os.stat(name, dir_fd=rootfd).st_size for name in files),</span></span><br><span class="line"><span class="string">                  end=&quot;&quot;)</span></span><br><span class="line"><span class="string">            print(&quot;bytes in&quot;, len(files), &quot;non-directory files&quot;)</span></span><br><span class="line"><span class="string">            if &#x27;CVS&#x27; in dirs:</span></span><br><span class="line"><span class="string">                dirs.remove(&#x27;CVS&#x27;)  # don&#x27;t visit CVS directories</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(top, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(top, <span class="string">&#x27;__index__&#x27;</span>):</span><br><span class="line">            top = fspath(top)</span><br><span class="line">        <span class="comment"># Note: To guard against symlink races, we use the standard</span></span><br><span class="line">        <span class="comment"># lstat()/open()/fstat() trick.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> follow_symlinks:</span><br><span class="line">            orig_st = stat(top, follow_symlinks=<span class="literal">False</span>, dir_fd=dir_fd)</span><br><span class="line">        topfd = <span class="built_in">open</span>(top, O_RDONLY, dir_fd=dir_fd)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> (follow_symlinks <span class="keyword">or</span> (st.S_ISDIR(orig_st.st_mode) <span class="keyword">and</span></span><br><span class="line">                                    path.samestat(orig_st, stat(topfd)))):</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">from</span> _fwalk(topfd, top, <span class="built_in">isinstance</span>(top, <span class="built_in">bytes</span>),</span><br><span class="line">                                  topdown, onerror, follow_symlinks)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            close(topfd)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fwalk</span>(<span class="params">topfd, toppath, isbytes, topdown, onerror, follow_symlinks</span>):</span></span><br><span class="line">        <span class="comment"># Note: This uses O(depth of the directory tree) file descriptors: if</span></span><br><span class="line">        <span class="comment"># necessary, it can be adapted to only require O(1) FDs, see issue</span></span><br><span class="line">        <span class="comment"># #13734.</span></span><br><span class="line"></span><br><span class="line">        scandir_it = scandir(topfd)</span><br><span class="line">        dirs = []</span><br><span class="line">        nondirs = []</span><br><span class="line">        entries = <span class="literal">None</span> <span class="keyword">if</span> topdown <span class="keyword">or</span> follow_symlinks <span class="keyword">else</span> []</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> scandir_it:</span><br><span class="line">            name = entry.name</span><br><span class="line">            <span class="keyword">if</span> isbytes:</span><br><span class="line">                name = fsencode(name)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> entry.is_dir():</span><br><span class="line">                    dirs.append(name)</span><br><span class="line">                    <span class="keyword">if</span> entries <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        entries.append(entry)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nondirs.append(name)</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># Add dangling symlinks, ignore disappeared files</span></span><br><span class="line">                    <span class="keyword">if</span> entry.is_symlink():</span><br><span class="line">                        nondirs.append(name)</span><br><span class="line">                <span class="keyword">except</span> OSError:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> topdown:</span><br><span class="line">            <span class="keyword">yield</span> toppath, dirs, nondirs, topfd</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> dirs <span class="keyword">if</span> entries <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="built_in">zip</span>(dirs, entries):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> follow_symlinks:</span><br><span class="line">                    <span class="keyword">if</span> topdown:</span><br><span class="line">                        orig_st = stat(name, dir_fd=topfd, follow_symlinks=<span class="literal">False</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">assert</span> entries <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">                        name, entry = name</span><br><span class="line">                        orig_st = entry.stat(follow_symlinks=<span class="literal">False</span>)</span><br><span class="line">                dirfd = <span class="built_in">open</span>(name, O_RDONLY, dir_fd=topfd)</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">                <span class="keyword">if</span> onerror <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    onerror(err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> follow_symlinks <span class="keyword">or</span> path.samestat(orig_st, stat(dirfd)):</span><br><span class="line">                    dirpath = path.join(toppath, name)</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">from</span> _fwalk(dirfd, dirpath, isbytes,</span><br><span class="line">                                      topdown, onerror, follow_symlinks)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                close(dirfd)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> topdown:</span><br><span class="line">            <span class="keyword">yield</span> toppath, dirs, nondirs, topfd</span><br><span class="line"></span><br><span class="line">    __all__.append(<span class="string">&quot;fwalk&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">I/O子系统的层次结构&lt;/a&gt;) 。 其实在这里只需要知道 os.Popen 和 原始subprocess.Popen 的区别是 os.Popen会把返回值用 _wrap_close 封装一次。&lt;/p&gt; </span><br><span class="line">&lt;h3 id=<span class="string">&quot;%E7%AC%AC1018~1023%E8%A1%8C%20fdopen%E2%80%94%E2%80%94%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6&quot;</span>&gt;第<span class="number">1018</span>~<span class="number">1023</span>行 fdopen——打开文件&lt;/h3&gt; </span><br><span class="line">&lt;pre&gt;&lt;code class=<span class="string">&quot;language-python&quot;</span>&gt;# Supply os.fdopen()</span><br><span class="line">def fdopen(fd, *args, **kwargs):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(fd, <span class="keyword">int</span>):</span><br><span class="line">        raise TypeError(<span class="string">&quot;invalid fd type (%s, expected integer)&quot;</span> % type(fd))</span><br><span class="line">    <span class="keyword">import</span> io</span><br><span class="line">    <span class="keyword">return</span> io.open(fd, *args, **kwargs)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p> 示例 ：<strong>os.execle(‘/usr/bin/cat’, ‘/root/test.py’, ‘/root/test2.py’, {‘SYS’: ‘/root/bin’})</strong> </p>
</blockquote>
<blockquote>
<p> 示例 ：<strong>os.execlpe(‘cat’, ‘/root/test.py’, ‘/root/test2.py’, {‘SYS’: ‘/root/bin’})</strong> </p>
</blockquote>
<blockquote>
<p> 示例 ：<strong>os.execvp(‘cat’, [‘/root/test.py’, ‘/root/test2.py’])</strong> </p>
</blockquote>
<h3 id="第657-713行-Environ——环境变量信息的类"><a href="#第657-713行-Environ——环境变量信息的类" class="headerlink" title="第657~713行 _Environ——环境变量信息的类"></a>第657~713行 _Environ——环境变量信息的类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Change environ to automatically call putenv(), unsetenv if they exist.</span></span><br><span class="line"><span class="keyword">from</span> _collections_abc <span class="keyword">import</span> MutableMapping</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Environ</span>(<span class="params">MutableMapping</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data, encodekey, decodekey, encodevalue, decodevalue, putenv, unsetenv</span>):</span></span><br><span class="line">        self.encodekey = encodekey</span><br><span class="line">        self.decodekey = decodekey</span><br><span class="line">        self.encodevalue = encodevalue</span><br><span class="line">        self.decodevalue = decodevalue</span><br><span class="line">        self.putenv = putenv</span><br><span class="line">        self.unsetenv = unsetenv</span><br><span class="line">        self._data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = self._data[self.encodekey(key)]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># raise KeyError with the original key value</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.decodevalue(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        key = self.encodekey(key)</span><br><span class="line">        value = self.encodevalue(value)</span><br><span class="line">        self.putenv(key, value)</span><br><span class="line">        self._data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        encodedkey = self.encodekey(key)</span><br><span class="line">        self.unsetenv(encodedkey)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self._data[encodedkey]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># raise KeyError with the original key value</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># list() from dict object is an atomic operation</span></span><br><span class="line">        keys = <span class="built_in">list</span>(self._data)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">yield</span> self.decodekey(key)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;environ(&#123;&lt;!-- --&gt;&#123;&lt;!-- --&gt;&#123;&#125;&#125;&#125;)&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;, &#x27;</span>.join(</span><br><span class="line">            (<span class="string">&#x27;&#123;!r&#125;: &#123;!r&#125;&#x27;</span>.<span class="built_in">format</span>(self.decodekey(key), self.decodevalue(value))</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> self._data.items())))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dict</span>(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setdefault</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            self[key] = value</span><br><span class="line">        <span class="keyword">return</span> self[key]</span><br></pre></td></tr></table></figure>
<h3 id="第723-729行-os-unsetenv——删除环境变量"><a href="#第723-729行-os-unsetenv——删除环境变量" class="headerlink" title="第723~729行 os.unsetenv——删除环境变量"></a>第723~729行 os.unsetenv——删除环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _unsetenv = unsetenv</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    _unsetenv = <span class="keyword">lambda</span> key: _putenv(key, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;unsetenv&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> __all__:</span><br><span class="line">        __all__.append(<span class="string">&quot;unsetenv&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="第766-770行-getenv——获取环境变量"><a href="#第766-770行-getenv——获取环境变量" class="headerlink" title="第766~770行 getenv——获取环境变量"></a>第766~770行 getenv——获取环境变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getenv</span>(<span class="params">key, default=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Get an environment variable, return None if it doesn&#x27;t exist.</span></span><br><span class="line"><span class="string">    The optional second argument can specify an alternate default.</span></span><br><span class="line"><span class="string">    key, default and the result are str.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> environ.get(key, default)</span><br></pre></td></tr></table></figure>
<h3 id="第796-827行-fsencode，fsdecode——路径名的编码和解码"><a href="#第796-827行-fsencode，fsdecode——路径名的编码和解码" class="headerlink" title="第796~827行 fsencode，fsdecode——路径名的编码和解码"></a>第796~827行 fsencode，fsdecode——路径名的编码和解码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fscodec</span>():</span></span><br><span class="line">    encoding = sys.getfilesystemencoding()</span><br><span class="line">    errors = sys.getfilesystemencodeerrors()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fsencode</span>(<span class="params">filename</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encode filename (an os.PathLike, bytes, or str) to the filesystem</span></span><br><span class="line"><span class="string">        encoding with &#x27;surrogateescape&#x27; error handler, return bytes unchanged.</span></span><br><span class="line"><span class="string">        On Windows, use &#x27;strict&#x27; error handler if the file system encoding is</span></span><br><span class="line"><span class="string">        &#x27;mbcs&#x27; (which is the default encoding).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        filename = fspath(filename)  <span class="comment"># Does type-checking of `filename`.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(filename, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">return</span> filename.encode(encoding, errors)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fsdecode</span>(<span class="params">filename</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decode filename (an os.PathLike, bytes, or str) from the filesystem</span></span><br><span class="line"><span class="string">        encoding with &#x27;surrogateescape&#x27; error handler, return str unchanged. On</span></span><br><span class="line"><span class="string">        Windows, use &#x27;strict&#x27; error handler if the file system encoding is</span></span><br><span class="line"><span class="string">        &#x27;mbcs&#x27; (which is the default encoding).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        filename = fspath(filename)  <span class="comment"># Does type-checking of `filename`.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(filename, <span class="built_in">bytes</span>):</span><br><span class="line">            <span class="keyword">return</span> filename.decode(encoding, errors)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fsencode, fsdecode</span><br><span class="line"></span><br><span class="line">fsencode, fsdecode = _fscodec()</span><br><span class="line"><span class="keyword">del</span> _fscodec</span><br></pre></td></tr></table></figure>
<ul>
<li> **spawnv **函数， 调用_spawnvef，最终执行的是 execv，执行一个可执行文件替代现有进程。 </li>
<li> **spawnve **函数， 调用_spawnvef，最终执行的是 execve，执行一个可执行文件替代现有进程。 </li>
<li> <strong>spawnvp</strong> 函数， 调用_spawnvef，最终执行的是 execvp，执行一个可执行文件替代现有进程。 </li>
<li> **spawnvp **函数， 调用_spawnvef，最终执行的是 execvpe，执行一个可执行文件替代现有进程。 <h3 id="第973-1016行-popen——执行cmd或者shell命令"><a href="#第973-1016行-popen——执行cmd或者shell命令" class="headerlink" title="第973~1016行 popen——执行cmd或者shell命令"></a>第973~1016行 popen——执行cmd或者shell命令</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Supply os.popen()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">popen</span>(<span class="params">cmd, mode=<span class="string">&quot;r&quot;</span>, buffering=-<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(cmd, <span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;invalid cmd type (%s, expected string)&quot;</span> % <span class="built_in">type</span>(cmd))</span><br><span class="line">    <span class="keyword">if</span> mode <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&quot;r&quot;</span>, <span class="string">&quot;w&quot;</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;invalid mode %r&quot;</span> % mode)</span><br><span class="line">    <span class="keyword">if</span> buffering == <span class="number">0</span> <span class="keyword">or</span> buffering <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;popen() does not support unbuffered streams&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> subprocess, io</span><br><span class="line">    <span class="keyword">if</span> mode == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">        proc = subprocess.Popen(cmd,</span><br><span class="line">                                shell=<span class="literal">True</span>,</span><br><span class="line">                                stdout=subprocess.PIPE,</span><br><span class="line">                                bufsize=buffering)</span><br><span class="line">        <span class="keyword">return</span> _wrap_close(io.TextIOWrapper(proc.stdout), proc)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        proc = subprocess.Popen(cmd,</span><br><span class="line">                                shell=<span class="literal">True</span>,</span><br><span class="line">                                stdin=subprocess.PIPE,</span><br><span class="line">                                bufsize=buffering)</span><br><span class="line">        <span class="keyword">return</span> _wrap_close(io.TextIOWrapper(proc.stdin), proc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Helper for popen() -- a proxy for a file whose close waits for the process</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_wrap_close</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, stream, proc</span>):</span></span><br><span class="line">        self._stream = stream</span><br><span class="line">        self._proc = proc</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._stream.close()</span><br><span class="line">        returncode = self._proc.wait()</span><br><span class="line">        <span class="keyword">if</span> returncode == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> returncode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> returncode &amp;lt;&amp;lt; <span class="number">8</span>  <span class="comment"># Shift left to match old behavior</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        self.close()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(self._stream, name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self._stream)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Supply os.fdopen()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fdopen</span>(<span class="params">fd, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(fd, <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;invalid fd type (%s, expected integer)&quot;</span> % <span class="built_in">type</span>(fd))</span><br><span class="line">    <span class="keyword">import</span> io</span><br><span class="line">    <span class="keyword">return</span> io.<span class="built_in">open</span>(fd, *args, **kwargs)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传入打开文件描述符 <strong>fd</strong> ，返回对应文件的对象。类似内建 open 函数，二者接受同样的参数。不同之处在于fdopen第一个参数应该为整数(文件描述符)。关于最后的 r<strong>eturn  io.open</strong> , <a href="https://docs.python.org/3.8/library/io.html#io.open">官方文档</a> 说 io.open 和内建函数 open 的区别是：io.open 是 open 的别名 (This is an alias for the builtin open() function)。</p>
<h3 id="第1026-1061行-fspath——路径标准化"><a href="#第1026-1061行-fspath——路径标准化" class="headerlink" title="第1026~1061行 fspath——路径标准化"></a>第1026~1061行 fspath——路径标准化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For testing purposes, make sure the function is available when the C</span></span><br><span class="line"><span class="comment"># implementation exists.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_fspath</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the path representation of a path-like object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If str or bytes is passed in, it is returned unchanged. Otherwise the</span></span><br><span class="line"><span class="string">    os.PathLike interface is used to get the path representation. If the</span></span><br><span class="line"><span class="string">    path representation is not str or bytes, TypeError is raised. If the</span></span><br><span class="line"><span class="string">    provided path is not str, bytes, or os.PathLike, TypeError is raised.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(path, (<span class="built_in">str</span>, <span class="built_in">bytes</span>)):</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Work from the object&#x27;s type to match method resolution of other magic</span></span><br><span class="line">    <span class="comment"># methods.</span></span><br><span class="line">    path_type = <span class="built_in">type</span>(path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        path_repr = path_type.__fspath__(path)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(path_type, <span class="string">&#x27;__fspath__&#x27;</span>):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;expected str, bytes or os.PathLike object, &quot;</span></span><br><span class="line">                            <span class="string">&quot;not &quot;</span> + path_type.__name__)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(path_repr, (<span class="built_in">str</span>, <span class="built_in">bytes</span>)):</span><br><span class="line">        <span class="keyword">return</span> path_repr</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;expected &#123;&#125;.__fspath__() to return str or bytes, &quot;</span></span><br><span class="line">                        <span class="string">&quot;not &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path_type.__name__,</span><br><span class="line">                                        <span class="built_in">type</span>(path_repr).__name__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># If there is no C implementation, make the pure Python version the</span></span><br><span class="line"><span class="comment"># implementation as transparently as possible.</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _exists(<span class="string">&#x27;fspath&#x27;</span>):</span><br><span class="line">    fspath = _fspath</span><br><span class="line">    fspath.__name__ = <span class="string">&quot;fspath&quot;</span></span><br></pre></td></tr></table></figure>
<p>第1028~1055行， _fspath 方法的作用是返回一个 os 模块能处理的标准路径形式，其实就是字符串。如果传入的是 str 或 bytes 类型的字符串，将原样返回。否则将调用传入参数的 <strong>fspath</strong> 方法，如果得到的是一个 str 或 bytes 类型的对象，那就返回这个值。<strong>fspath</strong> 方法应该是这样定义的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__fspath__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> self.path.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p> 第1059~1061行，只有在 buildin 的内建方法 globals() 里不包含 fspath 时，才会调用上面的_fspath方法去定义 os.fspath。实测 windows 下不会走这个分支，也就是说 Windows 下内建方法已经存在 fspath 了。</p>
<h3 id="第1064-1077行-PathLike——什么是PathLike"><a href="#第1064-1077行-PathLike——什么是PathLike" class="headerlink" title="第1064~1077行 PathLike——什么是PathLike"></a>第1064~1077行 PathLike——什么是PathLike</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PathLike</span>(<span class="params">abc.ABC</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Abstract base class for implementing the file system path protocol.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__fspath__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return the file system path representation of the object.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span>(<span class="params">cls, subclass</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> PathLike:</span><br><span class="line">            <span class="keyword">return</span> _check_methods(subclass, <span class="string">&#x27;__fspath__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br></pre></td></tr></table></figure>
<p>前面提到好多次，路径要是 PathLike 的，这个抽象类就是为了解释到底什么样的类才是 “ PathLike的”。里面用到了@abc.abstractmethod 装饰器，说明这个类是抽象类不能被实例化。但是可以被继承， <strong>subclasshook</strong> 检查子类是否实现了<strong>fspath</strong> 方法。也就是说一个类如果是 “PathLike 的”，首先它必须要实现 <strong>fspath</strong> 方法。</p>
<h3 id="第1080-1115行-add-dll-directory——-添加DLL文件搜索路径"><a href="#第1080-1115行-add-dll-directory——-添加DLL文件搜索路径" class="headerlink" title="第1080~1115行 add_dll_directory—— 添加DLL文件搜索路径"></a>第1080~1115行 add_dll_directory—— 添加DLL文件搜索路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">_AddedDllDirectory</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path, cookie, remove_dll_directory</span>):</span></span><br><span class="line">            self.path = path</span><br><span class="line">            self._cookie = cookie</span><br><span class="line">            self._remove_dll_directory = remove_dll_directory</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">            self._remove_dll_directory(self._cookie)</span><br><span class="line">            self.path = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">            self.close()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">if</span> self.path:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&amp;lt;AddedDllDirectory(&#123;!r&#125;)&amp;gt;&quot;</span>.<span class="built_in">format</span>(self.path)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&amp;lt;AddedDllDirectory()&amp;gt;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_dll_directory</span>(<span class="params">path</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Add a path to the DLL search path.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This search path is used when resolving dependencies for imported</span></span><br><span class="line"><span class="string">        extension modules (the module itself is resolved through sys.path),</span></span><br><span class="line"><span class="string">        and also by ctypes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Remove the directory by calling close() on the returned object or</span></span><br><span class="line"><span class="string">        using it in a with statement.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> nt</span><br><span class="line">        cookie = nt._add_dll_directory(path)</span><br><span class="line">        <span class="keyword">return</span> _AddedDllDirectory(</span><br><span class="line">            path,</span><br><span class="line">            cookie,</span><br><span class="line">            nt._remove_dll_directory</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Python中调用C/C++编写的dll文件时，需要提供这个dll文件的搜索路径(类似环境变量)。add_dll_directory 函数就用于在导入扩展模块或使用 ctypes 加载 DLL 时，依赖提供额外搜索路径。调用返回的_AddedDllDirectory 的close方法可以删除这个路径。主要调用 nt._add_dll_directory方法实现，所以只在Windows系统有效。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>《彻底弄懂Python标准库源码》计划，才完成第一篇，最大的感受就是读标准库源码跟我想象很不一样，太太太难了。我以为标准库一定都很通俗易懂吧，应该挺简单的吧，可事实上看过来，这些标准库方法在外面调用起来的确挺优雅的，它们的实现过程还挺复杂的。我们调用的时候只需要关注入参和出参是什么就行了，有时候感觉好神奇好方便啊，我传个A竟然能返回我想要的B。而研究源码就是要看它为什么是这样的，为什么这么神奇，这就要求每一行代码的意思都要搞明白。作为一个程序员，我们要一直保持着一颗好奇心，我们不会相信有什么黑科技，我们一定要看看这些 magic 的背后是什么原理 。</p>
<p>可能也和第一篇选的os库有关系，这个和系统交互的库，大部分是把C的库进行了一层封装。后半部分涉及很多系统底层的的东西，好多不了解的知识，导致看的很煎熬，中间各种查资料补课，还另外补充了几篇博客。好在没想过放弃，自己立的 flag 一定要把它完成。</p>
<p>本来想学习标准库的优雅写法，可是看完我发现我并学不会，os库也不是想象的那么优雅，更多的是为了更有效地实现功能。感觉要想达到学习代码写法的目的，还是看 requests 这种有名的第三方库比较好。还有这篇博客这种一行一行贴代码流水账式的分析意义也不大，白白占用很大篇幅，以后考虑换一种风格。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol>
<li>如果只是想看 os 库的用法，官方文档写的很全很详细</li>
</ol>
<p>    官方文档 <a href="https://docs.python.org/zh-cn/3/library/os.html">os — 多种操作系统接口</a> </p>
<p>    官方文档  <a href="https://docs.python.org/zh-cn/3/library/io.html">io — 处理流的核心工具</a></p>
<p>2. <a href="https://blog.csdn.net/yushuaigee/article/details/107883964">彻底弄懂 Linux 下的文件描述符 —— 杰克小麻雀</a></p>
<p>3. <a href="https://blog.csdn.net/yushuaigee/article/details/107567001">彻底弄懂 Python3中入参里的*号的作用 —— 杰克小麻雀</a></p>
<p>4. <a href="https://en.wikipedia.org/wiki/Symlink_race">Symlink race —- Wikipedia</a></p>
<p>5. <a href="https://blog.csdn.net/u011150719/article/details/50865280">linux stat函数（获取文件详细信息）—— mastodon</a></p>
<p>6. <a href="https://blog.csdn.net/guoping16/article/details/6583383">exec函数 —— guoping16</a></p>
<p>7. <a href="https://blog.csdn.net/xiaosi2468/article/details/6401874">spawn 系列函数 —— xiaosi2468</a></p>
<p>8. <a href="https://blog.csdn.net/jason314/article/details/5640969">linux中fork函数详解 —— jason314</a> </p>
<p>9.  <a href="https://www.unix.com/unix-for-advanced-and-expert-users/178644-spawn-vs-fork.html">spawn() Vs. fork() —— The UNIX and Linux Forums</a></p>
<p>10. <a href="https://www.cnblogs.com/lincappu/p/12801539.html">python3之模块io —— lincappu</a> </p>
<p>11. <a href="http://c.biancheng.net/cpp/html/2632.html">I/O子系统的层次结构 —— C语言中文网 </a></p>
<p>前文见 </p>
<p><a href="https://blog.csdn.net/yushuaigee/article/details/106329590">彻底弄懂Python标准库源码（零）—— 学习计划</a></p>
<p><a href="https://blog.csdn.net/yushuaigee/article/details/106755148">彻底弄懂Python标准库源码（一）—— os模块</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>python</tag>
        <tag>编程语言</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底理解Python中的&quot;指针&quot;</title>
    <url>/2019/09/07/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%20%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<blockquote>
<p>作者: 杰克小麻雀<br>原文链接: <a href="https://blog.csdn.net/yushuaigee/article/details/96745994">https://blog.csdn.net/yushuaigee/article/details/96745994</a></p>
</blockquote>
<p>学过C，C++语言的同学都知道一个重要的概念——指针。</p>
<p>Python中有指针的概念吗？我查了许多资料，没人认明确地说Python中有“指针”这一定义。在我看来，Python中虽然没有“指针”的定义，但是却随处可见“指针”的影子。不过这里的“指针”并不完全等同于c语言中的指针，只能是加引号的“指针”。</p>
<h3 id="一、两个Python例子引发的思考"><a href="#一、两个Python例子引发的思考" class="headerlink" title="一、两个Python例子引发的思考"></a>一、两个Python例子引发的思考</h3><p>第一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --coding=utf-8--</span></span><br><span class="line"><span class="comment"># 第一个例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：将参数发送出去（这里简化为打印）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;send: &#x27;</span>, param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_list删掉最后一个元素发送出去，也就是[&#x27;a&#x27;]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun1...&#x27;</span>)</span><br><span class="line">    param.pop()</span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_list增加一个元素&#x27;c&#x27;发送出去，也就是[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun2...&#x27;</span>)</span><br><span class="line">    param.append(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_list发送出去，也就是[&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun3...&#x27;</span>)</span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    fun1(test_list)</span><br><span class="line">    fun2(test_list)</span><br><span class="line">    fun3(test_list)</span><br></pre></td></tr></table></figure>
<p>我预期的结果为：</p>
<blockquote>
<p> run fun1…<br> send:  [‘a’]<br> run fun2…<br> send:  [‘a’, ‘b’, ‘c’]<br> run fun3…<br> send:  [‘a’, ‘b’] </p>
</blockquote>
<p>实际的结果为：</p>
<blockquote>
<p> run fun1…<br> send:  [‘a’]<br> run fun2…<br> send:  [‘a’, ‘c’]<br> run fun3…<br> send:  [‘a’, ‘c’] </p>
</blockquote>
<p> 按照代码表面来理解，三个函数只是对传进来的“形参”param进行了改变，对原来的“实参”test_list并没有影响，所以每个函数传进去的test_list应该都是 [‘a’, ‘b’]。可是从结果来看，每个函数里的“形参”被改变后，外面的“实参”也跟着改变了。在原来的代码基础上加几条打印，可以看到就是这样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_list = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">    print(<span class="string">&#x27;test_list:&#x27;</span>, test_list)</span><br><span class="line">    fun1(test_list)</span><br><span class="line">    print(<span class="string">&#x27;test_list:&#x27;</span>, test_list)</span><br><span class="line">    fun2(test_list)</span><br><span class="line">    print(<span class="string">&#x27;test_list:&#x27;</span>, test_list)</span><br><span class="line">    fun3(test_list)</span><br><span class="line">    print(<span class="string">&#x27;test_list:&#x27;</span>, test_list)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> test_list: [‘a’, ‘b’]<br> run fun1…<br> send:  [‘a’]<br> test_list: [‘a’]<br> run fun2…<br> send:  [‘a’, ‘c’]<br> test_list: [‘a’, ‘c’]<br> run fun3…<br> send:  [‘a’, ‘c’]<br> test_list: [‘a’, ‘c’] </p>
</blockquote>
<p>所以上面例子中三个函数里的param和test_list其实是一个对象，fun1里的pop和fun2里的append都是操作的同一个变量(对象)，也就是说传递到三个函数中的参数是test_list的“地址”。类似C语言中，函数的参数为指针类型。</p>
<p> 第二个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --coding=utf-8--</span></span><br><span class="line"><span class="comment"># 第二个例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：将参数发送出去（这里简化为打印）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;send: &#x27;</span>, param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_value的值加上1发送出去，也就是2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun1...&#x27;</span>)</span><br><span class="line">    param += <span class="number">1</span></span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_value的值减去1发送出去，也就是0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun2...&#x27;</span>)</span><br><span class="line">    param -= <span class="number">1</span></span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法预期功能：把test_value发送出去，也就是1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span>(<span class="params">param</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;run fun3...&#x27;</span>)</span><br><span class="line">    send(param)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test_value = <span class="number">1</span></span><br><span class="line">    <span class="comment"># print(&#x27;test_value:&#x27;, test_value)</span></span><br><span class="line">    fun1(test_value)</span><br><span class="line">    <span class="comment"># print(&#x27;test_value:&#x27;, test_value)</span></span><br><span class="line">    fun2(test_value)</span><br><span class="line">    <span class="comment"># print(&#x27;test_value:&#x27;, test_value)</span></span><br><span class="line">    fun3(test_value)</span><br><span class="line">    <span class="comment"># print(&#x27;test_value:&#x27;, test_value)</span></span><br></pre></td></tr></table></figure>
<p>实际输出结果：</p>
<blockquote>
<p> run fun1…<br> send:  2<br> run fun2…<br> send:  0<br> run fun3…<br> send:  1 </p>
</blockquote>
<p> 这次的结果和上次不太一样，结果表明三个函数里的param和test_value并不是一个对象，fun1里的加1和fun2里的减1操作之后，并没有影响test_value的值，也就是说传递到三个函数中的参数是test_list的“值”(的拷贝)。那么什么时候传的是指针，什么时候传的是值呢？其实只要了解一下Python中创建对象的具体过程，问题就迎刃而解了。</p>
<h3 id="二、Python中的不可变对象和可变对象"><a href="#二、Python中的不可变对象和可变对象" class="headerlink" title="二、Python中的不可变对象和可变对象"></a>二、Python中的不可变对象和可变对象</h3><p>众所周知，Python中一切皆对象，每个对象至少包含三个数据：引用计数、类型和值。引用计数用于Python的GC机制，类型用于在CPython层运行时保证类型安全性，值就是对象关联的实际值。</p>
<p>Python对象分为不可变对象和可变对象。可变对象可以修改，上面第一个例子中的test_list（list类型）就属于可变对象，不可变对象无法更改，类似C语言中加了const修饰，上面第二个例子中的test_value（int类型）就属于不可变对象。</p>
<p><strong>不可变对象：int(整形)、str(字符串)、float(浮点型)、tuple(元组)</strong></p>
<p><strong>可变对象：dict(字典)、list(列表)、 set(集合）</strong></p>
<p>        <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/2019090622412710.png" alt="2019090622412710.png"></p>
<p>这里 x += 1 看似更改了 x 的值，实际上已经改变了ID，所以是新建了一个值。 </p>
<p>        <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/2019090622470785.png" alt="2019090622470785.png"></p>
<p>同样str类型的v可以重新赋值，但是不能更改元素。这就类似于C语言中加了const修饰的数组，不能更改它的内容，但是你可以将原来指向它指针改为指向别人。</p>
<p>可变对象的情形就不一样了，可以任意更改元素。ID不会变，直到重新赋值：</p>
<p>         <img src="https://cdn.jsdelivr.net/gh/yushuaige/myblog@master/img/20190906225303542.png" alt="20190906225303542.png"></p>
<h3 id="三、C语言中定义变量的过程"><a href="#三、C语言中定义变量的过程" class="headerlink" title="三、C语言中定义变量的过程"></a>三、C语言中定义变量的过程</h3><blockquote>
<p> 例如：<strong>int x = 2337;</strong> </p>
</blockquote>
<p>在C语言中，这行代码的执行分为三步：</p>
<p><strong>1. 为整数分配足够的内存</strong></p>
<p><strong>2. 将值2337分配给该内存位置</strong></p>
<p><strong>3. 将x指向该值</strong></p>
<p>简化的内存视图如下：</p>
<img alt="Xçåå­è¡¨ç¤ºï¼2337ï¼" class="has" height="111" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy5yZWFscHl0aG9uLmNvbS9tZWRpYS9jX21lbW9yeTEuMzM0ZmU3YzEzZTgyLnBuZw?x-oss-process=image/format,png" width="201">

<blockquote>
<p> 如果将x重新赋值：<strong>x = 2338;</strong> </p>
</blockquote>
<p>上面的代码为变量 x 重新分配了一个新值2338，从而<strong>覆盖</strong>了以前的值2337。这意味着在这里变量 x 是<strong>可变的</strong>。更新简化的内存视图如下：</p>
<img alt="New In-Memory representation of X (2338)" class="has" height="112" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy5yZWFscHl0aG9uLmNvbS9tZWRpYS9jX21lbW9yeTIuMTRkNjM4ZGFmNzE4LnBuZw?x-oss-process=image/format,png" width="204">

<p>x 的地址并没有变，<strong>这意味着在C语言中定义变量时, x 它代表的是一个内存位置</strong>，可以理解为一个空盒子，而关键字 int 就确定了这个盒子的大小，我们可以将值2337放进这个盒子，也可以将2338放进这个盒子，因为它们是 int 型的值。</p>
<blockquote>
<p> 此时再引入一个新的变量：<strong>int y = x;</strong> </p>
</blockquote>
<p> 这时会创建一个新的 int 型的盒子 y ，再把 x 中的值赋值过来。在内存中是这样：</p>
<img alt="In-Memory representation of X (2338) and Y (2338)" class="has" height="121" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy5yZWFscHl0aG9uLmNvbS9tZWRpYS9jX21lbW9yeTMuNWFmZTExMGZhZjRkLnBuZw?x-oss-process=image/format,png" width="507">

<p>两个变量除了值都是 2338 之外，其他并没有任何关系。任意更改其中一个变量的值，另一个不会受到任何影响。</p>
<blockquote>
<p> 例如更改 y 的值为 2339：<strong>y = 2339;</strong> </p>
</blockquote>
<p> <img alt="Updated representation of Y (2339)" class="has" height="120" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy5yZWFscHl0aG9uLmNvbS9tZWRpYS9jX21lbW9yeTQuNDVhNDVkYmJmYWFiLnBuZw?x-oss-process=image/format,png" width="502"></p>
<h3 id="四、Python中定义对象的过程"><a href="#四、Python中定义对象的过程" class="headerlink" title="四、Python中定义对象的过程"></a>四、Python中定义对象的过程</h3><p>再看一下同样的代码，在Python中运行的情况。严格上来讲Python中的变量和C中的变量的意义不是等价的，Python中的变量或许叫做“名称”会更加贴切一点，看了下面的分析就会有所体会。</p>
<blockquote>
<p> 定义一个变量 x：<strong>x = 2337</strong> </p>
</blockquote>
<p>与C类似，上面的代码在执行过程中会分解为5步：</p>
<p><strong>1. 创建一个PyObject</strong></p>
<p><strong>2. 将PyObject的类型设置为整数型</strong></p>
<p><strong>3. 将PyObject的值设置为2337</strong></p>
<p><strong>4.创建一个变量（名称）x</strong></p>
<p><strong>5.将 x 指向新建的PyObject</strong></p>
<p><strong>6.将该PyObject的引用计数加 1</strong></p>
<p>简化的内存视图如下：</p>
<img alt="Python In-Memory representation of X (2337)" class="has" height="159" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy5yZWFscHl0aG9uLmNvbS9tZWRpYS9weV9tZW1vcnkxLjJiNmU1ZjhlNWJjOS5wbmc?x-oss-process=image/format,png" width="391">

<blockquote>
<p>  如果将x重新赋值：<strong>x = 2338</strong> </p>
</blockquote>
<p> 上面这行代码在Python中的执行过程和在C中有很大不同，具体过程是这样：</p>
<p><strong>1. 创建一个新的PyObject</strong></p>
<p><strong>2. 将PyObject的类型设置为整数型</strong></p>
<p><strong>3. 将PyObject的值设置为2338</strong></p>
<p><strong>4.将 x 指向新的PyObject</strong></p>
<p><strong>5.将新的PyObject的引用计数加 1</strong></p>
<p><strong>6.将旧的PyObject的引用计数减 1</strong></p>
<p>内存中的情况如下：</p>
<img alt="Python Name Pointing to new object (2338)" class="has" height="347" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy5yZWFscHl0aG9uLmNvbS9tZWRpYS9weV9tZW1vcnkyLjk5YmI0MzJjMzQzMi5wbmc?x-oss-process=image/format,png" width="407">

<p>引用计数位为0的原对象，将会被Python的内存管理机制销毁。这说明 x 它不是一个空盒子。</p>
<blockquote>
<p> 如果是这样呢：<strong>y = x</strong>  </p>
</blockquote>
<p> 在内存中会新建一个新名称（变量），但不用创建一个新对象，原来对象的引用计数变成了 2：</p>
<img alt="X and Y Names pointing to 2338" class="has" height="354" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy5yZWFscHl0aG9uLmNvbS9tZWRpYS9weV9tZW1vcnkzXzEuZWE0MzQ3MWQzYmY2LnBuZw?x-oss-process=image/format,png" width="415">

<p> 现在 x 和 y 都指向同一个对象，但是他们还是不可改变对象。</p>
<blockquote>
<p> 比如如果执行： <strong>y += 1</strong> </p>
</blockquote>
<p> 这和执行 y = 2339 的过程是一样的：</p>
<img alt="x name and y name different objects" class="has" height="285" src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9maWxlcy5yZWFscHl0aG9uLmNvbS9tZWRpYS9weV9tZW1vcnk0LjBhMTVlODQxNWExNS5wbmc?x-oss-process=image/format,png" width="521">

<p> 这样看来，我们在Python中不是新建变量，而是新建名称并绑定到变量，所以说Python中的变量和C中的变量的意义不是等价的。当然这只是不可变对象的情况，如果 x, y 是 list 这种类型可变对象，上面的代码改为：</p>
<blockquote>
<p> x = [1] # 新建一个PyObject1,名称为x，值为 [1],引用计数为 1<br> x = [2] # 新建一个PyObject2,名称x指向PyObject2,值为 [2],引用计数为1,PyObject1引用计数为0(回收)<br> y = x   # 新建一个名称y,指向PyObject2，值为 [2],引用计数改为 2<br> y.append(3) # PyObject2的值改为 [2,3],名称x和y依然都指向PyObject2,引用计数还是2 </p>
</blockquote>
<p>前三行代码执行时，内存情况和不可变对象是一样的，但是最后一行执行时，将不会新建一个新的对象，因为 list 是可变对象，它可以对象的值改成[2,3] , id还是原来的id（其实这里的id和C语言中的地址也不是完全等价的，只是类似）。这就是Python中可变对象和不可变对象的不同之处。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>综上所述，由Python中的两个例子产生Python中是否像C语言一样也有指针的疑惑，研究了Python中可变对象和不可变对象的区别，接着对比C语言和Python在创建变量时的不同。我以前总是想把Python和C语言联系起来，总是想将C语言中已有的定义和用法套用在Python上，这样虽然方便理解，但是也会产生许多困惑。随着对Python的底层探究地越来越多，我越来越发现Python中有许多新的东西，不能将它们简单地等价于C语言中已有的术语。</p>
<p>回到最开始的问题，Python中有“指针”吗？我的理解是，如果此处的指针是指C语言中的指针，那么答案是没有，如果这里的指针指的是C语言中的指针思想，那么答案是有。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul>
<li>Pointers in Python: What’s the Point? (Logan Jones) :<a href="https://realpython.com/pointers-in-python/#real-pointers-with-ctypes">https://realpython.com/pointers-in-python/#real-pointers-with-ctypes</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python指针</tag>
        <tag>可变对象</tag>
        <tag>Python</tag>
        <tag>python原理</tag>
        <tag>不可变对象</tag>
      </tags>
  </entry>
</search>
